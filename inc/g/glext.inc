'/*
'** Copyright (c) 2007-2012 The Khronos Group Inc.
'**
'** Permission is hereby granted, free of charge, to any person obtaining a
'** copy of this software and/or associated documentation files (the
'** "Materials"), to deal in the Materials without restriction, including
'** without limitation the rights to use, copy, modify, merge, publish,
'** distribute, sublicense, and/or sell copies of the Materials, and to
'** permit persons to whom the Materials are furnished to do so, subject to
'** the following conditions:
'**
'** The above copyright notice and this permission notice shall be included
'** in all copies or substantial portions of the Materials.
'**
'** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
'** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
'** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
'** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
'** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
'** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
'** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
'*/

'/*************************************************************/

'/* Header file version number, required by OpenGL ABI for Linux */
'/* glext.h last updated $Date: 2013-02-07 01:42:49 -0800 (Thu, 07 Feb 2013) $ */
'/* Current version at http://www.opengl.org/registry/ */

#INCLUDE THIS ONCE
%GLEXT_INC = 1

#INCLUDE ONCE "WINDOWS.INC"
#INCLUDE ONCE "GL.INC"
#INCLUDE ONCE "GLU.INC"

%GL_GLEXT_VERSION = 86

#IF NOT %DEF(%GL_VERSION_1_2)
%GL_UNSIGNED_BYTE_3_3_2                               = &H8032???
%GL_UNSIGNED_SHORT_4_4_4_4                            = &H8033???
%GL_UNSIGNED_SHORT_5_5_5_1                            = &H8034???
%GL_UNSIGNED_INT_8_8_8_8                              = &H8035???
%GL_UNSIGNED_INT_10_10_10_2                           = &H8036???
%GL_TEXTURE_BINDING_3D                                = &H806A???
%GL_PACK_SKIP_IMAGES                                  = &H806B???
%GL_PACK_IMAGE_HEIGHT                                 = &H806C???
%GL_UNPACK_SKIP_IMAGES                                = &H806D???
%GL_UNPACK_IMAGE_HEIGHT                               = &H806E???
%GL_TEXTURE_3D                                        = &H806F???
%GL_PROXY_TEXTURE_3D                                  = &H8070???
%GL_TEXTURE_DEPTH                                     = &H8071???
%GL_TEXTURE_WRAP_R                                    = &H8072???
%GL_MAX_3D_TEXTURE_SIZE                               = &H8073???
%GL_UNSIGNED_BYTE_2_3_3_REV                           = &H8362???
%GL_UNSIGNED_SHORT_5_6_5                              = &H8363???
%GL_UNSIGNED_SHORT_5_6_5_REV                          = &H8364???
%GL_UNSIGNED_SHORT_4_4_4_4_REV                        = &H8365???
%GL_UNSIGNED_SHORT_1_5_5_5_REV                        = &H8366???
%GL_UNSIGNED_INT_8_8_8_8_REV                          = &H8367???
%GL_UNSIGNED_INT_2_10_10_10_REV                       = &H8368???
%GL_BGR                                               = &H80E0???
%GL_BGRA                                              = &H80E1???
%GL_MAX_ELEMENTS_VERTICES                             = &H80E8???
%GL_MAX_ELEMENTS_INDICES                              = &H80E9???
%GL_CLAMP_TO_EDGE                                     = &H812F???
%GL_TEXTURE_MIN_LOD                                   = &H813A???
%GL_TEXTURE_MAX_LOD                                   = &H813B???
%GL_TEXTURE_BASE_LEVEL                                = &H813C???
%GL_TEXTURE_MAX_LEVEL                                 = &H813D???
%GL_SMOOTH_POINT_SIZE_RANGE                           = &H0B12???
%GL_SMOOTH_POINT_SIZE_GRANULARITY                     = &H0B13???
%GL_SMOOTH_LINE_WIDTH_RANGE                           = &H0B22???
%GL_SMOOTH_LINE_WIDTH_GRANULARITY                     = &H0B23???
%GL_ALIASED_LINE_WIDTH_RANGE                          = &H846E???
%GL_RESCALE_NORMAL                                    = &H803A???
%GL_LIGHT_MODEL_COLOR_CONTROL                         = &H81F8???
%GL_SINGLE_COLOR                                      = &H81F9???
%GL_SEPARATE_SPECULAR_COLOR                           = &H81FA???
%GL_ALIASED_POINT_SIZE_RANGE                          = &H846D???
#ENDIF

#IF NOT %DEF(%GL_ARB_imaging)
%GL_CONSTANT_COLOR                                    = &H8001???
%GL_ONE_MINUS_CONSTANT_COLOR                          = &H8002???
%GL_CONSTANT_ALPHA                                    = &H8003???
%GL_ONE_MINUS_CONSTANT_ALPHA                          = &H8004???
%GL_BLEND_COLOR                                       = &H8005???
%GL_FUNC_ADD                                          = &H8006???
%GL_MIN                                               = &H8007???
%GL_MAX                                               = &H8008???
%GL_BLEND_EQUATION                                    = &H8009???
%GL_FUNC_SUBTRACT                                     = &H800A???
%GL_FUNC_REVERSE_SUBTRACT                             = &H800B???
%GL_CONVOLUTION_1D                                    = &H8010???
%GL_CONVOLUTION_2D                                    = &H8011???
%GL_SEPARABLE_2D                                      = &H8012???
%GL_CONVOLUTION_BORDER_MODE                           = &H8013???
%GL_CONVOLUTION_FILTER_SCALE                          = &H8014???
%GL_CONVOLUTION_FILTER_BIAS                           = &H8015???
%GL_REDUCE                                            = &H8016???
%GL_CONVOLUTION_FORMAT                                = &H8017???
%GL_CONVOLUTION_WIDTH                                 = &H8018???
%GL_CONVOLUTION_HEIGHT                                = &H8019???
%GL_MAX_CONVOLUTION_WIDTH                             = &H801A???
%GL_MAX_CONVOLUTION_HEIGHT                            = &H801B???
%GL_POST_CONVOLUTION_RED_SCALE                        = &H801C???
%GL_POST_CONVOLUTION_GREEN_SCALE                      = &H801D???
%GL_POST_CONVOLUTION_BLUE_SCALE                       = &H801E???
%GL_POST_CONVOLUTION_ALPHA_SCALE                      = &H801F???
%GL_POST_CONVOLUTION_RED_BIAS                         = &H8020???
%GL_POST_CONVOLUTION_GREEN_BIAS                       = &H8021???
%GL_POST_CONVOLUTION_BLUE_BIAS                        = &H8022???
%GL_POST_CONVOLUTION_ALPHA_BIAS                       = &H8023???
%GL_HISTOGRAM                                         = &H8024???
%GL_PROXY_HISTOGRAM                                   = &H8025???
%GL_HISTOGRAM_WIDTH                                   = &H8026???
%GL_HISTOGRAM_FORMAT                                  = &H8027???
%GL_HISTOGRAM_RED_SIZE                                = &H8028???
%GL_HISTOGRAM_GREEN_SIZE                              = &H8029???
%GL_HISTOGRAM_BLUE_SIZE                               = &H802A???
%GL_HISTOGRAM_ALPHA_SIZE                              = &H802B???
%GL_HISTOGRAM_LUMINANCE_SIZE                          = &H802C???
%GL_HISTOGRAM_SINK                                    = &H802D???
%GL_MINMAX                                            = &H802E???
%GL_MINMAX_FORMAT                                     = &H802F???
%GL_MINMAX_SINK                                       = &H8030???
%GL_TABLE_TOO_LARGE                                   = &H8031???
%GL_COLOR_MATRIX                                      = &H80B1???
%GL_COLOR_MATRIX_STACK_DEPTH                          = &H80B2???
%GL_MAX_COLOR_MATRIX_STACK_DEPTH                      = &H80B3???
%GL_POST_COLOR_MATRIX_RED_SCALE                       = &H80B4???
%GL_POST_COLOR_MATRIX_GREEN_SCALE                     = &H80B5???
%GL_POST_COLOR_MATRIX_BLUE_SCALE                      = &H80B6???
%GL_POST_COLOR_MATRIX_ALPHA_SCALE                     = &H80B7???
%GL_POST_COLOR_MATRIX_RED_BIAS                        = &H80B8???
%GL_POST_COLOR_MATRIX_GREEN_BIAS                      = &H80B9???
%GL_POST_COLOR_MATRIX_BLUE_BIAS                       = &H80BA???
%GL_POST_COLOR_MATRIX_ALPHA_BIAS                      = &H80BB???
%GL_COLOR_TABLE                                       = &H80D0???
%GL_POST_CONVOLUTION_COLOR_TABLE                      = &H80D1???
%GL_POST_COLOR_MATRIX_COLOR_TABLE                     = &H80D2???
%GL_PROXY_COLOR_TABLE                                 = &H80D3???
%GL_PROXY_POST_CONVOLUTION_COLOR_TABLE                = &H80D4???
%GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE               = &H80D5???
%GL_COLOR_TABLE_SCALE                                 = &H80D6???
%GL_COLOR_TABLE_BIAS                                  = &H80D7???
%GL_COLOR_TABLE_FORMAT                                = &H80D8???
%GL_COLOR_TABLE_WIDTH                                 = &H80D9???
%GL_COLOR_TABLE_RED_SIZE                              = &H80DA???
%GL_COLOR_TABLE_GREEN_SIZE                            = &H80DB???
%GL_COLOR_TABLE_BLUE_SIZE                             = &H80DC???
%GL_COLOR_TABLE_ALPHA_SIZE                            = &H80DD???
%GL_COLOR_TABLE_LUMINANCE_SIZE                        = &H80DE???
%GL_COLOR_TABLE_INTENSITY_SIZE                        = &H80DF???
%GL_CONSTANT_BORDER                                   = &H8151???
%GL_REPLICATE_BORDER                                  = &H8153???
%GL_CONVOLUTION_BORDER_COLOR                          = &H8154???
#ENDIF

#IF NOT %DEF(%GL_VERSION_1_3)
%GL_TEXTURE0                                          = &H84C0???
%GL_TEXTURE1                                          = &H84C1???
%GL_TEXTURE2                                          = &H84C2???
%GL_TEXTURE3                                          = &H84C3???
%GL_TEXTURE4                                          = &H84C4???
%GL_TEXTURE5                                          = &H84C5???
%GL_TEXTURE6                                          = &H84C6???
%GL_TEXTURE7                                          = &H84C7???
%GL_TEXTURE8                                          = &H84C8???
%GL_TEXTURE9                                          = &H84C9???
%GL_TEXTURE10                                         = &H84CA???
%GL_TEXTURE11                                         = &H84CB???
%GL_TEXTURE12                                         = &H84CC???
%GL_TEXTURE13                                         = &H84CD???
%GL_TEXTURE14                                         = &H84CE???
%GL_TEXTURE15                                         = &H84CF???
%GL_TEXTURE16                                         = &H84D0???
%GL_TEXTURE17                                         = &H84D1???
%GL_TEXTURE18                                         = &H84D2???
%GL_TEXTURE19                                         = &H84D3???
%GL_TEXTURE20                                         = &H84D4???
%GL_TEXTURE21                                         = &H84D5???
%GL_TEXTURE22                                         = &H84D6???
%GL_TEXTURE23                                         = &H84D7???
%GL_TEXTURE24                                         = &H84D8???
%GL_TEXTURE25                                         = &H84D9???
%GL_TEXTURE26                                         = &H84DA???
%GL_TEXTURE27                                         = &H84DB???
%GL_TEXTURE28                                         = &H84DC???
%GL_TEXTURE29                                         = &H84DD???
%GL_TEXTURE30                                         = &H84DE???
%GL_TEXTURE31                                         = &H84DF???
%GL_ACTIVE_TEXTURE                                    = &H84E0???
%GL_MULTISAMPLE                                       = &H809D???
%GL_SAMPLE_ALPHA_TO_COVERAGE                          = &H809E???
%GL_SAMPLE_ALPHA_TO_ONE                               = &H809F???
%GL_SAMPLE_COVERAGE                                   = &H80A0???
%GL_SAMPLE_BUFFERS                                    = &H80A8???
%GL_SAMPLES                                           = &H80A9???
%GL_SAMPLE_COVERAGE_VALUE                             = &H80AA???
%GL_SAMPLE_COVERAGE_INVERT                            = &H80AB???
%GL_TEXTURE_CUBE_MAP                                  = &H8513???
%GL_TEXTURE_BINDING_CUBE_MAP                          = &H8514???
%GL_TEXTURE_CUBE_MAP_POSITIVE_X                       = &H8515???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_X                       = &H8516???
%GL_TEXTURE_CUBE_MAP_POSITIVE_Y                       = &H8517???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_Y                       = &H8518???
%GL_TEXTURE_CUBE_MAP_POSITIVE_Z                       = &H8519???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_Z                       = &H851A???
%GL_PROXY_TEXTURE_CUBE_MAP                            = &H851B???
%GL_MAX_CUBE_MAP_TEXTURE_SIZE                         = &H851C???
%GL_COMPRESSED_RGB                                    = &H84ED???
%GL_COMPRESSED_RGBA                                   = &H84EE???
%GL_TEXTURE_COMPRESSION_HINT                          = &H84EF???
%GL_TEXTURE_COMPRESSED_IMAGE_SIZE                     = &H86A0???
%GL_TEXTURE_COMPRESSED                                = &H86A1???
%GL_NUM_COMPRESSED_TEXTURE_FORMATS                    = &H86A2???
%GL_COMPRESSED_TEXTURE_FORMATS                        = &H86A3???
%GL_CLAMP_TO_BORDER                                   = &H812D???
%GL_CLIENT_ACTIVE_TEXTURE                             = &H84E1???
%GL_MAX_TEXTURE_UNITS                                 = &H84E2???
%GL_TRANSPOSE_MODELVIEW_MATRIX                        = &H84E3???
%GL_TRANSPOSE_PROJECTION_MATRIX                       = &H84E4???
%GL_TRANSPOSE_TEXTURE_MATRIX                          = &H84E5???
%GL_TRANSPOSE_COLOR_MATRIX                            = &H84E6???
%GL_MULTISAMPLE_BIT                                   = &H20000000???
%GL_NORMAL_MAP                                        = &H8511???
%GL_REFLECTION_MAP                                    = &H8512???
%GL_COMPRESSED_ALPHA                                  = &H84E9???
%GL_COMPRESSED_LUMINANCE                              = &H84EA???
%GL_COMPRESSED_LUMINANCE_ALPHA                        = &H84EB???
%GL_COMPRESSED_INTENSITY                              = &H84EC???
%GL_COMBINE                                           = &H8570???
%GL_COMBINE_RGB                                       = &H8571???
%GL_COMBINE_ALPHA                                     = &H8572???
%GL_SOURCE0_RGB                                       = &H8580???
%GL_SOURCE1_RGB                                       = &H8581???
%GL_SOURCE2_RGB                                       = &H8582???
%GL_SOURCE0_ALPHA                                     = &H8588???
%GL_SOURCE1_ALPHA                                     = &H8589???
%GL_SOURCE2_ALPHA                                     = &H858A???
%GL_OPERAND0_RGB                                      = &H8590???
%GL_OPERAND1_RGB                                      = &H8591???
%GL_OPERAND2_RGB                                      = &H8592???
%GL_OPERAND0_ALPHA                                    = &H8598???
%GL_OPERAND1_ALPHA                                    = &H8599???
%GL_OPERAND2_ALPHA                                    = &H859A???
%GL_RGB_SCALE                                         = &H8573???
%GL_ADD_SIGNED                                        = &H8574???
%GL_INTERPOLATE                                       = &H8575???
%GL_SUBTRACT                                          = &H84E7???
%GL_CONSTANT                                          = &H8576???
%GL_PRIMARY_COLOR                                     = &H8577???
%GL_PREVIOUS                                          = &H8578???
%GL_DOT3_RGB                                          = &H86AE???
%GL_DOT3_RGBA                                         = &H86AF???
#ENDIF

#IF NOT %DEF(%GL_VERSION_1_4)
%GL_BLEND_DST_RGB                                     = &H80C8???
%GL_BLEND_SRC_RGB                                     = &H80C9???
%GL_BLEND_DST_ALPHA                                   = &H80CA???
%GL_BLEND_SRC_ALPHA                                   = &H80CB???
%GL_POINT_FADE_THRESHOLD_SIZE                         = &H8128???
%GL_DEPTH_COMPONENT16                                 = &H81A5???
%GL_DEPTH_COMPONENT24                                 = &H81A6???
%GL_DEPTH_COMPONENT32                                 = &H81A7???
%GL_MIRRORED_REPEAT                                   = &H8370???
%GL_MAX_TEXTURE_LOD_BIAS                              = &H84FD???
%GL_TEXTURE_LOD_BIAS                                  = &H8501???
%GL_INCR_WRAP                                         = &H8507???
%GL_DECR_WRAP                                         = &H8508???
%GL_TEXTURE_DEPTH_SIZE                                = &H884A???
%GL_TEXTURE_COMPARE_MODE                              = &H884C???
%GL_TEXTURE_COMPARE_FUNC                              = &H884D???
%GL_POINT_SIZE_MIN                                    = &H8126???
%GL_POINT_SIZE_MAX                                    = &H8127???
%GL_POINT_DISTANCE_ATTENUATION                        = &H8129???
%GL_GENERATE_MIPMAP                                   = &H8191???
%GL_GENERATE_MIPMAP_HINT                              = &H8192???
%GL_FOG_COORDINATE_SOURCE                             = &H8450???
%GL_FOG_COORDINATE                                    = &H8451???
%GL_FRAGMENT_DEPTH                                    = &H8452???
%GL_CURRENT_FOG_COORDINATE                            = &H8453???
%GL_FOG_COORDINATE_ARRAY_TYPE                         = &H8454???
%GL_FOG_COORDINATE_ARRAY_STRIDE                       = &H8455???
%GL_FOG_COORDINATE_ARRAY_POINTER                      = &H8456???
%GL_FOG_COORDINATE_ARRAY                              = &H8457???
%GL_COLOR_SUM                                         = &H8458???
%GL_CURRENT_SECONDARY_COLOR                           = &H8459???
%GL_SECONDARY_COLOR_ARRAY_SIZE                        = &H845A???
%GL_SECONDARY_COLOR_ARRAY_TYPE                        = &H845B???
%GL_SECONDARY_COLOR_ARRAY_STRIDE                      = &H845C???
%GL_SECONDARY_COLOR_ARRAY_POINTER                     = &H845D???
%GL_SECONDARY_COLOR_ARRAY                             = &H845E???
%GL_TEXTURE_FILTER_CONTROL                            = &H8500???
%GL_DEPTH_TEXTURE_MODE                                = &H884B???
%GL_COMPARE_R_TO_TEXTURE                              = &H884E???
#ENDIF

#IF NOT %DEF(%GL_VERSION_1_5)
%GL_BUFFER_SIZE                                       = &H8764???
%GL_BUFFER_USAGE                                      = &H8765???
%GL_QUERY_COUNTER_BITS                                = &H8864???
%GL_CURRENT_QUERY                                     = &H8865???
%GL_QUERY_RESULT                                      = &H8866???
%GL_QUERY_RESULT_AVAILABLE                            = &H8867???
%GL_ARRAY_BUFFER                                      = &H8892???
%GL_ELEMENT_ARRAY_BUFFER                              = &H8893???
%GL_ARRAY_BUFFER_BINDING                              = &H8894???
%GL_ELEMENT_ARRAY_BUFFER_BINDING                      = &H8895???
%GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING                = &H889F???
%GL_READ_ONLY                                         = &H88B8???
%GL_WRITE_ONLY                                        = &H88B9???
%GL_READ_WRITE                                        = &H88BA???
%GL_BUFFER_ACCESS                                     = &H88BB???
%GL_BUFFER_MAPPED                                     = &H88BC???
%GL_BUFFER_MAP_POINTER                                = &H88BD???
%GL_STREAM_DRAW                                       = &H88E0???
%GL_STREAM_READ                                       = &H88E1???
%GL_STREAM_COPY                                       = &H88E2???
%GL_STATIC_DRAW                                       = &H88E4???
%GL_STATIC_READ                                       = &H88E5???
%GL_STATIC_COPY                                       = &H88E6???
%GL_DYNAMIC_DRAW                                      = &H88E8???
%GL_DYNAMIC_READ                                      = &H88E9???
%GL_DYNAMIC_COPY                                      = &H88EA???
%GL_SAMPLES_PASSED                                    = &H8914???
%GL_SRC1_ALPHA                                        = &H8589???
%GL_VERTEX_ARRAY_BUFFER_BINDING                       = &H8896???
%GL_NORMAL_ARRAY_BUFFER_BINDING                       = &H8897???
%GL_COLOR_ARRAY_BUFFER_BINDING                        = &H8898???
%GL_INDEX_ARRAY_BUFFER_BINDING                        = &H8899???
%GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING                = &H889A???
%GL_EDGE_FLAG_ARRAY_BUFFER_BINDING                    = &H889B???
%GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING              = &H889C???
%GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING               = &H889D???
%GL_WEIGHT_ARRAY_BUFFER_BINDING                       = &H889E???
%GL_FOG_COORD_SRC                                     = &H8450???
%GL_FOG_COORD                                         = &H8451???
%GL_CURRENT_FOG_COORD                                 = &H8453???
%GL_FOG_COORD_ARRAY_TYPE                              = &H8454???
%GL_FOG_COORD_ARRAY_STRIDE                            = &H8455???
%GL_FOG_COORD_ARRAY_POINTER                           = &H8456???
%GL_FOG_COORD_ARRAY                                   = &H8457???
%GL_FOG_COORD_ARRAY_BUFFER_BINDING                    = &H889D???
%GL_SRC0_RGB                                          = &H8580???
%GL_SRC1_RGB                                          = &H8581???
%GL_SRC2_RGB                                          = &H8582???
%GL_SRC0_ALPHA                                        = &H8588???
%GL_SRC2_ALPHA                                        = &H858A???
#ENDIF

#IF NOT %DEF(%GL_VERSION_2_0)
%GL_BLEND_EQUATION_RGB                                = &H8009???
%GL_VERTEX_ATTRIB_ARRAY_ENABLED                       = &H8622???
%GL_VERTEX_ATTRIB_ARRAY_SIZE                          = &H8623???
%GL_VERTEX_ATTRIB_ARRAY_STRIDE                        = &H8624???
%GL_VERTEX_ATTRIB_ARRAY_TYPE                          = &H8625???
%GL_CURRENT_VERTEX_ATTRIB                             = &H8626???
%GL_VERTEX_PROGRAM_POINT_SIZE                         = &H8642???
%GL_VERTEX_ATTRIB_ARRAY_POINTER                       = &H8645???
%GL_STENCIL_BACK_FUNC                                 = &H8800???
%GL_STENCIL_BACK_FAIL                                 = &H8801???
%GL_STENCIL_BACK_PASS_DEPTH_FAIL                      = &H8802???
%GL_STENCIL_BACK_PASS_DEPTH_PASS                      = &H8803???
%GL_MAX_DRAW_BUFFERS                                  = &H8824???
%GL_DRAW_BUFFER0                                      = &H8825???
%GL_DRAW_BUFFER1                                      = &H8826???
%GL_DRAW_BUFFER2                                      = &H8827???
%GL_DRAW_BUFFER3                                      = &H8828???
%GL_DRAW_BUFFER4                                      = &H8829???
%GL_DRAW_BUFFER5                                      = &H882A???
%GL_DRAW_BUFFER6                                      = &H882B???
%GL_DRAW_BUFFER7                                      = &H882C???
%GL_DRAW_BUFFER8                                      = &H882D???
%GL_DRAW_BUFFER9                                      = &H882E???
%GL_DRAW_BUFFER10                                     = &H882F???
%GL_DRAW_BUFFER11                                     = &H8830???
%GL_DRAW_BUFFER12                                     = &H8831???
%GL_DRAW_BUFFER13                                     = &H8832???
%GL_DRAW_BUFFER14                                     = &H8833???
%GL_DRAW_BUFFER15                                     = &H8834???
%GL_BLEND_EQUATION_ALPHA                              = &H883D???
%GL_MAX_VERTEX_ATTRIBS                                = &H8869???
%GL_VERTEX_ATTRIB_ARRAY_NORMALIZED                    = &H886A???
%GL_MAX_TEXTURE_IMAGE_UNITS                           = &H8872???
%GL_FRAGMENT_SHADER                                   = &H8B30???
%GL_VERTEX_SHADER                                     = &H8B31???
%GL_MAX_FRAGMENT_UNIFORM_COMPONENTS                   = &H8B49???
%GL_MAX_VERTEX_UNIFORM_COMPONENTS                     = &H8B4A???
%GL_MAX_VARYING_FLOATS                                = &H8B4B???
%GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS                    = &H8B4C???
%GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS                  = &H8B4D???
%GL_SHADER_TYPE                                       = &H8B4F???
%GL_FLOAT_VEC2                                        = &H8B50???
%GL_FLOAT_VEC3                                        = &H8B51???
%GL_FLOAT_VEC4                                        = &H8B52???
%GL_INT_VEC2                                          = &H8B53???
%GL_INT_VEC3                                          = &H8B54???
%GL_INT_VEC4                                          = &H8B55???
%GL_BOOL                                              = &H8B56???
%GL_BOOL_VEC2                                         = &H8B57???
%GL_BOOL_VEC3                                         = &H8B58???
%GL_BOOL_VEC4                                         = &H8B59???
%GL_FLOAT_MAT2                                        = &H8B5A???
%GL_FLOAT_MAT3                                        = &H8B5B???
%GL_FLOAT_MAT4                                        = &H8B5C???
%GL_SAMPLER_1D                                        = &H8B5D???
%GL_SAMPLER_2D                                        = &H8B5E???
%GL_SAMPLER_3D                                        = &H8B5F???
%GL_SAMPLER_CUBE                                      = &H8B60???
%GL_SAMPLER_1D_SHADOW                                 = &H8B61???
%GL_SAMPLER_2D_SHADOW                                 = &H8B62???
%GL_DELETE_STATUS                                     = &H8B80???
%GL_COMPILE_STATUS                                    = &H8B81???
%GL_LINK_STATUS                                       = &H8B82???
%GL_VALIDATE_STATUS                                   = &H8B83???
%GL_INFO_LOG_LENGTH                                   = &H8B84???
%GL_ATTACHED_SHADERS                                  = &H8B85???
%GL_ACTIVE_UNIFORMS                                   = &H8B86???
%GL_ACTIVE_UNIFORM_MAX_LENGTH                         = &H8B87???
%GL_SHADER_SOURCE_LENGTH                              = &H8B88???
%GL_ACTIVE_ATTRIBUTES                                 = &H8B89???
%GL_ACTIVE_ATTRIBUTE_MAX_LENGTH                       = &H8B8A???
%GL_FRAGMENT_SHADER_DERIVATIVE_HINT                   = &H8B8B???
%GL_SHADING_LANGUAGE_VERSION                          = &H8B8C???
%GL_CURRENT_PROGRAM                                   = &H8B8D???
%GL_POINT_SPRITE_COORD_ORIGIN                         = &H8CA0???
%GL_LOWER_LEFT                                        = &H8CA1???
%GL_UPPER_LEFT                                        = &H8CA2???
%GL_STENCIL_BACK_REF                                  = &H8CA3???
%GL_STENCIL_BACK_VALUE_MASK                           = &H8CA4???
%GL_STENCIL_BACK_WRITEMASK                            = &H8CA5???
%GL_VERTEX_PROGRAM_TWO_SIDE                           = &H8643???
%GL_POINT_SPRITE                                      = &H8861???
%GL_COORD_REPLACE                                     = &H8862???
%GL_MAX_TEXTURE_COORDS                                = &H8871???
#ENDIF

#IF NOT %DEF(%GL_VERSION_2_1)
%GL_PIXEL_PACK_BUFFER                                 = &H88EB???
%GL_PIXEL_UNPACK_BUFFER                               = &H88EC???
%GL_PIXEL_PACK_BUFFER_BINDING                         = &H88ED???
%GL_PIXEL_UNPACK_BUFFER_BINDING                       = &H88EF???
%GL_FLOAT_MAT2x3                                      = &H8B65???
%GL_FLOAT_MAT2x4                                      = &H8B66???
%GL_FLOAT_MAT3x2                                      = &H8B67???
%GL_FLOAT_MAT3x4                                      = &H8B68???
%GL_FLOAT_MAT4x2                                      = &H8B69???
%GL_FLOAT_MAT4x3                                      = &H8B6A???
%GL_SRGB                                              = &H8C40???
%GL_SRGB8                                             = &H8C41???
%GL_SRGB_ALPHA                                        = &H8C42???
%GL_SRGB8_ALPHA8                                      = &H8C43???
%GL_COMPRESSED_SRGB                                   = &H8C48???
%GL_COMPRESSED_SRGB_ALPHA                             = &H8C49???
%GL_CURRENT_RASTER_SECONDARY_COLOR                    = &H845F???
%GL_SLUMINANCE_ALPHA                                  = &H8C44???
%GL_SLUMINANCE8_ALPHA8                                = &H8C45???
%GL_SLUMINANCE                                        = &H8C46???
%GL_SLUMINANCE8                                       = &H8C47???
%GL_COMPRESSED_SLUMINANCE                             = &H8C4A???
%GL_COMPRESSED_SLUMINANCE_ALPHA                       = &H8C4B???
#ENDIF

#IF NOT %DEF(%GL_VERSION_3_0)
%GL_COMPARE_REF_TO_TEXTURE                            = &H884E???
%GL_CLIP_DISTANCE0                                    = &H3000???
%GL_CLIP_DISTANCE1                                    = &H3001???
%GL_CLIP_DISTANCE2                                    = &H3002???
%GL_CLIP_DISTANCE3                                    = &H3003???
%GL_CLIP_DISTANCE4                                    = &H3004???
%GL_CLIP_DISTANCE5                                    = &H3005???
%GL_CLIP_DISTANCE6                                    = &H3006???
%GL_CLIP_DISTANCE7                                    = &H3007???
%GL_MAX_CLIP_DISTANCES                                = &H0D32???
%GL_MAJOR_VERSION                                     = &H821B???
%GL_MINOR_VERSION                                     = &H821C???
%GL_NUM_EXTENSIONS                                    = &H821D???
%GL_CONTEXT_FLAGS                                     = &H821E???
%GL_DEPTH_BUFFER                                      = &H8223???   ' Removed in version 76 - 5 March 2012
%GL_STENCIL_BUFFER                                    = &H8224???   ' Removed in version 76 - 5 March 2012
%GL_COMPRESSED_RED                                    = &H8225???
%GL_COMPRESSED_RG                                     = &H8226???
%GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT               = &H00000001???
%GL_RGBA32F                                           = &H8814???
%GL_RGB32F                                            = &H8815???
%GL_RGBA16F                                           = &H881A???
%GL_RGB16F                                            = &H881B???
%GL_VERTEX_ATTRIB_ARRAY_INTEGER                       = &H88FD???
%GL_MAX_ARRAY_TEXTURE_LAYERS                          = &H88FF???
%GL_MIN_PROGRAM_TEXEL_OFFSET                          = &H8904???
%GL_MAX_PROGRAM_TEXEL_OFFSET                          = &H8905???
%GL_CLAMP_READ_COLOR                                  = &H891C???
%GL_FIXED_ONLY                                        = &H891D???
%GL_MAX_VARYING_COMPONENTS                            = &H8B4B???
%GL_TEXTURE_1D_ARRAY                                  = &H8C18???
%GL_PROXY_TEXTURE_1D_ARRAY                            = &H8C19???
%GL_TEXTURE_2D_ARRAY                                  = &H8C1A???
%GL_PROXY_TEXTURE_2D_ARRAY                            = &H8C1B???
%GL_TEXTURE_BINDING_1D_ARRAY                          = &H8C1C???
%GL_TEXTURE_BINDING_2D_ARRAY                          = &H8C1D???
%GL_R11F_G11F_B10F                                    = &H8C3A???
%GL_UNSIGNED_INT_10F_11F_11F_REV                      = &H8C3B???
%GL_RGB9_E5                                           = &H8C3D???
%GL_UNSIGNED_INT_5_9_9_9_REV                          = &H8C3E???
%GL_TEXTURE_SHARED_SIZE                               = &H8C3F???
%GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH             = &H8C76???
%GL_TRANSFORM_FEEDBACK_BUFFER_MODE                    = &H8C7F???
%GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS        = &H8C80???
%GL_TRANSFORM_FEEDBACK_VARYINGS                       = &H8C83???
%GL_TRANSFORM_FEEDBACK_BUFFER_START                   = &H8C84???
%GL_TRANSFORM_FEEDBACK_BUFFER_SIZE                    = &H8C85???
%GL_PRIMITIVES_GENERATED                              = &H8C87???
%GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN             = &H8C88???
%GL_RASTERIZER_DISCARD                                = &H8C89???
%GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS     = &H8C8A???
%GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS           = &H8C8B???
%GL_INTERLEAVED_ATTRIBS                               = &H8C8C???
%GL_SEPARATE_ATTRIBS                                  = &H8C8D???
%GL_TRANSFORM_FEEDBACK_BUFFER                         = &H8C8E???
%GL_TRANSFORM_FEEDBACK_BUFFER_BINDING                 = &H8C8F???
%GL_RGBA32UI                                          = &H8D70???
%GL_RGB32UI                                           = &H8D71???
%GL_RGBA16UI                                          = &H8D76???
%GL_RGB16UI                                           = &H8D77???
%GL_RGBA8UI                                           = &H8D7C???
%GL_RGB8UI                                            = &H8D7D???
%GL_RGBA32I                                           = &H8D82???
%GL_RGB32I                                            = &H8D83???
%GL_RGBA16I                                           = &H8D88???
%GL_RGB16I                                            = &H8D89???
%GL_RGBA8I                                            = &H8D8E???
%GL_RGB8I                                             = &H8D8F???
%GL_RED_INTEGER                                       = &H8D94???
%GL_GREEN_INTEGER                                     = &H8D95???
%GL_BLUE_INTEGER                                      = &H8D96???
%GL_RGB_INTEGER                                       = &H8D98???
%GL_RGBA_INTEGER                                      = &H8D99???
%GL_BGR_INTEGER                                       = &H8D9A???
%GL_BGRA_INTEGER                                      = &H8D9B???
%GL_SAMPLER_1D_ARRAY                                  = &H8DC0???
%GL_SAMPLER_2D_ARRAY                                  = &H8DC1???
%GL_SAMPLER_1D_ARRAY_SHADOW                           = &H8DC3???
%GL_SAMPLER_2D_ARRAY_SHADOW                           = &H8DC4???
%GL_SAMPLER_CUBE_SHADOW                               = &H8DC5???
%GL_UNSIGNED_INT_VEC2                                 = &H8DC6???
%GL_UNSIGNED_INT_VEC3                                 = &H8DC7???
%GL_UNSIGNED_INT_VEC4                                 = &H8DC8???
%GL_INT_SAMPLER_1D                                    = &H8DC9???
%GL_INT_SAMPLER_2D                                    = &H8DCA???
%GL_INT_SAMPLER_3D                                    = &H8DCB???
%GL_INT_SAMPLER_CUBE                                  = &H8DCC???
%GL_INT_SAMPLER_1D_ARRAY                              = &H8DCE???
%GL_INT_SAMPLER_2D_ARRAY                              = &H8DCF???
%GL_UNSIGNED_INT_SAMPLER_1D                           = &H8DD1???
%GL_UNSIGNED_INT_SAMPLER_2D                           = &H8DD2???
%GL_UNSIGNED_INT_SAMPLER_3D                           = &H8DD3???
%GL_UNSIGNED_INT_SAMPLER_CUBE                         = &H8DD4???
%GL_UNSIGNED_INT_SAMPLER_1D_ARRAY                     = &H8DD6???
%GL_UNSIGNED_INT_SAMPLER_2D_ARRAY                     = &H8DD7???
%GL_QUERY_WAIT                                        = &H8E13???
%GL_QUERY_NO_WAIT                                     = &H8E14???
%GL_QUERY_BY_REGION_WAIT                              = &H8E15???
%GL_QUERY_BY_REGION_NO_WAIT                           = &H8E16???
%GL_BUFFER_ACCESS_FLAGS                               = &H911F???
%GL_BUFFER_MAP_LENGTH                                 = &H9120???
%GL_BUFFER_MAP_OFFSET                                 = &H9121???
'/* Reuse tokens from ARB_depth_buffer_float */
'/* reuse GL_DEPTH_COMPONENT32F */
'/* reuse GL_DEPTH32F_STENCIL8 */
'/* reuse GL_FLOAT_32_UNSIGNED_INT_24_8_REV */
'/* Reuse tokens from ARB_framebuffer_object */
'/* reuse GL_INVALID_FRAMEBUFFER_OPERATION */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE */
'/* reuse GL_FRAMEBUFFER_DEFAULT */
'/* reuse GL_FRAMEBUFFER_UNDEFINED */
'/* reuse GL_DEPTH_STENCIL_ATTACHMENT */
'/* reuse GL_INDEX */
'/* reuse GL_MAX_RENDERBUFFER_SIZE */
'/* reuse GL_DEPTH_STENCIL */
'/* reuse GL_UNSIGNED_INT_24_8 */
'/* reuse GL_DEPTH24_STENCIL8 */
'/* reuse GL_TEXTURE_STENCIL_SIZE */
'/* reuse GL_TEXTURE_RED_TYPE */
'/* reuse GL_TEXTURE_GREEN_TYPE */
'/* reuse GL_TEXTURE_BLUE_TYPE */
'/* reuse GL_TEXTURE_ALPHA_TYPE */
'/* reuse GL_TEXTURE_DEPTH_TYPE */
'/* reuse GL_UNSIGNED_NORMALIZED */
'/* reuse GL_FRAMEBUFFER_BINDING */
'/* reuse GL_DRAW_FRAMEBUFFER_BINDING */
'/* reuse GL_RENDERBUFFER_BINDING */
'/* reuse GL_READ_FRAMEBUFFER */
'/* reuse GL_DRAW_FRAMEBUFFER */
'/* reuse GL_READ_FRAMEBUFFER_BINDING */
'/* reuse GL_RENDERBUFFER_SAMPLES */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
'/* reuse GL_FRAMEBUFFER_COMPLETE */
'/* reuse GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT */
'/* reuse GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT */
'/* reuse GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER */
'/* reuse GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER */
'/* reuse GL_FRAMEBUFFER_UNSUPPORTED */
'/* reuse GL_MAX_COLOR_ATTACHMENTS */
'/* reuse GL_COLOR_ATTACHMENT0 */
'/* reuse GL_COLOR_ATTACHMENT1 */
'/* reuse GL_COLOR_ATTACHMENT2 */
'/* reuse GL_COLOR_ATTACHMENT3 */
'/* reuse GL_COLOR_ATTACHMENT4 */
'/* reuse GL_COLOR_ATTACHMENT5 */
'/* reuse GL_COLOR_ATTACHMENT6 */
'/* reuse GL_COLOR_ATTACHMENT7 */
'/* reuse GL_COLOR_ATTACHMENT8 */
'/* reuse GL_COLOR_ATTACHMENT9 */
'/* reuse GL_COLOR_ATTACHMENT10 */
'/* reuse GL_COLOR_ATTACHMENT11 */
'/* reuse GL_COLOR_ATTACHMENT12 */
'/* reuse GL_COLOR_ATTACHMENT13 */
'/* reuse GL_COLOR_ATTACHMENT14 */
'/* reuse GL_COLOR_ATTACHMENT15 */
'/* reuse GL_DEPTH_ATTACHMENT */
'/* reuse GL_STENCIL_ATTACHMENT */
'/* reuse GL_FRAMEBUFFER */
'/* reuse GL_RENDERBUFFER */
'/* reuse GL_RENDERBUFFER_WIDTH */
'/* reuse GL_RENDERBUFFER_HEIGHT */
'/* reuse GL_RENDERBUFFER_INTERNAL_FORMAT */
'/* reuse GL_STENCIL_INDEX1 */
'/* reuse GL_STENCIL_INDEX4 */
'/* reuse GL_STENCIL_INDEX8 */
'/* reuse GL_STENCIL_INDEX16 */
'/* reuse GL_RENDERBUFFER_RED_SIZE */
'/* reuse GL_RENDERBUFFER_GREEN_SIZE */
'/* reuse GL_RENDERBUFFER_BLUE_SIZE */
'/* reuse GL_RENDERBUFFER_ALPHA_SIZE */
'/* reuse GL_RENDERBUFFER_DEPTH_SIZE */
'/* reuse GL_RENDERBUFFER_STENCIL_SIZE */
'/* reuse GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE */
'/* reuse GL_MAX_SAMPLES */
'/* Reuse tokens from ARB_framebuffer_sRGB */
'/* reuse GL_FRAMEBUFFER_SRGB */
'/* Reuse tokens from ARB_half_float_vertex */
'/* reuse GL_HALF_FLOAT */
'/* Reuse tokens from ARB_map_buffer_range */
'/* reuse GL_MAP_READ_BIT */
'/* reuse GL_MAP_WRITE_BIT */
'/* reuse GL_MAP_INVALIDATE_RANGE_BIT */
'/* reuse GL_MAP_INVALIDATE_BUFFER_BIT */
'/* reuse GL_MAP_FLUSH_EXPLICIT_BIT */
'/* reuse GL_MAP_UNSYNCHRONIZED_BIT */
'/* Reuse tokens from ARB_texture_compression_rgtc */
'/* reuse GL_COMPRESSED_RED_RGTC1 */
'/* reuse GL_COMPRESSED_SIGNED_RED_RGTC1 */
'/* reuse GL_COMPRESSED_RG_RGTC2 */
'/* reuse GL_COMPRESSED_SIGNED_RG_RGTC2 */
'/* Reuse tokens from ARB_texture_rg */
'/* reuse GL_RG */
'/* reuse GL_RG_INTEGER */
'/* reuse GL_R8 */
'/* reuse GL_R16 */
'/* reuse GL_RG8 */
'/* reuse GL_RG16 */
'/* reuse GL_R16F */
'/* reuse GL_R32F */
'/* reuse GL_RG16F */
'/* reuse GL_RG32F */
'/* reuse GL_R8I */
'/* reuse GL_R8UI */
'/* reuse GL_R16I */
'/* reuse GL_R16UI */
'/* reuse GL_R32I */
'/* reuse GL_R32UI */
'/* reuse GL_RG8I */
'/* reuse GL_RG8UI */
'/* reuse GL_RG16I */
'/* reuse GL_RG16UI */
'/* reuse GL_RG32I */
'/* reuse GL_RG32UI */
'/* Reuse tokens from ARB_vertex_array_object */
'/* reuse GL_VERTEX_ARRAY_BINDING */
%GL_CLAMP_VERTEX_COLOR                                = &H891A???
%GL_CLAMP_FRAGMENT_COLOR                              = &H891B???
%GL_ALPHA_INTEGER                                     = &H8D97???
'/* Reuse tokens from ARB_framebuffer_object */
'/* reuse GL_TEXTURE_LUMINANCE_TYPE */
'/* reuse GL_TEXTURE_INTENSITY_TYPE */
#ENDIF

#IF NOT %DEF(%GL_VERSION_3_1)
%GL_SAMPLER_2D_RECT                                   = &H8B63???
%GL_SAMPLER_2D_RECT_SHADOW                            = &H8B64???
%GL_SAMPLER_BUFFER                                    = &H8DC2???
%GL_INT_SAMPLER_2D_RECT                               = &H8DCD???
%GL_INT_SAMPLER_BUFFER                                = &H8DD0???
%GL_UNSIGNED_INT_SAMPLER_2D_RECT                      = &H8DD5???
%GL_UNSIGNED_INT_SAMPLER_BUFFER                       = &H8DD8???
%GL_TEXTURE_BUFFER                                    = &H8C2A???
%GL_MAX_TEXTURE_BUFFER_SIZE                           = &H8C2B???
%GL_TEXTURE_BINDING_BUFFER                            = &H8C2C???
%GL_TEXTURE_BUFFER_DATA_STORE_BINDING                 = &H8C2D???
%GL_TEXTURE_BUFFER_FORMAT                             = &H8C2E???   ' Removed in version 86
%GL_TEXTURE_RECTANGLE                                 = &H84F5???
%GL_TEXTURE_BINDING_RECTANGLE                         = &H84F6???
%GL_PROXY_TEXTURE_RECTANGLE                           = &H84F7???
%GL_MAX_RECTANGLE_TEXTURE_SIZE                        = &H84F8???
%GL_RED_SNORM                                         = &H8F90???
%GL_RG_SNORM                                          = &H8F91???
%GL_RGB_SNORM                                         = &H8F92???
%GL_RGBA_SNORM                                        = &H8F93???
%GL_R8_SNORM                                          = &H8F94???
%GL_RG8_SNORM                                         = &H8F95???
%GL_RGB8_SNORM                                        = &H8F96???
%GL_RGBA8_SNORM                                       = &H8F97???
%GL_R16_SNORM                                         = &H8F98???
%GL_RG16_SNORM                                        = &H8F99???
%GL_RGB16_SNORM                                       = &H8F9A???
%GL_RGBA16_SNORM                                      = &H8F9B???
%GL_SIGNED_NORMALIZED                                 = &H8F9C???
%GL_PRIMITIVE_RESTART                                 = &H8F9D???
%GL_PRIMITIVE_RESTART_INDEX                           = &H8F9E???
'/* Reuse tokens from ARB_copy_buffer */
'/* reuse GL_COPY_READ_BUFFER */
'/* reuse GL_COPY_WRITE_BUFFER */
'/* Reuse tokens from ARB_draw_instanced (none) */
'/* Reuse tokens from ARB_uniform_buffer_object */
'/* reuse GL_UNIFORM_BUFFER */
'/* reuse GL_UNIFORM_BUFFER_BINDING */
'/* reuse GL_UNIFORM_BUFFER_START */
'/* reuse GL_UNIFORM_BUFFER_SIZE */
'/* reuse GL_MAX_VERTEX_UNIFORM_BLOCKS */
'/* reuse GL_MAX_FRAGMENT_UNIFORM_BLOCKS */
'/* reuse GL_MAX_COMBINED_UNIFORM_BLOCKS */
'/* reuse GL_MAX_UNIFORM_BUFFER_BINDINGS */
'/* reuse GL_MAX_UNIFORM_BLOCK_SIZE */
'/* reuse GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS */
'/* reuse GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS */
'/* reuse GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT */
'/* reuse GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */
'/* reuse GL_ACTIVE_UNIFORM_BLOCKS */
'/* reuse GL_UNIFORM_TYPE */
'/* reuse GL_UNIFORM_SIZE */
'/* reuse GL_UNIFORM_NAME_LENGTH */
'/* reuse GL_UNIFORM_BLOCK_INDEX */
'/* reuse GL_UNIFORM_OFFSET */
'/* reuse GL_UNIFORM_ARRAY_STRIDE */
'/* reuse GL_UNIFORM_MATRIX_STRIDE */
'/* reuse GL_UNIFORM_IS_ROW_MAJOR */
'/* reuse GL_UNIFORM_BLOCK_BINDING */
'/* reuse GL_UNIFORM_BLOCK_DATA_SIZE */
'/* reuse GL_UNIFORM_BLOCK_NAME_LENGTH */
'/* reuse GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS */
'/* reuse GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES */
'/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER */
'/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER */
'/* reuse GL_INVALID_INDEX */
#ENDIF

#IF NOT %DEF(%GL_VERSION_3_2)
%GL_CONTEXT_CORE_PROFILE_BIT                          = &H00000001???
%GL_CONTEXT_COMPATIBILITY_PROFILE_BIT                 = &H00000002???
%GL_LINES_ADJACENCY                                   = &H000A???
%GL_LINE_STRIP_ADJACENCY                              = &H000B???
%GL_TRIANGLES_ADJACENCY                               = &H000C???
%GL_TRIANGLE_STRIP_ADJACENCY                          = &H000D???
%GL_PROGRAM_POINT_SIZE                                = &H8642???
%GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS                  = &H8C29???
%GL_FRAMEBUFFER_ATTACHMENT_LAYERED                    = &H8DA7???
%GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS              = &H8DA8???
%GL_GEOMETRY_SHADER                                   = &H8DD9???
%GL_GEOMETRY_VERTICES_OUT                             = &H8916???
%GL_GEOMETRY_INPUT_TYPE                               = &H8917???
%GL_GEOMETRY_OUTPUT_TYPE                              = &H8918???
%GL_MAX_GEOMETRY_UNIFORM_COMPONENTS                   = &H8DDF???
%GL_MAX_GEOMETRY_OUTPUT_VERTICES                      = &H8DE0???
%GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS              = &H8DE1???
%GL_MAX_VERTEX_OUTPUT_COMPONENTS                      = &H9122???
%GL_MAX_GEOMETRY_INPUT_COMPONENTS                     = &H9123???
%GL_MAX_GEOMETRY_OUTPUT_COMPONENTS                    = &H9124???
%GL_MAX_FRAGMENT_INPUT_COMPONENTS                     = &H9125???
%GL_CONTEXT_PROFILE_MASK                              = &H9126???
'/* reuse GL_MAX_VARYING_COMPONENTS */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
'/* Reuse tokens from ARB_depth_clamp */
'/* reuse GL_DEPTH_CLAMP */
'/* Reuse tokens from ARB_draw_elements_base_vertex (none) */
'/* Reuse tokens from ARB_fragment_coord_conventions (none) */
'/* Reuse tokens from ARB_provoking_vertex */
'/* reuse GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION */
'/* reuse GL_FIRST_VERTEX_CONVENTION */
'/* reuse GL_LAST_VERTEX_CONVENTION */
'/* reuse GL_PROVOKING_VERTEX */
'/* Reuse tokens from ARB_seamless_cube_map */
'/* reuse GL_TEXTURE_CUBE_MAP_SEAMLESS */
'/* Reuse tokens from ARB_sync */
'/* reuse GL_MAX_SERVER_WAIT_TIMEOUT */
'/* reuse GL_OBJECT_TYPE */
'/* reuse GL_SYNC_CONDITION */
'/* reuse GL_SYNC_STATUS */
'/* reuse GL_SYNC_FLAGS */
'/* reuse GL_SYNC_FENCE */
'/* reuse GL_SYNC_GPU_COMMANDS_COMPLETE */
'/* reuse GL_UNSIGNALED */
'/* reuse GL_SIGNALED */
'/* reuse GL_ALREADY_SIGNALED */
'/* reuse GL_TIMEOUT_EXPIRED */
'/* reuse GL_CONDITION_SATISFIED */
'/* reuse GL_WAIT_FAILED */
'/* reuse GL_TIMEOUT_IGNORED */
'/* reuse GL_SYNC_FLUSH_COMMANDS_BIT */
'/* reuse GL_TIMEOUT_IGNORED */
'/* Reuse tokens from ARB_texture_multisample */
'/* reuse GL_SAMPLE_POSITION */
'/* reuse GL_SAMPLE_MASK */
'/* reuse GL_SAMPLE_MASK_VALUE */
'/* reuse GL_MAX_SAMPLE_MASK_WORDS */
'/* reuse GL_TEXTURE_2D_MULTISAMPLE */
'/* reuse GL_PROXY_TEXTURE_2D_MULTISAMPLE */
'/* reuse GL_TEXTURE_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_TEXTURE_BINDING_2D_MULTISAMPLE */
'/* reuse GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_TEXTURE_SAMPLES */
'/* reuse GL_TEXTURE_FIXED_SAMPLE_LOCATIONS */
'/* reuse GL_SAMPLER_2D_MULTISAMPLE */
'/* reuse GL_INT_SAMPLER_2D_MULTISAMPLE */
'/* reuse GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE */
'/* reuse GL_SAMPLER_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_MAX_COLOR_TEXTURE_SAMPLES */
'/* reuse GL_MAX_DEPTH_TEXTURE_SAMPLES */
'/* reuse GL_MAX_INTEGER_SAMPLES */
'/* Don't need to reuse tokens from ARB_vertex_array_bgra since they're already in 1.2 core */
#ENDIF

#IF NOT %DEF(%GL_VERSION_3_3)
%GL_VERTEX_ATTRIB_ARRAY_DIVISOR    = &H88FE???
'/* Reuse tokens from ARB_blend_func_extended */
'/* reuse GL_SRC1_COLOR */
'/* reuse GL_ONE_MINUS_SRC1_COLOR */
'/* reuse GL_ONE_MINUS_SRC1_ALPHA */
'/* reuse GL_MAX_DUAL_SOURCE_DRAW_BUFFERS */
'/* Reuse tokens from ARB_explicit_attrib_location (none) */
'/* Reuse tokens from ARB_occlusion_query2 */
'/* reuse GL_ANY_SAMPLES_PASSED */
'/* Reuse tokens from ARB_sampler_objects */
'/* reuse GL_SAMPLER_BINDING */
'/* Reuse tokens from ARB_shader_bit_encoding (none) */
'/* Reuse tokens from ARB_texture_rgb10_a2ui */
'/* reuse GL_RGB10_A2UI */
'/* Reuse tokens from ARB_texture_swizzle */
'/* reuse GL_TEXTURE_SWIZZLE_R */
'/* reuse GL_TEXTURE_SWIZZLE_G */
'/* reuse GL_TEXTURE_SWIZZLE_B */
'/* reuse GL_TEXTURE_SWIZZLE_A */
'/* reuse GL_TEXTURE_SWIZZLE_RGBA */
'/* Reuse tokens from ARB_timer_query */
'/* reuse GL_TIME_ELAPSED */
'/* reuse GL_TIMESTAMP */
'/* Reuse tokens from ARB_vertex_type_2_10_10_10_rev */
'/* reuse GL_INT_2_10_10_10_REV */
#ENDIF

#IF NOT %DEF(%GL_VERSION_4_0)
%GL_SAMPLE_SHADING                      = &H8C36???
%GL_MIN_SAMPLE_SHADING_VALUE            = &H8C37???
%GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET   = &H8E5E???
%GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET   = &H8E5F???
%GL_TEXTURE_CUBE_MAP_ARRAY              = &H9009???
%GL_TEXTURE_BINDING_CUBE_MAP_ARRAY      = &H900A???
%GL_PROXY_TEXTURE_CUBE_MAP_ARRAY        = &H900B???
%GL_SAMPLER_CUBE_MAP_ARRAY              = &H900C???
%GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW       = &H900D???
%GL_INT_SAMPLER_CUBE_MAP_ARRAY          = &H900E???
%GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = &H900F???
'/* Reuse tokens from ARB_texture_query_lod (none) */
'/* Reuse tokens from ARB_draw_buffers_blend (none) */
'/* Reuse tokens from ARB_draw_indirect */
'/* reuse GL_DRAW_INDIRECT_BUFFER */
'/* reuse GL_DRAW_INDIRECT_BUFFER_BINDING */
'/* Reuse tokens from ARB_gpu_shader5 */
'/* reuse GL_GEOMETRY_SHADER_INVOCATIONS */
'/* reuse GL_MAX_GEOMETRY_SHADER_INVOCATIONS */
'/* reuse GL_MIN_FRAGMENT_INTERPOLATION_OFFSET */
'/* reuse GL_MAX_FRAGMENT_INTERPOLATION_OFFSET */
'/* reuse GL_FRAGMENT_INTERPOLATION_OFFSET_BITS */
'/* reuse GL_MAX_VERTEX_STREAMS */
'/* Reuse tokens from ARB_gpu_shader_fp64 */
'/* reuse GL_DOUBLE_VEC2 */
'/* reuse GL_DOUBLE_VEC3 */
'/* reuse GL_DOUBLE_VEC4 */
'/* reuse GL_DOUBLE_MAT2 */
'/* reuse GL_DOUBLE_MAT3 */
'/* reuse GL_DOUBLE_MAT4 */
'/* reuse GL_DOUBLE_MAT2x3 */
'/* reuse GL_DOUBLE_MAT2x4 */
'/* reuse GL_DOUBLE_MAT3x2 */
'/* reuse GL_DOUBLE_MAT3x4 */
'/* reuse GL_DOUBLE_MAT4x2 */
'/* reuse GL_DOUBLE_MAT4x3 */
'/* Reuse tokens from ARB_shader_subroutine */
'/* reuse GL_ACTIVE_SUBROUTINES */
'/* reuse GL_ACTIVE_SUBROUTINE_UNIFORMS */
'/* reuse GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS */
'/* reuse GL_ACTIVE_SUBROUTINE_MAX_LENGTH */
'/* reuse GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH */
'/* reuse GL_MAX_SUBROUTINES */
'/* reuse GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS */
'/* reuse GL_NUM_COMPATIBLE_SUBROUTINES */
'/* reuse GL_COMPATIBLE_SUBROUTINES */
'/* Reuse tokens from ARB_tessellation_shader */
'/* reuse GL_PATCHES */
'/* reuse GL_PATCH_VERTICES */
'/* reuse GL_PATCH_DEFAULT_INNER_LEVEL */
'/* reuse GL_PATCH_DEFAULT_OUTER_LEVEL */
'/* reuse GL_TESS_CONTROL_OUTPUT_VERTICES */
'/* reuse GL_TESS_GEN_MODE */
'/* reuse GL_TESS_GEN_SPACING */
'/* reuse GL_TESS_GEN_VERTEX_ORDER */
'/* reuse GL_TESS_GEN_POINT_MODE */
'/* reuse GL_ISOLINES */
'/* reuse GL_FRACTIONAL_ODD */
'/* reuse GL_FRACTIONAL_EVEN */
'/* reuse GL_MAX_PATCH_VERTICES */
'/* reuse GL_MAX_TESS_GEN_LEVEL */
'/* reuse GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS */
'/* reuse GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS */
'/* reuse GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS */
'/* reuse GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS */
'/* reuse GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS */
'/* reuse GL_MAX_TESS_PATCH_COMPONENTS */
'/* reuse GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS */
'/* reuse GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS */
'/* reuse GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS */
'/* reuse GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS */
'/* reuse GL_MAX_TESS_CONTROL_INPUT_COMPONENTS */
'/* reuse GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS */
'/* reuse GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS */
'/* reuse GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS */
'/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER */
'/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER */
'/* reuse GL_TESS_EVALUATION_SHADER */
'/* reuse GL_TESS_CONTROL_SHADER */
'/* Reuse tokens from ARB_texture_buffer_object_rgb32 (none) */
'/* Reuse tokens from ARB_transform_feedback2 */
'/* reuse GL_TRANSFORM_FEEDBACK */
'/* reuse GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED */
'/* reuse GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE */
'/* reuse GL_TRANSFORM_FEEDBACK_BINDING */
'/* Reuse tokens from ARB_transform_feedback3 */
'/* reuse GL_MAX_TRANSFORM_FEEDBACK_BUFFERS */
'/* reuse GL_MAX_VERTEX_STREAMS */
#ENDIF

#IF NOT %DEF(%GL_VERSION_4_1)
'/* Reuse tokens from ARB_ES2_compatibility */
'/* reuse GL_FIXED */
'/* reuse GL_IMPLEMENTATION_COLOR_READ_TYPE */
'/* reuse GL_IMPLEMENTATION_COLOR_READ_FORMAT */
'/* reuse GL_LOW_FLOAT */
'/* reuse GL_MEDIUM_FLOAT */
'/* reuse GL_HIGH_FLOAT */
'/* reuse GL_LOW_INT */
'/* reuse GL_MEDIUM_INT */
'/* reuse GL_HIGH_INT */
'/* reuse GL_SHADER_COMPILER */
'/* reuse GL_SHADER_BINARY_FORMATS */
'/* reuse GL_NUM_SHADER_BINARY_FORMATS */
'/* reuse GL_MAX_VERTEX_UNIFORM_VECTORS */
'/* reuse GL_RGB565 */
'/* reuse GL_MAX_VARYING_VECTORS */
'/* reuse GL_MAX_FRAGMENT_UNIFORM_VECTORS */
'/* Reuse tokens from ARB_get_program_binary */
'/* reuse GL_PROGRAM_BINARY_RETRIEVABLE_HINT */
'/* reuse GL_PROGRAM_BINARY_LENGTH */
'/* reuse GL_NUM_PROGRAM_BINARY_FORMATS */
'/* reuse GL_PROGRAM_BINARY_FORMATS */
'/* Reuse tokens from ARB_separate_shader_objects */
'/* reuse GL_VERTEX_SHADER_BIT */
'/* reuse GL_FRAGMENT_SHADER_BIT */
'/* reuse GL_GEOMETRY_SHADER_BIT */
'/* reuse GL_TESS_CONTROL_SHADER_BIT */
'/* reuse GL_TESS_EVALUATION_SHADER_BIT */
'/* reuse GL_ALL_SHADER_BITS */
'/* reuse GL_PROGRAM_SEPARABLE */
'/* reuse GL_ACTIVE_PROGRAM */
'/* reuse GL_PROGRAM_PIPELINE_BINDING */
'/* Reuse tokens from ARB_shader_precision (none) */
'/* Reuse tokens from ARB_vertex_attrib_64bit - all are in GL 3.0 and 4.0 already */
'/* Reuse tokens from ARB_viewport_array - some are in GL 1.1 and ARB_provoking_vertex already */
'/* reuse GL_MAX_VIEWPORTS */
'/* reuse GL_VIEWPORT_SUBPIXEL_BITS */
'/* reuse GL_VIEWPORT_BOUNDS_RANGE */
'/* reuse GL_LAYER_PROVOKING_VERTEX */
'/* reuse GL_VIEWPORT_INDEX_PROVOKING_VERTEX */
'/* reuse GL_UNDEFINED_VERTEX */
#ENDIF

#IF NOT %DEF(%GL_VERSION_4_2)
'/* Reuse tokens from ARB_base_instance (none) */
'/* Reuse tokens from ARB_shading_language_420pack (none) */
'/* Reuse tokens from ARB_transform_feedback_instanced (none) */
'/* Reuse tokens from ARB_compressed_texture_pixel_storage */
'/* reuse GL_UNPACK_COMPRESSED_BLOCK_WIDTH */
'/* reuse GL_UNPACK_COMPRESSED_BLOCK_HEIGHT */
'/* reuse GL_UNPACK_COMPRESSED_BLOCK_DEPTH */
'/* reuse GL_UNPACK_COMPRESSED_BLOCK_SIZE */
'/* reuse GL_PACK_COMPRESSED_BLOCK_WIDTH */
'/* reuse GL_PACK_COMPRESSED_BLOCK_HEIGHT */
'/* reuse GL_PACK_COMPRESSED_BLOCK_DEPTH */
'/* reuse GL_PACK_COMPRESSED_BLOCK_SIZE */
'/* Reuse tokens from ARB_conservative_depth (none) */
'/* Reuse tokens from ARB_internalformat_query */
'/* reuse GL_NUM_SAMPLE_COUNTS */
'/* Reuse tokens from ARB_map_buffer_alignment */
'/* reuse GL_MIN_MAP_BUFFER_ALIGNMENT */
'/* Reuse tokens from ARB_shader_atomic_counters */
'/* reuse GL_ATOMIC_COUNTER_BUFFER */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_BINDING */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_START */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_SIZE */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER */
'/* reuse GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_VERTEX_ATOMIC_COUNTERS */
'/* reuse GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS */
'/* reuse GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS */
'/* reuse GL_MAX_GEOMETRY_ATOMIC_COUNTERS */
'/* reuse GL_MAX_FRAGMENT_ATOMIC_COUNTERS */
'/* reuse GL_MAX_COMBINED_ATOMIC_COUNTERS */
'/* reuse GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE */
'/* reuse GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS */
'/* reuse GL_ACTIVE_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX */
'/* reuse GL_UNSIGNED_INT_ATOMIC_COUNTER */
'/* Reuse tokens from ARB_shader_image_load_store */
'/* reuse GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT */
'/* reuse GL_ELEMENT_ARRAY_BARRIER_BIT */
'/* reuse GL_UNIFORM_BARRIER_BIT */
'/* reuse GL_TEXTURE_FETCH_BARRIER_BIT */
'/* reuse GL_SHADER_IMAGE_ACCESS_BARRIER_BIT */
'/* reuse GL_COMMAND_BARRIER_BIT */
'/* reuse GL_PIXEL_BUFFER_BARRIER_BIT */
'/* reuse GL_TEXTURE_UPDATE_BARRIER_BIT */
'/* reuse GL_BUFFER_UPDATE_BARRIER_BIT */
'/* reuse GL_FRAMEBUFFER_BARRIER_BIT */
'/* reuse GL_TRANSFORM_FEEDBACK_BARRIER_BIT */
'/* reuse GL_ATOMIC_COUNTER_BARRIER_BIT */
'/* reuse GL_ALL_BARRIER_BITS */
'/* reuse GL_MAX_IMAGE_UNITS */
'/* reuse GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS */
'/* reuse GL_IMAGE_BINDING_NAME */
'/* reuse GL_IMAGE_BINDING_LEVEL */
'/* reuse GL_IMAGE_BINDING_LAYERED */
'/* reuse GL_IMAGE_BINDING_LAYER */
'/* reuse GL_IMAGE_BINDING_ACCESS */
'/* reuse GL_IMAGE_1D */
'/* reuse GL_IMAGE_2D */
'/* reuse GL_IMAGE_3D */
'/* reuse GL_IMAGE_2D_RECT */
'/* reuse GL_IMAGE_CUBE */
'/* reuse GL_IMAGE_BUFFER */
'/* reuse GL_IMAGE_1D_ARRAY */
'/* reuse GL_IMAGE_2D_ARRAY */
'/* reuse GL_IMAGE_CUBE_MAP_ARRAY */
'/* reuse GL_IMAGE_2D_MULTISAMPLE */
'/* reuse GL_IMAGE_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_INT_IMAGE_1D */
'/* reuse GL_INT_IMAGE_2D */
'/* reuse GL_INT_IMAGE_3D */
'/* reuse GL_INT_IMAGE_2D_RECT */
'/* reuse GL_INT_IMAGE_CUBE */
'/* reuse GL_INT_IMAGE_BUFFER */
'/* reuse GL_INT_IMAGE_1D_ARRAY */
'/* reuse GL_INT_IMAGE_2D_ARRAY */
'/* reuse GL_INT_IMAGE_CUBE_MAP_ARRAY */
'/* reuse GL_INT_IMAGE_2D_MULTISAMPLE */
'/* reuse GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_UNSIGNED_INT_IMAGE_1D */
'/* reuse GL_UNSIGNED_INT_IMAGE_2D */
'/* reuse GL_UNSIGNED_INT_IMAGE_3D */
'/* reuse GL_UNSIGNED_INT_IMAGE_2D_RECT */
'/* reuse GL_UNSIGNED_INT_IMAGE_CUBE */
'/* reuse GL_UNSIGNED_INT_IMAGE_BUFFER */
'/* reuse GL_UNSIGNED_INT_IMAGE_1D_ARRAY */
'/* reuse GL_UNSIGNED_INT_IMAGE_2D_ARRAY */
'/* reuse GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY */
'/* reuse GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE */
'/* reuse GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_MAX_IMAGE_SAMPLES */
'/* reuse GL_IMAGE_BINDING_FORMAT */
'/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_TYPE */
'/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE */
'/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS */
'/* reuse GL_MAX_VERTEX_IMAGE_UNIFORMS */
'/* reuse GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS */
'/* reuse GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS */
'/* reuse GL_MAX_GEOMETRY_IMAGE_UNIFORMS */
'/* reuse GL_MAX_FRAGMENT_IMAGE_UNIFORMS */
'/* reuse GL_MAX_COMBINED_IMAGE_UNIFORMS */
'/* Reuse tokens from ARB_shading_language_packing (none) */
'/* Reuse tokens from ARB_texture_storage */
'/* reuse GL_TEXTURE_IMMUTABLE_FORMAT */
#ENDIF

#IF NOT %DEF(%GL_VERSION_4_3)
%GL_NUM_SHADING_LANGUAGE_VERSIONS  = &H82E9???
%GL_VERTEX_ATTRIB_ARRAY_LONG       = &H874E???
'/* Reuse tokens from ARB_arrays_of_arrays (none, GLSL only) */
'/* Reuse tokens from ARB_fragment_layer_viewport (none, GLSL only) */
'/* Reuse tokens from ARB_shader_image_size (none, GLSL only) */
'/* Reuse tokens from ARB_ES3_compatibility */
'/* reuse GL_COMPRESSED_RGB8_ETC2 */
'/* reuse GL_COMPRESSED_SRGB8_ETC2 */
'/* reuse GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
'/* reuse GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
'/* reuse GL_COMPRESSED_RGBA8_ETC2_EAC */
'/* reuse GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
'/* reuse GL_COMPRESSED_R11_EAC */
'/* reuse GL_COMPRESSED_SIGNED_R11_EAC */
'/* reuse GL_COMPRESSED_RG11_EAC */
'/* reuse GL_COMPRESSED_SIGNED_RG11_EAC */
'/* reuse GL_PRIMITIVE_RESTART_FIXED_INDEX */
'/* reuse GL_ANY_SAMPLES_PASSED_CONSERVATIVE */
'/* reuse GL_MAX_ELEMENT_INDEX */
'/* Reuse tokens from ARB_clear_buffer_object (none) */
'/* Reuse tokens from ARB_compute_shader */
'/* reuse GL_COMPUTE_SHADER */
'/* reuse GL_MAX_COMPUTE_UNIFORM_BLOCKS */
'/* reuse GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS */
'/* reuse GL_MAX_COMPUTE_IMAGE_UNIFORMS */
'/* reuse GL_MAX_COMPUTE_SHARED_MEMORY_SIZE */
'/* reuse GL_MAX_COMPUTE_UNIFORM_COMPONENTS */
'/* reuse GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS */
'/* reuse GL_MAX_COMPUTE_ATOMIC_COUNTERS */
'/* reuse GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS */
'/* reuse GL_MAX_COMPUTE_LOCAL_INVOCATIONS */
'/* reuse GL_MAX_COMPUTE_WORK_GROUP_COUNT */
'/* reuse GL_MAX_COMPUTE_WORK_GROUP_SIZE */
'/* reuse GL_COMPUTE_LOCAL_WORK_SIZE */
'/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER */
'/* reuse GL_DISPATCH_INDIRECT_BUFFER */
'/* reuse GL_DISPATCH_INDIRECT_BUFFER_BINDING */
'/* Reuse tokens from ARB_copy_image (none) */
'/* Reuse tokens from KHR_debug */
'/* reuse GL_DEBUG_OUTPUT_SYNCHRONOUS */
'/* reuse GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH */
'/* reuse GL_DEBUG_CALLBACK_FUNCTION */
'/* reuse GL_DEBUG_CALLBACK_USER_PARAM */
'/* reuse GL_DEBUG_SOURCE_API */
'/* reuse GL_DEBUG_SOURCE_WINDOW_SYSTEM */
'/* reuse GL_DEBUG_SOURCE_SHADER_COMPILER */
'/* reuse GL_DEBUG_SOURCE_THIRD_PARTY */
'/* reuse GL_DEBUG_SOURCE_APPLICATION */
'/* reuse GL_DEBUG_SOURCE_OTHER */
'/* reuse GL_DEBUG_TYPE_ERROR */
'/* reuse GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR */
'/* reuse GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR */
'/* reuse GL_DEBUG_TYPE_PORTABILITY */
'/* reuse GL_DEBUG_TYPE_PERFORMANCE */
'/* reuse GL_DEBUG_TYPE_OTHER */
'/* reuse GL_MAX_DEBUG_MESSAGE_LENGTH */
'/* reuse GL_MAX_DEBUG_LOGGED_MESSAGES */
'/* reuse GL_DEBUG_LOGGED_MESSAGES */
'/* reuse GL_DEBUG_SEVERITY_HIGH */
'/* reuse GL_DEBUG_SEVERITY_MEDIUM */
'/* reuse GL_DEBUG_SEVERITY_LOW */
'/* reuse GL_DEBUG_TYPE_MARKER */
'/* reuse GL_DEBUG_TYPE_PUSH_GROUP */
'/* reuse GL_DEBUG_TYPE_POP_GROUP */
'/* reuse GL_DEBUG_SEVERITY_NOTIFICATION */
'/* reuse GL_MAX_DEBUG_GROUP_STACK_DEPTH */
'/* reuse GL_DEBUG_GROUP_STACK_DEPTH */
'/* reuse GL_BUFFER */
'/* reuse GL_SHADER */
'/* reuse GL_PROGRAM */
'/* reuse GL_QUERY */
'/* reuse GL_PROGRAM_PIPELINE */
'/* reuse GL_SAMPLER */
'/* reuse GL_DISPLAY_LIST */
'/* reuse GL_MAX_LABEL_LENGTH */
'/* reuse GL_DEBUG_OUTPUT */
'/* reuse GL_CONTEXT_FLAG_DEBUG_BIT */
'/* reuse GL_STACK_UNDERFLOW */
'/* reuse GL_STACK_OVERFLOW */
'/* Reuse tokens from ARB_explicit_uniform_location */
'/* reuse GL_MAX_UNIFORM_LOCATIONS */
'/* Reuse tokens from ARB_framebuffer_no_attachments */
'/* reuse GL_FRAMEBUFFER_DEFAULT_WIDTH */
'/* reuse GL_FRAMEBUFFER_DEFAULT_HEIGHT */
'/* reuse GL_FRAMEBUFFER_DEFAULT_LAYERS */
'/* reuse GL_FRAMEBUFFER_DEFAULT_SAMPLES */
'/* reuse GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS */
'/* reuse GL_MAX_FRAMEBUFFER_WIDTH */
'/* reuse GL_MAX_FRAMEBUFFER_HEIGHT */
'/* reuse GL_MAX_FRAMEBUFFER_LAYERS */
'/* reuse GL_MAX_FRAMEBUFFER_SAMPLES */
'/* Reuse tokens from ARB_internalformat_query2 */
'/* reuse GL_INTERNALFORMAT_SUPPORTED */
'/* reuse GL_INTERNALFORMAT_PREFERRED */
'/* reuse GL_INTERNALFORMAT_RED_SIZE */
'/* reuse GL_INTERNALFORMAT_GREEN_SIZE */
'/* reuse GL_INTERNALFORMAT_BLUE_SIZE */
'/* reuse GL_INTERNALFORMAT_ALPHA_SIZE */
'/* reuse GL_INTERNALFORMAT_DEPTH_SIZE */
'/* reuse GL_INTERNALFORMAT_STENCIL_SIZE */
'/* reuse GL_INTERNALFORMAT_SHARED_SIZE */
'/* reuse GL_INTERNALFORMAT_RED_TYPE */
'/* reuse GL_INTERNALFORMAT_GREEN_TYPE */
'/* reuse GL_INTERNALFORMAT_BLUE_TYPE */
'/* reuse GL_INTERNALFORMAT_ALPHA_TYPE */
'/* reuse GL_INTERNALFORMAT_DEPTH_TYPE */
'/* reuse GL_INTERNALFORMAT_STENCIL_TYPE */
'/* reuse GL_MAX_WIDTH */
'/* reuse GL_MAX_HEIGHT */
'/* reuse GL_MAX_DEPTH */
'/* reuse GL_MAX_LAYERS */
'/* reuse GL_MAX_COMBINED_DIMENSIONS */
'/* reuse GL_COLOR_COMPONENTS */
'/* reuse GL_DEPTH_COMPONENTS */
'/* reuse GL_STENCIL_COMPONENTS */
'/* reuse GL_COLOR_RENDERABLE */
'/* reuse GL_DEPTH_RENDERABLE */
'/* reuse GL_STENCIL_RENDERABLE */
'/* reuse GL_FRAMEBUFFER_RENDERABLE */
'/* reuse GL_FRAMEBUFFER_RENDERABLE_LAYERED */
'/* reuse GL_FRAMEBUFFER_BLEND */
'/* reuse GL_READ_PIXELS */
'/* reuse GL_READ_PIXELS_FORMAT */
'/* reuse GL_READ_PIXELS_TYPE */
'/* reuse GL_TEXTURE_IMAGE_FORMAT */
'/* reuse GL_TEXTURE_IMAGE_TYPE */
'/* reuse GL_GET_TEXTURE_IMAGE_FORMAT */
'/* reuse GL_GET_TEXTURE_IMAGE_TYPE */
'/* reuse GL_MIPMAP */
'/* reuse GL_MANUAL_GENERATE_MIPMAP */
'/* reuse GL_AUTO_GENERATE_MIPMAP */
'/* reuse GL_COLOR_ENCODING */
'/* reuse GL_SRGB_READ */
'/* reuse GL_SRGB_WRITE */
'/* reuse GL_FILTER */
'/* reuse GL_VERTEX_TEXTURE */
'/* reuse GL_TESS_CONTROL_TEXTURE */
'/* reuse GL_TESS_EVALUATION_TEXTURE */
'/* reuse GL_GEOMETRY_TEXTURE */
'/* reuse GL_FRAGMENT_TEXTURE */
'/* reuse GL_COMPUTE_TEXTURE */
'/* reuse GL_TEXTURE_SHADOW */
'/* reuse GL_TEXTURE_GATHER */
'/* reuse GL_TEXTURE_GATHER_SHADOW */
'/* reuse GL_SHADER_IMAGE_LOAD */
'/* reuse GL_SHADER_IMAGE_STORE */
'/* reuse GL_SHADER_IMAGE_ATOMIC */
'/* reuse GL_IMAGE_TEXEL_SIZE */
'/* reuse GL_IMAGE_COMPATIBILITY_CLASS */
'/* reuse GL_IMAGE_PIXEL_FORMAT */
'/* reuse GL_IMAGE_PIXEL_TYPE */
'/* reuse GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST */
'/* reuse GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST */
'/* reuse GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE */
'/* reuse GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE */
'/* reuse GL_TEXTURE_COMPRESSED_BLOCK_WIDTH */
'/* reuse GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT */
'/* reuse GL_TEXTURE_COMPRESSED_BLOCK_SIZE */
'/* reuse GL_CLEAR_BUFFER */
'/* reuse GL_TEXTURE_VIEW */
'/* reuse GL_VIEW_COMPATIBILITY_CLASS */
'/* reuse GL_FULL_SUPPORT */
'/* reuse GL_CAVEAT_SUPPORT */
'/* reuse GL_IMAGE_CLASS_4_X_32 */
'/* reuse GL_IMAGE_CLASS_2_X_32 */
'/* reuse GL_IMAGE_CLASS_1_X_32 */
'/* reuse GL_IMAGE_CLASS_4_X_16 */
'/* reuse GL_IMAGE_CLASS_2_X_16 */
'/* reuse GL_IMAGE_CLASS_1_X_16 */
'/* reuse GL_IMAGE_CLASS_4_X_8 */
'/* reuse GL_IMAGE_CLASS_2_X_8 */
'/* reuse GL_IMAGE_CLASS_1_X_8 */
'/* reuse GL_IMAGE_CLASS_11_11_10 */
'/* reuse GL_IMAGE_CLASS_10_10_10_2 */
'/* reuse GL_VIEW_CLASS_128_BITS */
'/* reuse GL_VIEW_CLASS_96_BITS */
'/* reuse GL_VIEW_CLASS_64_BITS */
'/* reuse GL_VIEW_CLASS_48_BITS */
'/* reuse GL_VIEW_CLASS_32_BITS */
'/* reuse GL_VIEW_CLASS_24_BITS */
'/* reuse GL_VIEW_CLASS_16_BITS */
'/* reuse GL_VIEW_CLASS_8_BITS */
'/* reuse GL_VIEW_CLASS_S3TC_DXT1_RGB */
'/* reuse GL_VIEW_CLASS_S3TC_DXT1_RGBA */
'/* reuse GL_VIEW_CLASS_S3TC_DXT3_RGBA */
'/* reuse GL_VIEW_CLASS_S3TC_DXT5_RGBA */
'/* reuse GL_VIEW_CLASS_RGTC1_RED */
'/* reuse GL_VIEW_CLASS_RGTC2_RG */
'/* reuse GL_VIEW_CLASS_BPTC_UNORM */
'/* reuse GL_VIEW_CLASS_BPTC_FLOAT */
'/* Reuse tokens from ARB_invalidate_subdata (none) */
'/* Reuse tokens from ARB_multi_draw_indirect (none) */
'/* Reuse tokens from ARB_program_interface_query */
'/* reuse GL_UNIFORM */
'/* reuse GL_UNIFORM_BLOCK */
'/* reuse GL_PROGRAM_INPUT */
'/* reuse GL_PROGRAM_OUTPUT */
'/* reuse GL_BUFFER_VARIABLE */
'/* reuse GL_SHADER_STORAGE_BLOCK */
'/* reuse GL_VERTEX_SUBROUTINE */
'/* reuse GL_TESS_CONTROL_SUBROUTINE */
'/* reuse GL_TESS_EVALUATION_SUBROUTINE */
'/* reuse GL_GEOMETRY_SUBROUTINE */
'/* reuse GL_FRAGMENT_SUBROUTINE */
'/* reuse GL_COMPUTE_SUBROUTINE */
'/* reuse GL_VERTEX_SUBROUTINE_UNIFORM */
'/* reuse GL_TESS_CONTROL_SUBROUTINE_UNIFORM */
'/* reuse GL_TESS_EVALUATION_SUBROUTINE_UNIFORM */
'/* reuse GL_GEOMETRY_SUBROUTINE_UNIFORM */
'/* reuse GL_FRAGMENT_SUBROUTINE_UNIFORM */
'/* reuse GL_COMPUTE_SUBROUTINE_UNIFORM */
'/* reuse GL_TRANSFORM_FEEDBACK_VARYING */
'/* reuse GL_ACTIVE_RESOURCES */
'/* reuse GL_MAX_NAME_LENGTH */
'/* reuse GL_MAX_NUM_ACTIVE_VARIABLES */
'/* reuse GL_MAX_NUM_COMPATIBLE_SUBROUTINES */
'/* reuse GL_NAME_LENGTH */
'/* reuse GL_TYPE */
'/* reuse GL_ARRAY_SIZE */
'/* reuse GL_OFFSET */
'/* reuse GL_BLOCK_INDEX */
'/* reuse GL_ARRAY_STRIDE */
'/* reuse GL_MATRIX_STRIDE */
'/* reuse GL_IS_ROW_MAJOR */
'/* reuse GL_ATOMIC_COUNTER_BUFFER_INDEX */
'/* reuse GL_BUFFER_BINDING */
'/* reuse GL_BUFFER_DATA_SIZE */
'/* reuse GL_NUM_ACTIVE_VARIABLES */
'/* reuse GL_ACTIVE_VARIABLES */
'/* reuse GL_REFERENCED_BY_VERTEX_SHADER */
'/* reuse GL_REFERENCED_BY_TESS_CONTROL_SHADER */
'/* reuse GL_REFERENCED_BY_TESS_EVALUATION_SHADER */
'/* reuse GL_REFERENCED_BY_GEOMETRY_SHADER */
'/* reuse GL_REFERENCED_BY_FRAGMENT_SHADER */
'/* reuse GL_REFERENCED_BY_COMPUTE_SHADER */
'/* reuse GL_TOP_LEVEL_ARRAY_SIZE */
'/* reuse GL_TOP_LEVEL_ARRAY_STRIDE */
'/* reuse GL_LOCATION */
'/* reuse GL_LOCATION_INDEX */
'/* reuse GL_IS_PER_PATCH */
'/* Reuse tokens from ARB_robust_buffer_access_behavior (none) */
'/* Reuse tokens from ARB_shader_storage_buffer_object */
'/* reuse GL_SHADER_STORAGE_BUFFER */
'/* reuse GL_SHADER_STORAGE_BUFFER_BINDING */
'/* reuse GL_SHADER_STORAGE_BUFFER_START */
'/* reuse GL_SHADER_STORAGE_BUFFER_SIZE */
'/* reuse GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS */
'/* reuse GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS */
'/* reuse GL_MAX_SHADER_STORAGE_BLOCK_SIZE */
'/* reuse GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT */
'/* reuse GL_SHADER_STORAGE_BARRIER_BIT */
'/* reuse GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES */
'/* Reuse tokens from ARB_stencil_texturing */
'/* reuse GL_DEPTH_STENCIL_TEXTURE_MODE */
'/* Reuse tokens from ARB_texture_buffer_range */
'/* reuse GL_TEXTURE_BUFFER_OFFSET */
'/* reuse GL_TEXTURE_BUFFER_SIZE */
'/* reuse GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT */
'/* Reuse tokens from ARB_texture_query_levels (none) */
'/* Reuse tokens from ARB_texture_storage_multisample (none) */
'/* Reuse tokens from ARB_texture_view */
'/* reuse GL_TEXTURE_VIEW_MIN_LEVEL */
'/* reuse GL_TEXTURE_VIEW_NUM_LEVELS */
'/* reuse GL_TEXTURE_VIEW_MIN_LAYER */
'/* reuse GL_TEXTURE_VIEW_NUM_LAYERS */
'/* reuse GL_TEXTURE_IMMUTABLE_LEVELS */
'/* Reuse tokens from ARB_vertex_attrib_binding */
'/* reuse GL_VERTEX_ATTRIB_BINDING */
'/* reuse GL_VERTEX_ATTRIB_RELATIVE_OFFSET */
'/* reuse GL_VERTEX_BINDING_DIVISOR */
'/* reuse GL_VERTEX_BINDING_OFFSET */
'/* reuse GL_VERTEX_BINDING_STRIDE */
'/* reuse GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET */
'/* reuse GL_MAX_VERTEX_ATTRIB_BINDINGS */
#ENDIF

#IF NOT %DEF(%GL_ARB_multitexture)
%GL_TEXTURE0_ARB                                      = &H84C0???
%GL_TEXTURE1_ARB                                      = &H84C1???
%GL_TEXTURE2_ARB                                      = &H84C2???
%GL_TEXTURE3_ARB                                      = &H84C3???
%GL_TEXTURE4_ARB                                      = &H84C4???
%GL_TEXTURE5_ARB                                      = &H84C5???
%GL_TEXTURE6_ARB                                      = &H84C6???
%GL_TEXTURE7_ARB                                      = &H84C7???
%GL_TEXTURE8_ARB                                      = &H84C8???
%GL_TEXTURE9_ARB                                      = &H84C9???
%GL_TEXTURE10_ARB                                     = &H84CA???
%GL_TEXTURE11_ARB                                     = &H84CB???
%GL_TEXTURE12_ARB                                     = &H84CC???
%GL_TEXTURE13_ARB                                     = &H84CD???
%GL_TEXTURE14_ARB                                     = &H84CE???
%GL_TEXTURE15_ARB                                     = &H84CF???
%GL_TEXTURE16_ARB                                     = &H84D0???
%GL_TEXTURE17_ARB                                     = &H84D1???
%GL_TEXTURE18_ARB                                     = &H84D2???
%GL_TEXTURE19_ARB                                     = &H84D3???
%GL_TEXTURE20_ARB                                     = &H84D4???
%GL_TEXTURE21_ARB                                     = &H84D5???
%GL_TEXTURE22_ARB                                     = &H84D6???
%GL_TEXTURE23_ARB                                     = &H84D7???
%GL_TEXTURE24_ARB                                     = &H84D8???
%GL_TEXTURE25_ARB                                     = &H84D9???
%GL_TEXTURE26_ARB                                     = &H84DA???
%GL_TEXTURE27_ARB                                     = &H84DB???
%GL_TEXTURE28_ARB                                     = &H84DC???
%GL_TEXTURE29_ARB                                     = &H84DD???
%GL_TEXTURE30_ARB                                     = &H84DE???
%GL_TEXTURE31_ARB                                     = &H84DF???
%GL_ACTIVE_TEXTURE_ARB                                = &H84E0???
%GL_CLIENT_ACTIVE_TEXTURE_ARB                         = &H84E1???
%GL_MAX_TEXTURE_UNITS_ARB                             = &H84E2???
#ENDIF

#IF NOT %DEF(%GL_ARB_transpose_matrix)
%GL_TRANSPOSE_MODELVIEW_MATRIX_ARB                    = &H84E3???
%GL_TRANSPOSE_PROJECTION_MATRIX_ARB                   = &H84E4???
%GL_TRANSPOSE_TEXTURE_MATRIX_ARB                      = &H84E5???
%GL_TRANSPOSE_COLOR_MATRIX_ARB                        = &H84E6???
#ENDIF

#IF NOT %DEF(%GL_ARB_multisample)
%GL_MULTISAMPLE_ARB                                   = &H809D???
%GL_SAMPLE_ALPHA_TO_COVERAGE_ARB                      = &H809E???
%GL_SAMPLE_ALPHA_TO_ONE_ARB                           = &H809F???
%GL_SAMPLE_COVERAGE_ARB                               = &H80A0???
%GL_SAMPLE_BUFFERS_ARB                                = &H80A8???
%GL_SAMPLES_ARB                                       = &H80A9???
%GL_SAMPLE_COVERAGE_VALUE_ARB                         = &H80AA???
%GL_SAMPLE_COVERAGE_INVERT_ARB                        = &H80AB???
%GL_MULTISAMPLE_BIT_ARB                               = &H20000000???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_env_add)
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_cube_map)
%GL_NORMAL_MAP_ARB                                    = &H8511???
%GL_REFLECTION_MAP_ARB                                = &H8512???
%GL_TEXTURE_CUBE_MAP_ARB                              = &H8513???
%GL_TEXTURE_BINDING_CUBE_MAP_ARB                      = &H8514???
%GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB                   = &H8515???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB                   = &H8516???
%GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB                   = &H8517???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB                   = &H8518???
%GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB                   = &H8519???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB                   = &H851A???
%GL_PROXY_TEXTURE_CUBE_MAP_ARB                        = &H851B???
%GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB                     = &H851C???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_compression)
%GL_COMPRESSED_ALPHA_ARB                              = &H84E9???
%GL_COMPRESSED_LUMINANCE_ARB                          = &H84EA???
%GL_COMPRESSED_LUMINANCE_ALPHA_ARB                    = &H84EB???
%GL_COMPRESSED_INTENSITY_ARB                          = &H84EC???
%GL_COMPRESSED_RGB_ARB                                = &H84ED???
%GL_COMPRESSED_RGBA_ARB                               = &H84EE???
%GL_TEXTURE_COMPRESSION_HINT_ARB                      = &H84EF???
%GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB                 = &H86A0???
%GL_TEXTURE_COMPRESSED_ARB                            = &H86A1???
%GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB                = &H86A2???
%GL_COMPRESSED_TEXTURE_FORMATS_ARB                    = &H86A3???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_border_clamp)
%GL_CLAMP_TO_BORDER_ARB                               = &H812D???
#ENDIF

#IF NOT %DEF(%GL_ARB_point_parameters)
%GL_POINT_SIZE_MIN_ARB                                = &H8126???
%GL_POINT_SIZE_MAX_ARB                                = &H8127???
%GL_POINT_FADE_THRESHOLD_SIZE_ARB                     = &H8128???
%GL_POINT_DISTANCE_ATTENUATION_ARB                    = &H8129???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_blend)
%GL_MAX_VERTEX_UNITS_ARB                              = &H86A4???
%GL_ACTIVE_VERTEX_UNITS_ARB                           = &H86A5???
%GL_WEIGHT_SUM_UNITY_ARB                              = &H86A6???
%GL_VERTEX_BLEND_ARB                                  = &H86A7???
%GL_CURRENT_WEIGHT_ARB                                = &H86A8???
%GL_WEIGHT_ARRAY_TYPE_ARB                             = &H86A9???
%GL_WEIGHT_ARRAY_STRIDE_ARB                           = &H86AA???
%GL_WEIGHT_ARRAY_SIZE_ARB                             = &H86AB???
%GL_WEIGHT_ARRAY_POINTER_ARB                          = &H86AC???
%GL_WEIGHT_ARRAY_ARB                                  = &H86AD???
%GL_MODELVIEW0_ARB                                    = &H1700???
%GL_MODELVIEW1_ARB                                    = &H850A???
%GL_MODELVIEW2_ARB                                    = &H8722???
%GL_MODELVIEW3_ARB                                    = &H8723???
%GL_MODELVIEW4_ARB                                    = &H8724???
%GL_MODELVIEW5_ARB                                    = &H8725???
%GL_MODELVIEW6_ARB                                    = &H8726???
%GL_MODELVIEW7_ARB                                    = &H8727???
%GL_MODELVIEW8_ARB                                    = &H8728???
%GL_MODELVIEW9_ARB                                    = &H8729???
%GL_MODELVIEW10_ARB                                   = &H872A???
%GL_MODELVIEW11_ARB                                   = &H872B???
%GL_MODELVIEW12_ARB                                   = &H872C???
%GL_MODELVIEW13_ARB                                   = &H872D???
%GL_MODELVIEW14_ARB                                   = &H872E???
%GL_MODELVIEW15_ARB                                   = &H872F???
%GL_MODELVIEW16_ARB                                   = &H8730???
%GL_MODELVIEW17_ARB                                   = &H8731???
%GL_MODELVIEW18_ARB                                   = &H8732???
%GL_MODELVIEW19_ARB                                   = &H8733???
%GL_MODELVIEW20_ARB                                   = &H8734???
%GL_MODELVIEW21_ARB                                   = &H8735???
%GL_MODELVIEW22_ARB                                   = &H8736???
%GL_MODELVIEW23_ARB                                   = &H8737???
%GL_MODELVIEW24_ARB                                   = &H8738???
%GL_MODELVIEW25_ARB                                   = &H8739???
%GL_MODELVIEW26_ARB                                   = &H873A???
%GL_MODELVIEW27_ARB                                   = &H873B???
%GL_MODELVIEW28_ARB                                   = &H873C???
%GL_MODELVIEW29_ARB                                   = &H873D???
%GL_MODELVIEW30_ARB                                   = &H873E???
%GL_MODELVIEW31_ARB                                   = &H873F???
#ENDIF

#IF NOT %DEF(%GL_ARB_matrix_palette)
%GL_MATRIX_PALETTE_ARB                                = &H8840???
%GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB                = &H8841???
%GL_MAX_PALETTE_MATRICES_ARB                          = &H8842???
%GL_CURRENT_PALETTE_MATRIX_ARB                        = &H8843???
%GL_MATRIX_INDEX_ARRAY_ARB                            = &H8844???
%GL_CURRENT_MATRIX_INDEX_ARB                          = &H8845???
%GL_MATRIX_INDEX_ARRAY_SIZE_ARB                       = &H8846???
%GL_MATRIX_INDEX_ARRAY_TYPE_ARB                       = &H8847???
%GL_MATRIX_INDEX_ARRAY_STRIDE_ARB                     = &H8848???
%GL_MATRIX_INDEX_ARRAY_POINTER_ARB                    = &H8849???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_env_combine)
%GL_COMBINE_ARB                                       = &H8570???
%GL_COMBINE_RGB_ARB                                   = &H8571???
%GL_COMBINE_ALPHA_ARB                                 = &H8572???
%GL_SOURCE0_RGB_ARB                                   = &H8580???
%GL_SOURCE1_RGB_ARB                                   = &H8581???
%GL_SOURCE2_RGB_ARB                                   = &H8582???
%GL_SOURCE0_ALPHA_ARB                                 = &H8588???
%GL_SOURCE1_ALPHA_ARB                                 = &H8589???
%GL_SOURCE2_ALPHA_ARB                                 = &H858A???
%GL_OPERAND0_RGB_ARB                                  = &H8590???
%GL_OPERAND1_RGB_ARB                                  = &H8591???
%GL_OPERAND2_RGB_ARB                                  = &H8592???
%GL_OPERAND0_ALPHA_ARB                                = &H8598???
%GL_OPERAND1_ALPHA_ARB                                = &H8599???
%GL_OPERAND2_ALPHA_ARB                                = &H859A???
%GL_RGB_SCALE_ARB                                     = &H8573???
%GL_ADD_SIGNED_ARB                                    = &H8574???
%GL_INTERPOLATE_ARB                                   = &H8575???
%GL_SUBTRACT_ARB                                      = &H84E7???
%GL_CONSTANT_ARB                                      = &H8576???
%GL_PRIMARY_COLOR_ARB                                 = &H8577???
%GL_PREVIOUS_ARB                                      = &H8578???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_env_crossbar)
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_env_dot3)
%GL_DOT3_RGB_ARB                                      = &H86AE???
%GL_DOT3_RGBA_ARB                                     = &H86AF???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_mirrored_repeat)
%GL_MIRRORED_REPEAT_ARB                               = &H8370???
#ENDIF

#IF NOT %DEF(%GL_ARB_depth_texture)
%GL_DEPTH_COMPONENT16_ARB                             = &H81A5???
%GL_DEPTH_COMPONENT24_ARB                             = &H81A6???
%GL_DEPTH_COMPONENT32_ARB                             = &H81A7???
%GL_TEXTURE_DEPTH_SIZE_ARB                            = &H884A???
%GL_DEPTH_TEXTURE_MODE_ARB                            = &H884B???
#ENDIF

#IF NOT %DEF(%GL_ARB_shadow)
%GL_TEXTURE_COMPARE_MODE_ARB                          = &H884C???
%GL_TEXTURE_COMPARE_FUNC_ARB                          = &H884D???
%GL_COMPARE_R_TO_TEXTURE_ARB                          = &H884E???
#ENDIF

#IF NOT %DEF(%GL_ARB_shadow_ambient)
%GL_TEXTURE_COMPARE_FAIL_VALUE_ARB                    = &H80BF???
#ENDIF

#IF NOT %DEF(%GL_ARB_window_pos)
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_program)
%GL_COLOR_SUM_ARB                                     = &H8458???
%GL_VERTEX_PROGRAM_ARB                                = &H8620???
%GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB                   = &H8622???
%GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB                      = &H8623???
%GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB                    = &H8624???
%GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB                      = &H8625???
%GL_CURRENT_VERTEX_ATTRIB_ARB                         = &H8626???
%GL_PROGRAM_LENGTH_ARB                                = &H8627???
%GL_PROGRAM_STRING_ARB                                = &H8628???
%GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB                = &H862E???
%GL_MAX_PROGRAM_MATRICES_ARB                          = &H862F???
%GL_CURRENT_MATRIX_STACK_DEPTH_ARB                    = &H8640???
%GL_CURRENT_MATRIX_ARB                                = &H8641???
%GL_VERTEX_PROGRAM_POINT_SIZE_ARB                     = &H8642???
%GL_VERTEX_PROGRAM_TWO_SIDE_ARB                       = &H8643???
%GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB                   = &H8645???
%GL_PROGRAM_ERROR_POSITION_ARB                        = &H864B???
%GL_PROGRAM_BINDING_ARB                               = &H8677???
%GL_MAX_VERTEX_ATTRIBS_ARB                            = &H8869???
%GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB                = &H886A???
%GL_PROGRAM_ERROR_STRING_ARB                          = &H8874???
%GL_PROGRAM_FORMAT_ASCII_ARB                          = &H8875???
%GL_PROGRAM_FORMAT_ARB                                = &H8876???
%GL_PROGRAM_INSTRUCTIONS_ARB                          = &H88A0???
%GL_MAX_PROGRAM_INSTRUCTIONS_ARB                      = &H88A1???
%GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB                   = &H88A2???
%GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB               = &H88A3???
%GL_PROGRAM_TEMPORARIES_ARB                           = &H88A4???
%GL_MAX_PROGRAM_TEMPORARIES_ARB                       = &H88A5???
%GL_PROGRAM_NATIVE_TEMPORARIES_ARB                    = &H88A6???
%GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB                = &H88A7???
%GL_PROGRAM_PARAMETERS_ARB                            = &H88A8???
%GL_MAX_PROGRAM_PARAMETERS_ARB                        = &H88A9???
%GL_PROGRAM_NATIVE_PARAMETERS_ARB                     = &H88AA???
%GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB                 = &H88AB???
%GL_PROGRAM_ATTRIBS_ARB                               = &H88AC???
%GL_MAX_PROGRAM_ATTRIBS_ARB                           = &H88AD???
%GL_PROGRAM_NATIVE_ATTRIBS_ARB                        = &H88AE???
%GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB                    = &H88AF???
%GL_PROGRAM_ADDRESS_REGISTERS_ARB                     = &H88B0???
%GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB                 = &H88B1???
%GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB              = &H88B2???
%GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB          = &H88B3???
%GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB                  = &H88B4???
%GL_MAX_PROGRAM_ENV_PARAMETERS_ARB                    = &H88B5???
%GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB                   = &H88B6???
%GL_TRANSPOSE_CURRENT_MATRIX_ARB                      = &H88B7???
%GL_MATRIX0_ARB                                       = &H88C0???
%GL_MATRIX1_ARB                                       = &H88C1???
%GL_MATRIX2_ARB                                       = &H88C2???
%GL_MATRIX3_ARB                                       = &H88C3???
%GL_MATRIX4_ARB                                       = &H88C4???
%GL_MATRIX5_ARB                                       = &H88C5???
%GL_MATRIX6_ARB                                       = &H88C6???
%GL_MATRIX7_ARB                                       = &H88C7???
%GL_MATRIX8_ARB                                       = &H88C8???
%GL_MATRIX9_ARB                                       = &H88C9???
%GL_MATRIX10_ARB                                      = &H88CA???
%GL_MATRIX11_ARB                                      = &H88CB???
%GL_MATRIX12_ARB                                      = &H88CC???
%GL_MATRIX13_ARB                                      = &H88CD???
%GL_MATRIX14_ARB                                      = &H88CE???
%GL_MATRIX15_ARB                                      = &H88CF???
%GL_MATRIX16_ARB                                      = &H88D0???
%GL_MATRIX17_ARB                                      = &H88D1???
%GL_MATRIX18_ARB                                      = &H88D2???
%GL_MATRIX19_ARB                                      = &H88D3???
%GL_MATRIX20_ARB                                      = &H88D4???
%GL_MATRIX21_ARB                                      = &H88D5???
%GL_MATRIX22_ARB                                      = &H88D6???
%GL_MATRIX23_ARB                                      = &H88D7???
%GL_MATRIX24_ARB                                      = &H88D8???
%GL_MATRIX25_ARB                                      = &H88D9???
%GL_MATRIX26_ARB                                      = &H88DA???
%GL_MATRIX27_ARB                                      = &H88DB???
%GL_MATRIX28_ARB                                      = &H88DC???
%GL_MATRIX29_ARB                                      = &H88DD???
%GL_MATRIX30_ARB                                      = &H88DE???
%GL_MATRIX31_ARB                                      = &H88DF???
#ENDIF

#IF NOT %DEF(%GL_ARB_fragment_program)
%GL_FRAGMENT_PROGRAM_ARB                              = &H8804???
%GL_PROGRAM_ALU_INSTRUCTIONS_ARB                      = &H8805???
%GL_PROGRAM_TEX_INSTRUCTIONS_ARB                      = &H8806???
%GL_PROGRAM_TEX_INDIRECTIONS_ARB                      = &H8807???
%GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB               = &H8808???
%GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB               = &H8809???
%GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB               = &H880A???
%GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB                  = &H880B???
%GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB                  = &H880C???
%GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB                  = &H880D???
%GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB           = &H880E???
%GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB           = &H880F???
%GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB           = &H8810???
%GL_MAX_TEXTURE_COORDS_ARB                            = &H8871???
%GL_MAX_TEXTURE_IMAGE_UNITS_ARB                       = &H8872???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_buffer_object)
%GL_BUFFER_SIZE_ARB                                   = &H8764???
%GL_BUFFER_USAGE_ARB                                  = &H8765???
%GL_ARRAY_BUFFER_ARB                                  = &H8892???
%GL_ELEMENT_ARRAY_BUFFER_ARB                          = &H8893???
%GL_ARRAY_BUFFER_BINDING_ARB                          = &H8894???
%GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB                  = &H8895???
%GL_VERTEX_ARRAY_BUFFER_BINDING_ARB                   = &H8896???
%GL_NORMAL_ARRAY_BUFFER_BINDING_ARB                   = &H8897???
%GL_COLOR_ARRAY_BUFFER_BINDING_ARB                    = &H8898???
%GL_INDEX_ARRAY_BUFFER_BINDING_ARB                    = &H8899???
%GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB            = &H889A???
%GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB                = &H889B???
%GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB          = &H889C???
%GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB           = &H889D???
%GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB                   = &H889E???
%GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB            = &H889F???
%GL_READ_ONLY_ARB                                     = &H88B8???
%GL_WRITE_ONLY_ARB                                    = &H88B9???
%GL_READ_WRITE_ARB                                    = &H88BA???
%GL_BUFFER_ACCESS_ARB                                 = &H88BB???
%GL_BUFFER_MAPPED_ARB                                 = &H88BC???
%GL_BUFFER_MAP_POINTER_ARB                            = &H88BD???
%GL_STREAM_DRAW_ARB                                   = &H88E0???
%GL_STREAM_READ_ARB                                   = &H88E1???
%GL_STREAM_COPY_ARB                                   = &H88E2???
%GL_STATIC_DRAW_ARB                                   = &H88E4???
%GL_STATIC_READ_ARB                                   = &H88E5???
%GL_STATIC_COPY_ARB                                   = &H88E6???
%GL_DYNAMIC_DRAW_ARB                                  = &H88E8???
%GL_DYNAMIC_READ_ARB                                  = &H88E9???
%GL_DYNAMIC_COPY_ARB                                  = &H88EA???
#ENDIF

#IF NOT %DEF(%GL_ARB_occlusion_query)
%GL_QUERY_COUNTER_BITS_ARB                            = &H8864???
%GL_CURRENT_QUERY_ARB                                 = &H8865???
%GL_QUERY_RESULT_ARB                                  = &H8866???
%GL_QUERY_RESULT_AVAILABLE_ARB                        = &H8867???
%GL_SAMPLES_PASSED_ARB                                = &H8914???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_objects)
%GL_PROGRAM_OBJECT_ARB                                = &H8B40???
%GL_SHADER_OBJECT_ARB                                 = &H8B48???
%GL_OBJECT_TYPE_ARB                                   = &H8B4E???
%GL_OBJECT_SUBTYPE_ARB                                = &H8B4F???
%GL_FLOAT_VEC2_ARB                                    = &H8B50???
%GL_FLOAT_VEC3_ARB                                    = &H8B51???
%GL_FLOAT_VEC4_ARB                                    = &H8B52???
%GL_INT_VEC2_ARB                                      = &H8B53???
%GL_INT_VEC3_ARB                                      = &H8B54???
%GL_INT_VEC4_ARB                                      = &H8B55???
%GL_BOOL_ARB                                          = &H8B56???
%GL_BOOL_VEC2_ARB                                     = &H8B57???
%GL_BOOL_VEC3_ARB                                     = &H8B58???
%GL_BOOL_VEC4_ARB                                     = &H8B59???
%GL_FLOAT_MAT2_ARB                                    = &H8B5A???
%GL_FLOAT_MAT3_ARB                                    = &H8B5B???
%GL_FLOAT_MAT4_ARB                                    = &H8B5C???
%GL_SAMPLER_1D_ARB                                    = &H8B5D???
%GL_SAMPLER_2D_ARB                                    = &H8B5E???
%GL_SAMPLER_3D_ARB                                    = &H8B5F???
%GL_SAMPLER_CUBE_ARB                                  = &H8B60???
%GL_SAMPLER_1D_SHADOW_ARB                             = &H8B61???
%GL_SAMPLER_2D_SHADOW_ARB                             = &H8B62???
%GL_SAMPLER_2D_RECT_ARB                               = &H8B63???
%GL_SAMPLER_2D_RECT_SHADOW_ARB                        = &H8B64???
%GL_OBJECT_DELETE_STATUS_ARB                          = &H8B80???
%GL_OBJECT_COMPILE_STATUS_ARB                         = &H8B81???
%GL_OBJECT_LINK_STATUS_ARB                            = &H8B82???
%GL_OBJECT_VALIDATE_STATUS_ARB                        = &H8B83???
%GL_OBJECT_INFO_LOG_LENGTH_ARB                        = &H8B84???
%GL_OBJECT_ATTACHED_OBJECTS_ARB                       = &H8B85???
%GL_OBJECT_ACTIVE_UNIFORMS_ARB                        = &H8B86???
%GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB              = &H8B87???
%GL_OBJECT_SHADER_SOURCE_LENGTH_ARB                   = &H8B88???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_shader)
%GL_VERTEX_SHADER_ARB                                 = &H8B31???
%GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB                 = &H8B4A???
%GL_MAX_VARYING_FLOATS_ARB                            = &H8B4B???
%GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB                = &H8B4C???
%GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB              = &H8B4D???
%GL_OBJECT_ACTIVE_ATTRIBUTES_ARB                      = &H8B89???
%GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB            = &H8B8A???
#ENDIF

#IF NOT %DEF(%GL_ARB_fragment_shader)
%GL_FRAGMENT_SHADER_ARB                               = &H8B30???
%GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB               = &H8B49???
%GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB               = &H8B8B???
#ENDIF

#IF NOT %DEF(%GL_ARB_shading_language_100)
%GL_SHADING_LANGUAGE_VERSION_ARB                      = &H8B8C???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_non_power_of_two)
#ENDIF

#IF NOT %DEF(%GL_ARB_point_sprite)
%GL_POINT_SPRITE_ARB                                  = &H8861???
%GL_COORD_REPLACE_ARB                                 = &H8862???
#ENDIF

#IF NOT %DEF(%GL_ARB_fragment_program_shadow)
#ENDIF

#IF NOT %DEF(%GL_ARB_draw_buffers)
%GL_MAX_DRAW_BUFFERS_ARB                              = &H8824???
%GL_DRAW_BUFFER0_ARB                                  = &H8825???
%GL_DRAW_BUFFER1_ARB                                  = &H8826???
%GL_DRAW_BUFFER2_ARB                                  = &H8827???
%GL_DRAW_BUFFER3_ARB                                  = &H8828???
%GL_DRAW_BUFFER4_ARB                                  = &H8829???
%GL_DRAW_BUFFER5_ARB                                  = &H882A???
%GL_DRAW_BUFFER6_ARB                                  = &H882B???
%GL_DRAW_BUFFER7_ARB                                  = &H882C???
%GL_DRAW_BUFFER8_ARB                                  = &H882D???
%GL_DRAW_BUFFER9_ARB                                  = &H882E???
%GL_DRAW_BUFFER10_ARB                                 = &H882F???
%GL_DRAW_BUFFER11_ARB                                 = &H8830???
%GL_DRAW_BUFFER12_ARB                                 = &H8831???
%GL_DRAW_BUFFER13_ARB                                 = &H8832???
%GL_DRAW_BUFFER14_ARB                                 = &H8833???
%GL_DRAW_BUFFER15_ARB                                 = &H8834???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_rectangle)
%GL_TEXTURE_RECTANGLE_ARB                             = &H84F5???
%GL_TEXTURE_BINDING_RECTANGLE_ARB                     = &H84F6???
%GL_PROXY_TEXTURE_RECTANGLE_ARB                       = &H84F7???
%GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB                    = &H84F8???
#ENDIF

#IF NOT %DEF(%GL_ARB_color_buffer_float)
%GL_RGBA_FLOAT_MODE_ARB                               = &H8820???
%GL_CLAMP_VERTEX_COLOR_ARB                            = &H891A???
%GL_CLAMP_FRAGMENT_COLOR_ARB                          = &H891B???
%GL_CLAMP_READ_COLOR_ARB                              = &H891C???
%GL_FIXED_ONLY_ARB                                    = &H891D???
#ENDIF

#IF NOT %DEF(%GL_ARB_half_float_pixel)
%GL_HALF_FLOAT_ARB                                    = &H140B???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_float)
%GL_TEXTURE_RED_TYPE_ARB                              = &H8C10???
%GL_TEXTURE_GREEN_TYPE_ARB                            = &H8C11???
%GL_TEXTURE_BLUE_TYPE_ARB                             = &H8C12???
%GL_TEXTURE_ALPHA_TYPE_ARB                            = &H8C13???
%GL_TEXTURE_LUMINANCE_TYPE_ARB                        = &H8C14???
%GL_TEXTURE_INTENSITY_TYPE_ARB                        = &H8C15???
%GL_TEXTURE_DEPTH_TYPE_ARB                            = &H8C16???
%GL_UNSIGNED_NORMALIZED_ARB                           = &H8C17???
%GL_RGBA32F_ARB                                       = &H8814???
%GL_RGB32F_ARB                                        = &H8815???
%GL_ALPHA32F_ARB                                      = &H8816???
%GL_INTENSITY32F_ARB                                  = &H8817???
%GL_LUMINANCE32F_ARB                                  = &H8818???
%GL_LUMINANCE_ALPHA32F_ARB                            = &H8819???
%GL_RGBA16F_ARB                                       = &H881A???
%GL_RGB16F_ARB                                        = &H881B???
%GL_ALPHA16F_ARB                                      = &H881C???
%GL_INTENSITY16F_ARB                                  = &H881D???
%GL_LUMINANCE16F_ARB                                  = &H881E???
%GL_LUMINANCE_ALPHA16F_ARB                            = &H881F???
#ENDIF

#IF NOT %DEF(%GL_ARB_pixel_buffer_object)
%GL_PIXEL_PACK_BUFFER_ARB                             = &H88EB???
%GL_PIXEL_UNPACK_BUFFER_ARB                           = &H88EC???
%GL_PIXEL_PACK_BUFFER_BINDING_ARB                     = &H88ED???
%GL_PIXEL_UNPACK_BUFFER_BINDING_ARB                   = &H88EF???
#ENDIF

#IF NOT %DEF(%GL_ARB_depth_buffer_float)
%GL_DEPTH_COMPONENT32F                                = &H8CAC???
%GL_DEPTH32F_STENCIL8                                 = &H8CAD???
%GL_FLOAT_32_UNSIGNED_INT_24_8_REV                    = &H8DAD???
#ENDIF

#IF NOT %DEF(%GL_ARB_draw_instanced)
#ENDIF

#IF NOT %DEF(%GL_ARB_framebuffer_object)
%GL_INVALID_FRAMEBUFFER_OPERATION                     = &H0506???
%GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING             = &H8210???
%GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE             = &H8211???
%GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE                   = &H8212???
%GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE                 = &H8213???
%GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE                  = &H8214???
%GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE                 = &H8215???
%GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE                 = &H8216???
%GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE               = &H8217???
%GL_FRAMEBUFFER_DEFAULT                               = &H8218???
%GL_FRAMEBUFFER_UNDEFINED                             = &H8219???
%GL_DEPTH_STENCIL_ATTACHMENT                          = &H821A???
%GL_MAX_RENDERBUFFER_SIZE                             = &H84E8???
%GL_DEPTH_STENCIL                                     = &H84F9???
%GL_UNSIGNED_INT_24_8                                 = &H84FA???
%GL_DEPTH24_STENCIL8                                  = &H88F0???
%GL_TEXTURE_STENCIL_SIZE                              = &H88F1???
%GL_TEXTURE_RED_TYPE                                  = &H8C10???
%GL_TEXTURE_GREEN_TYPE                                = &H8C11???
%GL_TEXTURE_BLUE_TYPE                                 = &H8C12???
%GL_TEXTURE_ALPHA_TYPE                                = &H8C13???
%GL_TEXTURE_LUMINANCE_TYPE                            = &H8C14???
%GL_UNSIGNED_NORMALIZED                               = &H8C17???
%GL_FRAMEBUFFER_BINDING                               = &H8CA6???
%GL_DRAW_FRAMEBUFFER_BINDING                          = &H8CA6???
%GL_RENDERBUFFER_BINDING                              = &H8CA7???
%GL_READ_FRAMEBUFFER                                  = &H8CA8???
%GL_DRAW_FRAMEBUFFER                                  = &H8CA9???
%GL_READ_FRAMEBUFFER_BINDING                          = &H8CAA???
%GL_RENDERBUFFER_SAMPLES                              = &H8CAB???
%GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                = &H8CD0???
%GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME                = &H8CD1???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL              = &H8CD2???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE      = &H8CD3???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER              = &H8CD4???
%GL_FRAMEBUFFER_COMPLETE                              = &H8CD5???
%GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT                 = &H8CD6???
%GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT         = &H8CD7???
%GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER                = &H8CDB???
%GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER                = &H8CDC???
%GL_FRAMEBUFFER_UNSUPPORTED                           = &H8CDD???
%GL_MAX_COLOR_ATTACHMENTS                             = &H8CDF???
%GL_COLOR_ATTACHMENT0                                 = &H8CE0???
%GL_COLOR_ATTACHMENT1                                 = &H8CE1???
%GL_COLOR_ATTACHMENT2                                 = &H8CE2???
%GL_COLOR_ATTACHMENT3                                 = &H8CE3???
%GL_COLOR_ATTACHMENT4                                 = &H8CE4???
%GL_COLOR_ATTACHMENT5                                 = &H8CE5???
%GL_COLOR_ATTACHMENT6                                 = &H8CE6???
%GL_COLOR_ATTACHMENT7                                 = &H8CE7???
%GL_COLOR_ATTACHMENT8                                 = &H8CE8???
%GL_COLOR_ATTACHMENT9                                 = &H8CE9???
%GL_COLOR_ATTACHMENT10                                = &H8CEA???
%GL_COLOR_ATTACHMENT11                                = &H8CEB???
%GL_COLOR_ATTACHMENT12                                = &H8CEC???
%GL_COLOR_ATTACHMENT13                                = &H8CED???
%GL_COLOR_ATTACHMENT14                                = &H8CEE???
%GL_COLOR_ATTACHMENT15                                = &H8CEF???
%GL_DEPTH_ATTACHMENT                                  = &H8D00???
%GL_STENCIL_ATTACHMENT                                = &H8D20???
%GL_FRAMEBUFFER                                       = &H8D40???
%GL_RENDERBUFFER                                      = &H8D41???
%GL_RENDERBUFFER_WIDTH                                = &H8D42???
%GL_RENDERBUFFER_HEIGHT                               = &H8D43???
%GL_RENDERBUFFER_INTERNAL_FORMAT                      = &H8D44???
%GL_STENCIL_INDEX1                                    = &H8D46???
%GL_STENCIL_INDEX4                                    = &H8D47???
%GL_STENCIL_INDEX8                                    = &H8D48???
%GL_STENCIL_INDEX16                                   = &H8D49???
%GL_RENDERBUFFER_RED_SIZE                             = &H8D50???
%GL_RENDERBUFFER_GREEN_SIZE                           = &H8D51???
%GL_RENDERBUFFER_BLUE_SIZE                            = &H8D52???
%GL_RENDERBUFFER_ALPHA_SIZE                           = &H8D53???
%GL_RENDERBUFFER_DEPTH_SIZE                           = &H8D54???
%GL_RENDERBUFFER_STENCIL_SIZE                         = &H8D55???
%GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE                = &H8D56???
%GL_MAX_SAMPLES                                       = &H8D57???
%GL_INDEX                                             = &H8222???
%GL_TEXTURE_INTENSITY_TYPE                            = &H8C15???
%GL_TEXTURE_DEPTH_TYPE                                = &H8C16???
#ENDIF

#IF NOT %DEF(%GL_ARB_framebuffer_sRGB)
%GL_FRAMEBUFFER_SRGB                                  = &H8DB9???
#ENDIF

#IF NOT %DEF(%GL_ARB_geometry_shader4)
%GL_LINES_ADJACENCY_ARB                               = &H000A???
%GL_LINE_STRIP_ADJACENCY_ARB                          = &H000B???
%GL_TRIANGLES_ADJACENCY_ARB                           = &H000C???
%GL_TRIANGLE_STRIP_ADJACENCY_ARB                      = &H000D???
%GL_PROGRAM_POINT_SIZE_ARB                            = &H8642???
%GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB              = &H8C29???
%GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB                = &H8DA7???
%GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB          = &H8DA8???
%GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB            = &H8DA9???
%GL_GEOMETRY_SHADER_ARB                               = &H8DD9???
%GL_GEOMETRY_VERTICES_OUT_ARB                         = &H8DDA???
%GL_GEOMETRY_INPUT_TYPE_ARB                           = &H8DDB???
%GL_GEOMETRY_OUTPUT_TYPE_ARB                          = &H8DDC???
%GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB               = &H8DDD???
%GL_MAX_VERTEX_VARYING_COMPONENTS_ARB                 = &H8DDE???
%GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB               = &H8DDF???
%GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB                  = &H8DE0???
%GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB          = &H8DE1???
'/* reuse GL_MAX_VARYING_COMPONENTS */
'/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
#ENDIF

#IF NOT %DEF(%GL_ARB_half_float_vertex)
%GL_HALF_FLOAT                                        = &H140B???
#ENDIF

#IF NOT %DEF(%GL_ARB_instanced_arrays)
%GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB                   = &H88FE???
#ENDIF

#IF NOT %DEF(%GL_ARB_map_buffer_range)
%GL_MAP_READ_BIT                                      = &H0001???
%GL_MAP_WRITE_BIT                                     = &H0002???
%GL_MAP_INVALIDATE_RANGE_BIT                          = &H0004???
%GL_MAP_INVALIDATE_BUFFER_BIT                         = &H0008???
%GL_MAP_FLUSH_EXPLICIT_BIT                            = &H0010???
%GL_MAP_UNSYNCHRONIZED_BIT                            = &H0020???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_buffer_object)
%GL_TEXTURE_BUFFER_ARB                                = &H8C2A???
%GL_MAX_TEXTURE_BUFFER_SIZE_ARB                       = &H8C2B???
%GL_TEXTURE_BINDING_BUFFER_ARB                        = &H8C2C???
%GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB             = &H8C2D???
%GL_TEXTURE_BUFFER_FORMAT_ARB                         = &H8C2E???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_compression_rgtc)
%GL_COMPRESSED_RED_RGTC1                              = &H8DBB???
%GL_COMPRESSED_SIGNED_RED_RGTC1                       = &H8DBC???
%GL_COMPRESSED_RG_RGTC2                               = &H8DBD???
%GL_COMPRESSED_SIGNED_RG_RGTC2                        = &H8DBE???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_rg)
%GL_RG                                                = &H8227???
%GL_RG_INTEGER                                        = &H8228???
%GL_R8                                                = &H8229???
%GL_R16                                               = &H822A???
%GL_RG8                                               = &H822B???
%GL_RG16                                              = &H822C???
%GL_R16F                                              = &H822D???
%GL_R32F                                              = &H822E???
%GL_RG16F                                             = &H822F???
%GL_RG32F                                             = &H8230???
%GL_R8I                                               = &H8231???
%GL_R8UI                                              = &H8232???
%GL_R16I                                              = &H8233???
%GL_R16UI                                             = &H8234???
%GL_R32I                                              = &H8235???
%GL_R32UI                                             = &H8236???
%GL_RG8I                                              = &H8237???
%GL_RG8UI                                             = &H8238???
%GL_RG16I                                             = &H8239???
%GL_RG16UI                                            = &H823A???
%GL_RG32I                                             = &H823B???
%GL_RG32UI                                            = &H823C???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_array_object)
%GL_VERTEX_ARRAY_BINDING                              = &H85B5???
#ENDIF

#IF NOT %DEF(%GL_ARB_uniform_buffer_object)
%GL_UNIFORM_BUFFER                                    = &H8A11???
%GL_UNIFORM_BUFFER_BINDING                            = &H8A28???
%GL_UNIFORM_BUFFER_START                              = &H8A29???
%GL_UNIFORM_BUFFER_SIZE                               = &H8A2A???
%GL_MAX_VERTEX_UNIFORM_BLOCKS                         = &H8A2B???
%GL_MAX_GEOMETRY_UNIFORM_BLOCKS                       = &H8A2C???
%GL_MAX_FRAGMENT_UNIFORM_BLOCKS                       = &H8A2D???
%GL_MAX_COMBINED_UNIFORM_BLOCKS                       = &H8A2E???
%GL_MAX_UNIFORM_BUFFER_BINDINGS                       = &H8A2F???
%GL_MAX_UNIFORM_BLOCK_SIZE                            = &H8A30???
%GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS            = &H8A31???
%GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS          = &H8A32???
%GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS          = &H8A33???
%GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT                   = &H8A34???
%GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH              = &H8A35???
%GL_ACTIVE_UNIFORM_BLOCKS                             = &H8A36???
%GL_UNIFORM_TYPE                                      = &H8A37???
%GL_UNIFORM_SIZE                                      = &H8A38???
%GL_UNIFORM_NAME_LENGTH                               = &H8A39???
%GL_UNIFORM_BLOCK_INDEX                               = &H8A3A???
%GL_UNIFORM_OFFSET                                    = &H8A3B???
%GL_UNIFORM_ARRAY_STRIDE                              = &H8A3C???
%GL_UNIFORM_MATRIX_STRIDE                             = &H8A3D???
%GL_UNIFORM_IS_ROW_MAJOR                              = &H8A3E???
%GL_UNIFORM_BLOCK_BINDING                             = &H8A3F???
%GL_UNIFORM_BLOCK_DATA_SIZE                           = &H8A40???
%GL_UNIFORM_BLOCK_NAME_LENGTH                         = &H8A41???
%GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS                     = &H8A42???
%GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES              = &H8A43???
%GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER         = &H8A44???
%GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER       = &H8A45???
%GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER       = &H8A46???
%GL_INVALID_INDEX                                     = &HFFFFFFFF???
#ENDIF

#IF NOT %DEF(%GL_ARB_compatibility)
'/* ARB_compatibility just defines tokens from core 3.0 */
#ENDIF

#IF NOT %DEF(%GL_ARB_copy_buffer)
%GL_COPY_READ_BUFFER_BINDING                          = &H8F36???
%GL_COPY_READ_BUFFER                                  = &H8F36???
%GL_COPY_WRITE_BUFFER_BINDING                         = &H8F37???
%GL_COPY_WRITE_BUFFER                                 = &H8F37???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_texture_lod)
#ENDIF

#IF NOT %DEF(%GL_ARB_depth_clamp)
%GL_DEPTH_CLAMP                                       = &H864F???
#ENDIF

#IF NOT %DEF(%GL_ARB_draw_elements_base_vertex)
#ENDIF

#IF NOT %DEF(%GL_ARB_fragment_coord_conventions)
#ENDIF

#IF NOT %DEF(%GL_ARB_provoking_vertex)
%GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION          = &H8E4C???
%GL_FIRST_VERTEX_CONVENTION                           = &H8E4D???
%GL_LAST_VERTEX_CONVENTION                            = &H8E4E???
%GL_PROVOKING_VERTEX                                  = &H8E4F???
#ENDIF

#IF NOT %DEF(%GL_ARB_seamless_cube_map)
%GL_TEXTURE_CUBE_MAP_SEAMLESS                         = &H884F???
#ENDIF

#IF NOT %DEF(%GL_ARB_sync)
%GL_MAX_SERVER_WAIT_TIMEOUT                           = &H9111???
%GL_OBJECT_TYPE                                       = &H9112???
%GL_SYNC_CONDITION                                    = &H9113???
%GL_SYNC_STATUS                                       = &H9114???
%GL_SYNC_FLAGS                                        = &H9115???
%GL_SYNC_FENCE                                        = &H9116???
%GL_SYNC_GPU_COMMANDS_COMPLETE                        = &H9117???
%GL_UNSIGNALED                                        = &H9118???
%GL_SIGNALED                                          = &H9119???
%GL_ALREADY_SIGNALED                                  = &H911A???
%GL_TIMEOUT_EXPIRED                                   = &H911B???
%GL_CONDITION_SATISFIED                               = &H911C???
%GL_WAIT_FAILED                                       = &H911D???
%GL_SYNC_FLUSH_COMMANDS_BIT                           = &H00000001
%GL_TIMEOUT_IGNORED                                   = &HFFFFFFFFFFFFFFFF&&
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_multisample)
%GL_SAMPLE_POSITION                                   = &H8E50???
%GL_SAMPLE_MASK                                       = &H8E51???
%GL_SAMPLE_MASK_VALUE                                 = &H8E52???
%GL_MAX_SAMPLE_MASK_WORDS                             = &H8E59???
%GL_TEXTURE_2D_MULTISAMPLE                            = &H9100???
%GL_PROXY_TEXTURE_2D_MULTISAMPLE                      = &H9101???
%GL_TEXTURE_2D_MULTISAMPLE_ARRAY                      = &H9102???
%GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY                = &H9103???
%GL_TEXTURE_BINDING_2D_MULTISAMPLE                    = &H9104???
%GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY              = &H9105???
%GL_TEXTURE_SAMPLES                                   = &H9106???
%GL_TEXTURE_FIXED_SAMPLE_LOCATIONS                    = &H9107???
%GL_SAMPLER_2D_MULTISAMPLE                            = &H9108???
%GL_INT_SAMPLER_2D_MULTISAMPLE                        = &H9109???
%GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE               = &H910A???
%GL_SAMPLER_2D_MULTISAMPLE_ARRAY                      = &H910B???
%GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY                  = &H910C???
%GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY         = &H910D???
%GL_MAX_COLOR_TEXTURE_SAMPLES                         = &H910E???
%GL_MAX_DEPTH_TEXTURE_SAMPLES                         = &H910F???
%GL_MAX_INTEGER_SAMPLES                               = &H9110???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_array_bgra)
'/* reuse GL_BGRA */
#ENDIF

#IF NOT %DEF(%GL_ARB_draw_buffers_blend)
#ENDIF

#IF NOT %DEF(%GL_ARB_sample_shading)
%GL_SAMPLE_SHADING_ARB                                = &H8C36???
%GL_MIN_SAMPLE_SHADING_VALUE_ARB                      = &H8C37???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_cube_map_array)
%GL_TEXTURE_CUBE_MAP_ARRAY_ARB                        = &H9009???
%GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB                = &H900A???
%GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB                  = &H900B???
%GL_SAMPLER_CUBE_MAP_ARRAY_ARB                        = &H900C???
%GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB                 = &H900D???
%GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB                    = &H900E???
%GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB           = &H900F???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_gather)
%GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB             = &H8E5E???
%GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB             = &H8E5F???
%GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB         = &H8F9F???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_query_lod)
#ENDIF

#IF NOT %DEF(%GL_ARB_shading_language_include)
%GL_SHADER_INCLUDE_ARB                                = &H8DAE???
%GL_NAMED_STRING_LENGTH_ARB                           = &H8DE9???
%GL_NAMED_STRING_TYPE_ARB                             = &H8DEA???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_compression_bptc)
%GL_COMPRESSED_RGBA_BPTC_UNORM_ARB                    = &H8E8C???
%GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB              = &H8E8D???
%GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB              = &H8E8E???
%GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB            = &H8E8F???
#ENDIF

#IF NOT %DEF(%GL_ARB_blend_func_extended)
%GL_SRC1_COLOR                                        = &H88F9???
'/* reuse GL_SRC1_ALPHA */
%GL_ONE_MINUS_SRC1_COLOR                              = &H88FA???
%GL_ONE_MINUS_SRC1_ALPHA                              = &H88FB???
%GL_MAX_DUAL_SOURCE_DRAW_BUFFERS                      = &H88FC???
#ENDIF

#IF NOT %DEF(%GL_ARB_explicit_attrib_location)
#ENDIF

#IF NOT %DEF(%GL_ARB_occlusion_query2)
%GL_ANY_SAMPLES_PASSED                                = &H8C2F???
#ENDIF

#IF NOT %DEF(%GL_ARB_sampler_objects)
%GL_SAMPLER_BINDING                                   = &H8919???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_bit_encoding)
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_rgb10_a2ui)
%GL_RGB10_A2UI                                        = &H906F???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_swizzle)
%GL_TEXTURE_SWIZZLE_R                                 = &H8E42???
%GL_TEXTURE_SWIZZLE_G                                 = &H8E43???
%GL_TEXTURE_SWIZZLE_B                                 = &H8E44???
%GL_TEXTURE_SWIZZLE_A                                 = &H8E45???
%GL_TEXTURE_SWIZZLE_RGBA                              = &H8E46???
#ENDIF

#IF NOT %DEF(%GL_ARB_timer_query)
%GL_TIME_ELAPSED                                      = &H88BF???
%GL_TIMESTAMP                                         = &H8E28???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_type_2_10_10_10_rev)
'/* reuse GL_UNSIGNED_INT_2_10_10_10_REV */
%GL_INT_2_10_10_10_REV                                = &H8D9F???
#ENDIF

#IF NOT %DEF(%GL_ARB_draw_indirect)
%GL_DRAW_INDIRECT_BUFFER                              = &H8F3F???
%GL_DRAW_INDIRECT_BUFFER_BINDING                      = &H8F43???
#ENDIF

#IF NOT %DEF(%GL_ARB_gpu_shader5)
%GL_GEOMETRY_SHADER_INVOCATIONS                       = &H887F???
%GL_MAX_GEOMETRY_SHADER_INVOCATIONS                   = &H8E5A???
%GL_MIN_FRAGMENT_INTERPOLATION_OFFSET                 = &H8E5B???
%GL_MAX_FRAGMENT_INTERPOLATION_OFFSET                 = &H8E5C???
%GL_FRAGMENT_INTERPOLATION_OFFSET_BITS                = &H8E5D???
'/* reuse GL_MAX_VERTEX_STREAMS */
#ENDIF

#IF NOT %DEF(%GL_ARB_gpu_shader_fp64)
'/* reuse GL_DOUBLE */
%GL_DOUBLE_VEC2                                       = &H8FFC???
%GL_DOUBLE_VEC3                                       = &H8FFD???
%GL_DOUBLE_VEC4                                       = &H8FFE???
%GL_DOUBLE_MAT2                                       = &H8F46???
%GL_DOUBLE_MAT3                                       = &H8F47???
%GL_DOUBLE_MAT4                                       = &H8F48???
%GL_DOUBLE_MAT2x3                                     = &H8F49???
%GL_DOUBLE_MAT2x4                                     = &H8F4A???
%GL_DOUBLE_MAT3x2                                     = &H8F4B???
%GL_DOUBLE_MAT3x4                                     = &H8F4C???
%GL_DOUBLE_MAT4x2                                     = &H8F4D???
%GL_DOUBLE_MAT4x3                                     = &H8F4E???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_subroutine)
%GL_ACTIVE_SUBROUTINES                                = &H8DE5???
%GL_ACTIVE_SUBROUTINE_UNIFORMS                        = &H8DE6???
%GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS               = &H8E47???
%GL_ACTIVE_SUBROUTINE_MAX_LENGTH                      = &H8E48???
%GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH              = &H8E49???
%GL_MAX_SUBROUTINES                                   = &H8DE7???
%GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS                  = &H8DE8???
%GL_NUM_COMPATIBLE_SUBROUTINES                        = &H8E4A???
%GL_COMPATIBLE_SUBROUTINES                            = &H8E4B???
'/* reuse GL_UNIFORM_SIZE */
'/* reuse GL_UNIFORM_NAME_LENGTH */
#ENDIF

#IF NOT %DEF(%GL_ARB_tessellation_shader)
%GL_PATCHES                                           = &H000E???
%GL_PATCH_VERTICES                                    = &H8E72???
%GL_PATCH_DEFAULT_INNER_LEVEL                         = &H8E73???
%GL_PATCH_DEFAULT_OUTER_LEVEL                         = &H8E74???
%GL_TESS_CONTROL_OUTPUT_VERTICES                      = &H8E75???
%GL_TESS_GEN_MODE                                     = &H8E76???
%GL_TESS_GEN_SPACING                                  = &H8E77???
%GL_TESS_GEN_VERTEX_ORDER                             = &H8E78???
%GL_TESS_GEN_POINT_MODE                               = &H8E79???
'/* reuse GL_TRIANGLES */
'/* reuse GL_QUADS */
%GL_ISOLINES                                          = &H8E7A???
'/* reuse GL_EQUAL */
%GL_FRACTIONAL_ODD                                    = &H8E7B???
%GL_FRACTIONAL_EVEN                                   = &H8E7C???
'/* reuse GL_CCW */
'/* reuse GL_CW */
%GL_MAX_PATCH_VERTICES                                = &H8E7D???
%GL_MAX_TESS_GEN_LEVEL                                = &H8E7E???
%GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS               = &H8E7F???
%GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS            = &H8E80???
%GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS              = &H8E81???
%GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS           = &H8E82???
%GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS                = &H8E83???
%GL_MAX_TESS_PATCH_COMPONENTS                         = &H8E84???
%GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS          = &H8E85???
%GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS             = &H8E86???
%GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS                   = &H8E89???
%GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS                = &H8E8A???
%GL_MAX_TESS_CONTROL_INPUT_COMPONENTS                 = &H886C???
%GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS              = &H886D???
%GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS      = &H8E1E???
%GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS   = &H8E1F???
%GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER   = &H84F0???
%GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = &H84F1???
%GL_TESS_EVALUATION_SHADER                            = &H8E87???
%GL_TESS_CONTROL_SHADER                               = &H8E88???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_buffer_object_rgb32)
'/* reuse GL_RGB32F */
'/* reuse GL_RGB32UI */
'/* reuse GL_RGB32I */
#ENDIF

#IF NOT %DEF(%GL_ARB_transform_feedback2)
%GL_TRANSFORM_FEEDBACK                                = &H8E22???
%GL_TRANSFORM_FEEDBACK_PAUSED                         = &H8E23???
%GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED                  = &H8E23???
%GL_TRANSFORM_FEEDBACK_ACTIVE                         = &H8E24???
%GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE                  = &H8E24???
%GL_TRANSFORM_FEEDBACK_BINDING                        = &H8E25???
#ENDIF

#IF NOT %DEF(%GL_ARB_transform_feedback3)
%GL_MAX_TRANSFORM_FEEDBACK_BUFFERS                    = &H8E70???
%GL_MAX_VERTEX_STREAMS                                = &H8E71???
#ENDIF

#IF NOT %DEF(%GL_ARB_ES2_compatibility)
%GL_FIXED                            = &H140C???
%GL_IMPLEMENTATION_COLOR_READ_TYPE   = &H8B9A???
%GL_IMPLEMENTATION_COLOR_READ_FORMAT = &H8B9B???
%GL_LOW_FLOAT                        = &H8DF0???
%GL_MEDIUM_FLOAT                     = &H8DF1???
%GL_HIGH_FLOAT                       = &H8DF2???
%GL_LOW_INT                          = &H8DF3???
%GL_MEDIUM_INT                       = &H8DF4???
%GL_HIGH_INT                         = &H8DF5???
%GL_SHADER_COMPILER                  = &H8DFA???
%GL_SHADER_BINARY_FORMATS            = &H8DF8???
%GL_NUM_SHADER_BINARY_FORMATS        = &H8DF9???
%GL_MAX_VERTEX_UNIFORM_VECTORS       = &H8DFB???
%GL_MAX_VARYING_VECTORS              = &H8DFC???
%GL_MAX_FRAGMENT_UNIFORM_VECTORS     = &H8DFD???
%GL_RGB565                           = &H8D62???
#ENDIF

#IF NOT %DEF(%GL_ARB_get_program_binary)
%GL_PROGRAM_BINARY_RETRIEVABLE_HINT = &H8257???
%GL_PROGRAM_BINARY_LENGTH           = &H8741???
%GL_NUM_PROGRAM_BINARY_FORMATS      = &H87FE???
%GL_PROGRAM_BINARY_FORMATS          = &H87FF???
#ENDIF

#IF NOT %DEF(%GL_ARB_separate_shader_objects)
%GL_VERTEX_SHADER_BIT              = &H00000001???
%GL_FRAGMENT_SHADER_BIT            = &H00000002???
%GL_GEOMETRY_SHADER_BIT            = &H00000004???
%GL_TESS_CONTROL_SHADER_BIT        = &H00000008???
%GL_TESS_EVALUATION_SHADER_BIT     = &H00000010???
%GL_ALL_SHADER_BITS                = &HFFFFFFFF???
%GL_PROGRAM_SEPARABLE              = &H8258???
%GL_ACTIVE_PROGRAM                 = &H8259???
%GL_PROGRAM_PIPELINE_BINDING       = &H825A???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_precision)
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_attrib_64bit)
'/* reuse GL_RGB32I */
'/* reuse GL_DOUBLE_VEC2 */
'/* reuse GL_DOUBLE_VEC3 */
'/* reuse GL_DOUBLE_VEC4 */
'/* reuse GL_DOUBLE_MAT2 */
'/* reuse GL_DOUBLE_MAT3 */
'/* reuse GL_DOUBLE_MAT4 */
'/* reuse GL_DOUBLE_MAT2x3 */
'/* reuse GL_DOUBLE_MAT2x4 */
'/* reuse GL_DOUBLE_MAT3x2 */
'/* reuse GL_DOUBLE_MAT3x4 */
'/* reuse GL_DOUBLE_MAT4x2 */
'/* reuse GL_DOUBLE_MAT4x3 */
#ENDIF

#IF NOT %DEF(%GL_ARB_viewport_array)
'/* reuse GL_SCISSOR_BOX */
'/* reuse GL_VIEWPORT */
'/* reuse GL_DEPTH_RANGE */
'/* reuse GL_SCISSOR_TEST */
%GL_MAX_VIEWPORTS                   = &H825B???
%GL_VIEWPORT_SUBPIXEL_BITS          = &H825C???
%GL_VIEWPORT_BOUNDS_RANGE           = &H825D???
%GL_LAYER_PROVOKING_VERTEX          = &H825E???
%GL_VIEWPORT_INDEX_PROVOKING_VERTEX = &H825F???
%GL_UNDEFINED_VERTEX                = &H8260???
'/* reuse GL_FIRST_VERTEX_CONVENTION */
'/* reuse GL_LAST_VERTEX_CONVENTION */
'/* reuse GL_PROVOKING_VERTEX */
#ENDIF

#IF NOT %DEF(%GL_ARB_cl_event)
%GL_SYNC_CL_EVENT_ARB              = &H8240???
%GL_SYNC_CL_EVENT_COMPLETE_ARB     = &H8241???
#ENDIF

#IF NOT %DEF(%GL_ARB_debug_output)
%GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB         = &H8242???
%GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = &H8243???
%GL_DEBUG_CALLBACK_FUNCTION_ARB          = &H8244???
%GL_DEBUG_CALLBACK_USER_PARAM_ARB        = &H8245???
%GL_DEBUG_SOURCE_API_ARB                 = &H8246???
%GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB       = &H8247???
%GL_DEBUG_SOURCE_SHADER_COMPILER_ARB     = &H8248???
%GL_DEBUG_SOURCE_THIRD_PARTY_ARB         = &H8249???
%GL_DEBUG_SOURCE_APPLICATION_ARB         = &H824A???
%GL_DEBUG_SOURCE_OTHER_ARB               = &H824B???
%GL_DEBUG_TYPE_ERROR_ARB                 = &H824C???
%GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB   = &H824D???
%GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB    = &H824E???
%GL_DEBUG_TYPE_PORTABILITY_ARB           = &H824F???
%GL_DEBUG_TYPE_PERFORMANCE_ARB           = &H8250???
%GL_DEBUG_TYPE_OTHER_ARB                 = &H8251???
%GL_MAX_DEBUG_MESSAGE_LENGTH_ARB         = &H9143???
%GL_MAX_DEBUG_LOGGED_MESSAGES_ARB        = &H9144???
%GL_DEBUG_LOGGED_MESSAGES_ARB            = &H9145???
%GL_DEBUG_SEVERITY_HIGH_ARB              = &H9146???
%GL_DEBUG_SEVERITY_MEDIUM_ARB            = &H9147???
%GL_DEBUG_SEVERITY_LOW_ARB               = &H9148???
#ENDIF

#IF NOT %DEF(%GL_ARB_robustness)
'/* reuse GL_NO_ERROR */
%GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = &H00000004???
%GL_LOSE_CONTEXT_ON_RESET_ARB          = &H8252???
%GL_GUILTY_CONTEXT_RESET_ARB           = &H8253???
%GL_INNOCENT_CONTEXT_RESET_ARB         = &H8254???
%GL_UNKNOWN_CONTEXT_RESET_ARB          = &H8255???
%GL_RESET_NOTIFICATION_STRATEGY_ARB    = &H8256???
%GL_NO_RESET_NOTIFICATION_ARB          = &H8261???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_stencil_export)
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_stencil_export)
#ENDIF

#IF NOT %DEF(%GL_ARB_base_instance)
#ENDIF

#IF NOT %DEF(%GL_ARB_shading_language_420pack)
#ENDIF

#IF NOT %DEF(%GL_ARB_transform_feedback_instanced)
#ENDIF

#IF NOT %DEF(%GL_ARB_compressed_texture_pixel_storage)
%GL_UNPACK_COMPRESSED_BLOCK_WIDTH  = &H9127???
%GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = &H9128???
%GL_UNPACK_COMPRESSED_BLOCK_DEPTH  = &H9129???
%GL_UNPACK_COMPRESSED_BLOCK_SIZE   = &H912A???
%GL_PACK_COMPRESSED_BLOCK_WIDTH    = &H912B???
%GL_PACK_COMPRESSED_BLOCK_HEIGHT   = &H912C???
%GL_PACK_COMPRESSED_BLOCK_DEPTH    = &H912D???
%GL_PACK_COMPRESSED_BLOCK_SIZE     = &H912E???
#ENDIF

#IF NOT %DEF(%GL_ARB_conservative_depth)
#ENDIF

#IF NOT %DEF(%GL_ARB_internalformat_query)
%GL_NUM_SAMPLE_COUNTS              = &H9380???
#ENDIF

#IF NOT %DEF(%GL_ARB_map_buffer_alignment)
%GL_MIN_MAP_BUFFER_ALIGNMENT       = &H90BC???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_atomic_counters)
%GL_ATOMIC_COUNTER_BUFFER                                      = &H92C0???
%GL_ATOMIC_COUNTER_BUFFER_BINDING                              = &H92C1???
%GL_ATOMIC_COUNTER_BUFFER_START                                = &H92C2???
%GL_ATOMIC_COUNTER_BUFFER_SIZE                                 = &H92C3???
%GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE                            = &H92C4???
%GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS               = &H92C5???
%GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES        = &H92C6???
%GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER          = &H92C7???
%GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER    = &H92C8???
%GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = &H92C9???
%GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER        = &H92CA???
%GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER        = &H92CB???
%GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS                          = &H92CC???
%GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS                    = &H92CD???
%GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS                 = &H92CE???
%GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS                        = &H92CF???
%GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS                        = &H92D0???
%GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS                        = &H92D1???
%GL_MAX_VERTEX_ATOMIC_COUNTERS                                 = &H92D2???
%GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS                           = &H92D3???
%GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS                        = &H92D4???
%GL_MAX_GEOMETRY_ATOMIC_COUNTERS                               = &H92D5???
%GL_MAX_FRAGMENT_ATOMIC_COUNTERS                               = &H92D6???
%GL_MAX_COMBINED_ATOMIC_COUNTERS                               = &H92D7???
%GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE                             = &H92D8???
%GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS                         = &H92DC???
%GL_ACTIVE_ATOMIC_COUNTER_BUFFERS                              = &H92D9???
%GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX                        = &H92DA???
%GL_UNSIGNED_INT_ATOMIC_COUNTER                                = &H92DB???
#ENDIF

#IF NOT %DEF(%GL_ARB_shader_image_load_store)
%GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT               = &H00000001???
%GL_ELEMENT_ARRAY_BARRIER_BIT                     = &H00000002???
%GL_UNIFORM_BARRIER_BIT                           = &H00000004???
%GL_TEXTURE_FETCH_BARRIER_BIT                     = &H00000008???
%GL_SHADER_IMAGE_ACCESS_BARRIER_BIT               = &H00000020???
%GL_COMMAND_BARRIER_BIT                           = &H00000040???
%GL_PIXEL_BUFFER_BARRIER_BIT                      = &H00000080???
%GL_TEXTURE_UPDATE_BARRIER_BIT                    = &H00000100???
%GL_BUFFER_UPDATE_BARRIER_BIT                     = &H00000200???
%GL_FRAMEBUFFER_BARRIER_BIT                       = &H00000400???
%GL_TRANSFORM_FEEDBACK_BARRIER_BIT                = &H00000800???
%GL_ATOMIC_COUNTER_BARRIER_BIT                    = &H00001000???
%GL_ALL_BARRIER_BITS                              = &HFFFFFFFF???
%GL_MAX_IMAGE_UNITS                               = &H8F38???
%GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = &H8F39???
%GL_IMAGE_BINDING_NAME                            = &H8F3A???
%GL_IMAGE_BINDING_LEVEL                           = &H8F3B???
%GL_IMAGE_BINDING_LAYERED                         = &H8F3C???
%GL_IMAGE_BINDING_LAYER                           = &H8F3D???
%GL_IMAGE_BINDING_ACCESS                          = &H8F3E???
%GL_IMAGE_1D                                      = &H904C???
%GL_IMAGE_2D                                      = &H904D???
%GL_IMAGE_3D                                      = &H904E???
%GL_IMAGE_2D_RECT                                 = &H904F???
%GL_IMAGE_CUBE                                    = &H9050???
%GL_IMAGE_BUFFER                                  = &H9051???
%GL_IMAGE_1D_ARRAY                                = &H9052???
%GL_IMAGE_2D_ARRAY                                = &H9053???
%GL_IMAGE_CUBE_MAP_ARRAY                          = &H9054???
%GL_IMAGE_2D_MULTISAMPLE                          = &H9055???
%GL_IMAGE_2D_MULTISAMPLE_ARRAY                    = &H9056???
%GL_INT_IMAGE_1D                                  = &H9057???
%GL_INT_IMAGE_2D                                  = &H9058???
%GL_INT_IMAGE_3D                                  = &H9059???
%GL_INT_IMAGE_2D_RECT                             = &H905A???
%GL_INT_IMAGE_CUBE                                = &H905B???
%GL_INT_IMAGE_BUFFER                              = &H905C???
%GL_INT_IMAGE_1D_ARRAY                            = &H905D???
%GL_INT_IMAGE_2D_ARRAY                            = &H905E???
%GL_INT_IMAGE_CUBE_MAP_ARRAY                      = &H905F???
%GL_INT_IMAGE_2D_MULTISAMPLE                      = &H9060???
%GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY                = &H9061???
%GL_UNSIGNED_INT_IMAGE_1D                         = &H9062???
%GL_UNSIGNED_INT_IMAGE_2D                         = &H9063???
%GL_UNSIGNED_INT_IMAGE_3D                         = &H9064???
%GL_UNSIGNED_INT_IMAGE_2D_RECT                    = &H9065???
%GL_UNSIGNED_INT_IMAGE_CUBE                       = &H9066???
%GL_UNSIGNED_INT_IMAGE_BUFFER                     = &H9067???
%GL_UNSIGNED_INT_IMAGE_1D_ARRAY                   = &H9068???
%GL_UNSIGNED_INT_IMAGE_2D_ARRAY                   = &H9069???
%GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY             = &H906A???
%GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE             = &H906B???
%GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY       = &H906C???
%GL_MAX_IMAGE_SAMPLES                             = &H906D???
%GL_IMAGE_BINDING_FORMAT                          = &H906E???
%GL_IMAGE_FORMAT_COMPATIBILITY_TYPE               = &H90C7???
%GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE            = &H90C8???
%GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS           = &H90C9???
%GL_MAX_VERTEX_IMAGE_UNIFORMS                     = &H90CA???
%GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS               = &H90CB???
%GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS            = &H90CC???
%GL_MAX_GEOMETRY_IMAGE_UNIFORMS                   = &H90CD???
%GL_MAX_FRAGMENT_IMAGE_UNIFORMS                   = &H90CE???
%GL_MAX_COMBINED_IMAGE_UNIFORMS                   = &H90CF???
#ENDIF

#IF NOT %DEF(%GL_ARB_shading_language_packing)
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_storage)
%GL_TEXTURE_IMMUTABLE_FORMAT                          = &H912F???
#ENDIF

#IF NOT %DEF(%GL_KHR_texture_compression_astc_ldr)
%GL_COMPRESSED_RGBA_ASTC_4x4_KHR           = &H93B0???
%GL_COMPRESSED_RGBA_ASTC_5x4_KHR           = &H93B1???
%GL_COMPRESSED_RGBA_ASTC_5x5_KHR           = &H93B2???
%GL_COMPRESSED_RGBA_ASTC_6x5_KHR           = &H93B3???
%GL_COMPRESSED_RGBA_ASTC_6x6_KHR           = &H93B4???
%GL_COMPRESSED_RGBA_ASTC_8x5_KHR           = &H93B5???
%GL_COMPRESSED_RGBA_ASTC_8x6_KHR           = &H93B6???
%GL_COMPRESSED_RGBA_ASTC_8x8_KHR           = &H93B7???
%GL_COMPRESSED_RGBA_ASTC_10x5_KHR          = &H93B8???
%GL_COMPRESSED_RGBA_ASTC_10x6_KHR          = &H93B9???
%GL_COMPRESSED_RGBA_ASTC_10x8_KHR          = &H93BA???
%GL_COMPRESSED_RGBA_ASTC_10x10_KHR         = &H93BB???
%GL_COMPRESSED_RGBA_ASTC_12x10_KHR         = &H93BC???
%GL_COMPRESSED_RGBA_ASTC_12x12_KHR         = &H93BD???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR   = &H93D0???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR   = &H93D1???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR   = &H93D2???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR   = &H93D3???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR   = &H93D4???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR   = &H93D5???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR   = &H93D6???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR   = &H93D7???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR  = &H93D8???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR  = &H93D9???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR  = &H93DA???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = &H93DB???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = &H93DC???
%GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = &H93DD???
#ENDIF

#IF NOT %DEF(%GL_KHR_debug)
%GL_DEBUG_OUTPUT_SYNCHRONOUS         = &H8242???
%GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = &H8243???
%GL_DEBUG_CALLBACK_FUNCTION          = &H8244???
%GL_DEBUG_CALLBACK_USER_PARAM        = &H8245???
%GL_DEBUG_SOURCE_API                 = &H8246???
%GL_DEBUG_SOURCE_WINDOW_SYSTEM       = &H8247???
%GL_DEBUG_SOURCE_SHADER_COMPILER     = &H8248???
%GL_DEBUG_SOURCE_THIRD_PARTY         = &H8249???
%GL_DEBUG_SOURCE_APPLICATION         = &H824A???
%GL_DEBUG_SOURCE_OTHER               = &H824B???
%GL_DEBUG_TYPE_ERROR                 = &H824C???
%GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR   = &H824D???
%GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR    = &H824E???
%GL_DEBUG_TYPE_PORTABILITY           = &H824F???
%GL_DEBUG_TYPE_PERFORMANCE           = &H8250???
%GL_DEBUG_TYPE_OTHER                 = &H8251???
%GL_DEBUG_TYPE_MARKER                = &H8268???
%GL_DEBUG_TYPE_PUSH_GROUP            = &H8269???
%GL_DEBUG_TYPE_POP_GROUP             = &H826A???
%GL_DEBUG_SEVERITY_NOTIFICATION      = &H826B???
%GL_MAX_DEBUG_GROUP_STACK_DEPTH      = &H826C???
%GL_DEBUG_GROUP_STACK_DEPTH          = &H826D???
%GL_BUFFER                           = &H82E0???
%GL_SHADER                           = &H82E1???
%GL_PROGRAM                          = &H82E2???
%GL_QUERY                            = &H82E3???
%GL_PROGRAM_PIPELINE                 = &H82E4???
%GL_SAMPLER                          = &H82E6???
%GL_DISPLAY_LIST                     = &H82E7???
'/* DISPLAY_LIST used in compatibility profile only */
%GL_MAX_LABEL_LENGTH                 = &H82E8???
%GL_MAX_DEBUG_MESSAGE_LENGTH         = &H9143???
%GL_MAX_DEBUG_LOGGED_MESSAGES        = &H9144???
%GL_DEBUG_LOGGED_MESSAGES            = &H9145???
%GL_DEBUG_SEVERITY_HIGH              = &H9146???
%GL_DEBUG_SEVERITY_MEDIUM            = &H9147???
%GL_DEBUG_SEVERITY_LOW               = &H9148???
%GL_DEBUG_OUTPUT                     = &H92E0???
%GL_CONTEXT_FLAG_DEBUG_BIT           = &H00000002???
'/* reuse GL_STACK_UNDERFLOW */
'/* reuse GL_STACK_OVERFLOW */
#ENDIF

'#IF NOT %DEF(%GL_ARB_arrays_of_arrays)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_clear_buffer_object)
'#ENDIF

#IF NOT %DEF(%GL_ARB_compute_shader)
%GL_COMPUTE_SHADER                                     = &H91B9???
%GL_MAX_COMPUTE_UNIFORM_BLOCKS                         = &H91BB???
%GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS                    = &H91BC???
%GL_MAX_COMPUTE_IMAGE_UNIFORMS                         = &H91BD???
%GL_MAX_COMPUTE_SHARED_MEMORY_SIZE                     = &H8262???
%GL_MAX_COMPUTE_UNIFORM_COMPONENTS                     = &H8263???
%GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS                 = &H8264???
%GL_MAX_COMPUTE_ATOMIC_COUNTERS                        = &H8265???
%GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS            = &H8266???
%GL_MAX_COMPUTE_LOCAL_INVOCATIONS                      = &H90EB???
%GL_MAX_COMPUTE_WORK_GROUP_COUNT                       = &H91BE???
%GL_MAX_COMPUTE_WORK_GROUP_SIZE                        = &H91BF???
%GL_COMPUTE_LOCAL_WORK_SIZE                            = &H8267???
%GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER         = &H90EC???
%GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = &H90ED???
%GL_DISPATCH_INDIRECT_BUFFER                           = &H90EE???
%GL_DISPATCH_INDIRECT_BUFFER_BINDING                   = &H90EF???
%GL_COMPUTE_SHADER_BIT                                 = &H00000020???
#ENDIF

'#IF NOT %DEF(%GL_ARB_copy_image)
'#ENDIF

#IF NOT %DEF(%GL_ARB_texture_view)
%GL_TEXTURE_VIEW_MIN_LEVEL         = &H82DB???
%GL_TEXTURE_VIEW_NUM_LEVELS        = &H82DC???
%GL_TEXTURE_VIEW_MIN_LAYER         = &H82DD???
%GL_TEXTURE_VIEW_NUM_LAYERS        = &H82DE???
%GL_TEXTURE_IMMUTABLE_LEVELS       = &H82DF???
#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_attrib_binding)
%GL_VERTEX_ATTRIB_BINDING             = &H82D4???
%GL_VERTEX_ATTRIB_RELATIVE_OFFSET     = &H82D5???
%GL_VERTEX_BINDING_DIVISOR            = &H82D6???
%GL_VERTEX_BINDING_OFFSET             = &H82D7???
%GL_VERTEX_BINDING_STRIDE             = &H82D8???
%GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = &H82D9???
%GL_MAX_VERTEX_ATTRIB_BINDINGS        = &H82DA???
#ENDIF

'#IF NOT %DEF(%GL_ARB_robustness_isolation)
'#ENDIF

#IF NOT %DEF(%GL_ARB_ES3_compatibility)
%GL_COMPRESSED_RGB8_ETC2                      = &H9274???
%GL_COMPRESSED_SRGB8_ETC2                     = &H9275???
%GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = &H9276???
%GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = &H9277???
%GL_COMPRESSED_RGBA8_ETC2_EAC                 = &H9278???
%GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC          = &H9279???
%GL_COMPRESSED_R11_EAC                        = &H9270???
%GL_COMPRESSED_SIGNED_R11_EAC                 = &H9271???
%GL_COMPRESSED_RG11_EAC                       = &H9272???
%GL_COMPRESSED_SIGNED_RG11_EAC                = &H9273???
%GL_PRIMITIVE_RESTART_FIXED_INDEX             = &H8D69???
%GL_ANY_SAMPLES_PASSED_CONSERVATIVE           = &H8D6A???
%GL_MAX_ELEMENT_INDEX                         = &H8D6B???
#ENDIF

#IF NOT %DEF(%GL_ARB_explicit_uniform_location)
%GL_MAX_UNIFORM_LOCATIONS          = &H826E???
#ENDIF

'#IF NOT %DEF(%GL_ARB_fragment_layer_viewport)
'#ENDIF

#IF NOT %DEF(%GL_ARB_framebuffer_no_attachments)
%GL_FRAMEBUFFER_DEFAULT_WIDTH                  = &H9310???
%GL_FRAMEBUFFER_DEFAULT_HEIGHT                 = &H9311???
%GL_FRAMEBUFFER_DEFAULT_LAYERS                 = &H9312???
%GL_FRAMEBUFFER_DEFAULT_SAMPLES                = &H9313???
%GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = &H9314???
%GL_MAX_FRAMEBUFFER_WIDTH                      = &H9315???
%GL_MAX_FRAMEBUFFER_HEIGHT                     = &H9316???
%GL_MAX_FRAMEBUFFER_LAYERS                     = &H9317???
%GL_MAX_FRAMEBUFFER_SAMPLES                    = &H9318???
#ENDIF

#IF NOT %DEF(%GL_ARB_internalformat_query2)
'/* reuse GL_IMAGE_FORMAT_COMPATIBILITY_TYPE */
'/* reuse GL_NUM_SAMPLE_COUNTS */
'/* reuse GL_RENDERBUFFER */
'/* reuse GL_SAMPLES */
'/* reuse GL_TEXTURE_1D */
'/* reuse GL_TEXTURE_1D_ARRAY */
'/* reuse GL_TEXTURE_2D */
'/* reuse GL_TEXTURE_2D_ARRAY */
'/* reuse GL_TEXTURE_3D */
'/* reuse GL_TEXTURE_CUBE_MAP */
'/* reuse GL_TEXTURE_CUBE_MAP_ARRAY */
'/* reuse GL_TEXTURE_RECTANGLE */
'/* reuse GL_TEXTURE_BUFFER */
'/* reuse GL_TEXTURE_2D_MULTISAMPLE */
'/* reuse GL_TEXTURE_2D_MULTISAMPLE_ARRAY */
'/* reuse GL_TEXTURE_COMPRESSED */
%GL_INTERNALFORMAT_SUPPORTED               = &H826F???
%GL_INTERNALFORMAT_PREFERRED               = &H8270???
%GL_INTERNALFORMAT_RED_SIZE                = &H8271???
%GL_INTERNALFORMAT_GREEN_SIZE              = &H8272???
%GL_INTERNALFORMAT_BLUE_SIZE               = &H8273???
%GL_INTERNALFORMAT_ALPHA_SIZE              = &H8274???
%GL_INTERNALFORMAT_DEPTH_SIZE              = &H8275???
%GL_INTERNALFORMAT_STENCIL_SIZE            = &H8276???
%GL_INTERNALFORMAT_SHARED_SIZE             = &H8277???
%GL_INTERNALFORMAT_RED_TYPE                = &H8278???
%GL_INTERNALFORMAT_GREEN_TYPE              = &H8279???
%GL_INTERNALFORMAT_BLUE_TYPE               = &H827A???
%GL_INTERNALFORMAT_ALPHA_TYPE              = &H827B???
%GL_INTERNALFORMAT_DEPTH_TYPE              = &H827C???
%GL_INTERNALFORMAT_STENCIL_TYPE            = &H827D???
%GL_MAX_WIDTH                              = &H827E???
%GL_MAX_HEIGHT                             = &H827F???
%GL_MAX_DEPTH                              = &H8280???
%GL_MAX_LAYERS                             = &H8281???
%GL_MAX_COMBINED_DIMENSIONS                = &H8282???
%GL_COLOR_COMPONENTS                       = &H8283???
%GL_DEPTH_COMPONENTS                       = &H8284???
%GL_STENCIL_COMPONENTS                     = &H8285???
%GL_COLOR_RENDERABLE                       = &H8286???
%GL_DEPTH_RENDERABLE                       = &H8287???
%GL_STENCIL_RENDERABLE                     = &H8288???
%GL_FRAMEBUFFER_RENDERABLE                 = &H8289???
%GL_FRAMEBUFFER_RENDERABLE_LAYERED         = &H828A???
%GL_FRAMEBUFFER_BLEND                      = &H828B???
%GL_READ_PIXELS                            = &H828C???
%GL_READ_PIXELS_FORMAT                     = &H828D???
%GL_READ_PIXELS_TYPE                       = &H828E???
%GL_TEXTURE_IMAGE_FORMAT                   = &H828F???
%GL_TEXTURE_IMAGE_TYPE                     = &H8290???
%GL_GET_TEXTURE_IMAGE_FORMAT               = &H8291???
%GL_GET_TEXTURE_IMAGE_TYPE                 = &H8292???
%GL_MIPMAP                                 = &H8293???
%GL_MANUAL_GENERATE_MIPMAP                 = &H8294???
%GL_AUTO_GENERATE_MIPMAP                   = &H8295???
%GL_COLOR_ENCODING                         = &H8296???
%GL_SRGB_READ                              = &H8297???
%GL_SRGB_WRITE                             = &H8298???
%GL_SRGB_DECODE_ARB                        = &H8299???
%GL_FILTER                                 = &H829A???
%GL_VERTEX_TEXTURE                         = &H829B???
%GL_TESS_CONTROL_TEXTURE                   = &H829C???
%GL_TESS_EVALUATION_TEXTURE                = &H829D???
%GL_GEOMETRY_TEXTURE                       = &H829E???
%GL_FRAGMENT_TEXTURE                       = &H829F???
%GL_COMPUTE_TEXTURE                        = &H82A0???
%GL_TEXTURE_SHADOW                         = &H82A1???
%GL_TEXTURE_GATHER                         = &H82A2???
%GL_TEXTURE_GATHER_SHADOW                  = &H82A3???
%GL_SHADER_IMAGE_LOAD                      = &H82A4???
%GL_SHADER_IMAGE_STORE                     = &H82A5???
%GL_SHADER_IMAGE_ATOMIC                    = &H82A6???
%GL_IMAGE_TEXEL_SIZE                       = &H82A7???
%GL_IMAGE_COMPATIBILITY_CLASS              = &H82A8???
%GL_IMAGE_PIXEL_FORMAT                     = &H82A9???
%GL_IMAGE_PIXEL_TYPE                       = &H82AA???
%GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST    = &H82AC???
%GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST  = &H82AD???
%GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE   = &H82AE???
%GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = &H82AF???
%GL_TEXTURE_COMPRESSED_BLOCK_WIDTH         = &H82B1???
%GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT        = &H82B2???
%GL_TEXTURE_COMPRESSED_BLOCK_SIZE          = &H82B3???
%GL_CLEAR_BUFFER                           = &H82B4???
%GL_TEXTURE_VIEW                           = &H82B5???
%GL_VIEW_COMPATIBILITY_CLASS               = &H82B6???
%GL_FULL_SUPPORT                           = &H82B7???
%GL_CAVEAT_SUPPORT                         = &H82B8???
%GL_IMAGE_CLASS_4_X_32                     = &H82B9???
%GL_IMAGE_CLASS_2_X_32                     = &H82BA???
%GL_IMAGE_CLASS_1_X_32                     = &H82BB???
%GL_IMAGE_CLASS_4_X_16                     = &H82BC???
%GL_IMAGE_CLASS_2_X_16                     = &H82BD???
%GL_IMAGE_CLASS_1_X_16                     = &H82BE???
%GL_IMAGE_CLASS_4_X_8                      = &H82BF???
%GL_IMAGE_CLASS_2_X_8                      = &H82C0???
%GL_IMAGE_CLASS_1_X_8                      = &H82C1???
%GL_IMAGE_CLASS_11_11_10                   = &H82C2???
%GL_IMAGE_CLASS_10_10_10_2                 = &H82C3???
%GL_VIEW_CLASS_128_BITS                    = &H82C4???
%GL_VIEW_CLASS_96_BITS                     = &H82C5???
%GL_VIEW_CLASS_64_BITS                     = &H82C6???
%GL_VIEW_CLASS_48_BITS                     = &H82C7???
%GL_VIEW_CLASS_32_BITS                     = &H82C8???
%GL_VIEW_CLASS_24_BITS                     = &H82C9???
%GL_VIEW_CLASS_16_BITS                     = &H82CA???
%GL_VIEW_CLASS_8_BITS                      = &H82CB???
%GL_VIEW_CLASS_S3TC_DXT1_RGB               = &H82CC???
%GL_VIEW_CLASS_S3TC_DXT1_RGBA              = &H82CD???
%GL_VIEW_CLASS_S3TC_DXT3_RGBA              = &H82CE???
%GL_VIEW_CLASS_S3TC_DXT5_RGBA              = &H82CF???
%GL_VIEW_CLASS_RGTC1_RED                   = &H82D0???
%GL_VIEW_CLASS_RGTC2_RG                    = &H82D1???
%GL_VIEW_CLASS_BPTC_UNORM                  = &H82D2???
%GL_VIEW_CLASS_BPTC_FLOAT                  = &H82D3???
#ENDIF

'#IF NOT %DEF(%GL_ARB_invalidate_subdata)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_multi_draw_indirect)
'#ENDIF

#IF NOT %DEF(%GL_ARB_program_interface_query)
%GL_UNIFORM                              = &H92E1???
%GL_UNIFORM_BLOCK                        = &H92E2???
%GL_PROGRAM_INPUT                        = &H92E3???
%GL_PROGRAM_OUTPUT                       = &H92E4???
%GL_BUFFER_VARIABLE                      = &H92E5???
%GL_SHADER_STORAGE_BLOCK                 = &H92E6???
'/* reuse GL_ATOMIC_COUNTER_BUFFER */
%GL_VERTEX_SUBROUTINE                    = &H92E8???
%GL_TESS_CONTROL_SUBROUTINE              = &H92E9???
%GL_TESS_EVALUATION_SUBROUTINE           = &H92EA???
%GL_GEOMETRY_SUBROUTINE                  = &H92EB???
%GL_FRAGMENT_SUBROUTINE                  = &H92EC???
%GL_COMPUTE_SUBROUTINE                   = &H92ED???
%GL_VERTEX_SUBROUTINE_UNIFORM            = &H92EE???
%GL_TESS_CONTROL_SUBROUTINE_UNIFORM      = &H92EF???
%GL_TESS_EVALUATION_SUBROUTINE_UNIFORM   = &H92F0???
%GL_GEOMETRY_SUBROUTINE_UNIFORM          = &H92F1???
%GL_FRAGMENT_SUBROUTINE_UNIFORM          = &H92F2???
%GL_COMPUTE_SUBROUTINE_UNIFORM           = &H92F3???
%GL_TRANSFORM_FEEDBACK_VARYING           = &H92F4???
%GL_ACTIVE_RESOURCES                     = &H92F5???
%GL_MAX_NAME_LENGTH                      = &H92F6???
%GL_MAX_NUM_ACTIVE_VARIABLES             = &H92F7???
%GL_MAX_NUM_COMPATIBLE_SUBROUTINES       = &H92F8???
%GL_NAME_LENGTH                          = &H92F9???
%GL_TYPE                                 = &H92FA???
%GL_ARRAY_SIZE                           = &H92FB???
%GL_OFFSET                               = &H92FC???
%GL_BLOCK_INDEX                          = &H92FD???
%GL_ARRAY_STRIDE                         = &H92FE???
%GL_MATRIX_STRIDE                        = &H92FF???
%GL_IS_ROW_MAJOR                         = &H9300???
%GL_ATOMIC_COUNTER_BUFFER_INDEX          = &H9301???
%GL_BUFFER_BINDING                       = &H9302???
%GL_BUFFER_DATA_SIZE                     = &H9303???
%GL_NUM_ACTIVE_VARIABLES                 = &H9304???
%GL_ACTIVE_VARIABLES                     = &H9305???
%GL_REFERENCED_BY_VERTEX_SHADER          = &H9306???
%GL_REFERENCED_BY_TESS_CONTROL_SHADER    = &H9307???
%GL_REFERENCED_BY_TESS_EVALUATION_SHADER = &H9308???
%GL_REFERENCED_BY_GEOMETRY_SHADER        = &H9309???
%GL_REFERENCED_BY_FRAGMENT_SHADER        = &H930A???
%GL_REFERENCED_BY_COMPUTE_SHADER         = &H930B???
%GL_TOP_LEVEL_ARRAY_SIZE                 = &H930C???
%GL_TOP_LEVEL_ARRAY_STRIDE               = &H930D???
%GL_LOCATION                             = &H930E???
%GL_LOCATION_INDEX                       = &H930F???
%GL_IS_PER_PATCH                         = &H92E7???
'/* reuse GL_NUM_COMPATIBLE_SUBROUTINES */
'/* reuse GL_COMPATIBLE_SUBROUTINES */
#ENDIF

'#IF NOT %DEF(%GL_ARB_robust_buffer_access_behavior)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_image_size)
'#ENDIF

#IF NOT %DEF(%GL_ARB_shader_storage_buffer_object)
%GL_SHADER_STORAGE_BUFFER                     = &H90D2???
%GL_SHADER_STORAGE_BUFFER_BINDING             = &H90D3???
%GL_SHADER_STORAGE_BUFFER_START               = &H90D4???
%GL_SHADER_STORAGE_BUFFER_SIZE                = &H90D5???
%GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS          = &H90D6???
%GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS        = &H90D7???
%GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS    = &H90D8???
%GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = &H90D9???
%GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS        = &H90DA???
%GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS         = &H90DB???
%GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS        = &H90DC???
%GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS        = &H90DD???
%GL_MAX_SHADER_STORAGE_BLOCK_SIZE             = &H90DE???
%GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT    = &H90DF???
%GL_SHADER_STORAGE_BARRIER_BIT                = &H00002000???
%GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES      = &H8F39???
'/* reuse GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS */
#ENDIF

#IF NOT %DEF(%GL_ARB_stencil_texturing)
%GL_DEPTH_STENCIL_TEXTURE_MODE      = &H90EA???
#ENDIF

#IF NOT %DEF(%GL_ARB_texture_buffer_range)
%GL_TEXTURE_BUFFER_OFFSET           = &H919D???
%GL_TEXTURE_BUFFER_SIZE             = &H919E???
%GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = &H919F???
#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_query_levels)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_storage_multisample)
'#ENDIF

#IF NOT %DEF(%GL_EXT_abgr)
%GL_ABGR_EXT                                          = &H8000???
#ENDIF

#IF NOT %DEF(%GL_EXT_blend_color)
%GL_CONSTANT_COLOR_EXT                                = &H8001???
%GL_ONE_MINUS_CONSTANT_COLOR_EXT                      = &H8002???
%GL_CONSTANT_ALPHA_EXT                                = &H8003???
%GL_ONE_MINUS_CONSTANT_ALPHA_EXT                      = &H8004???
%GL_BLEND_COLOR_EXT                                   = &H8005???
#ENDIF

#IF NOT %DEF(%GL_EXT_polygon_offset)
%GL_POLYGON_OFFSET_EXT                                = &H8037???
%GL_POLYGON_OFFSET_FACTOR_EXT                         = &H8038???
%GL_POLYGON_OFFSET_BIAS_EXT                           = &H8039???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture)
%GL_ALPHA4_EXT                                        = &H803B???
%GL_ALPHA8_EXT                                        = &H803C???
%GL_ALPHA12_EXT                                       = &H803D???
%GL_ALPHA16_EXT                                       = &H803E???
%GL_LUMINANCE4_EXT                                    = &H803F???
%GL_LUMINANCE8_EXT                                    = &H8040???
%GL_LUMINANCE12_EXT                                   = &H8041???
%GL_LUMINANCE16_EXT                                   = &H8042???
%GL_LUMINANCE4_ALPHA4_EXT                             = &H8043???
%GL_LUMINANCE6_ALPHA2_EXT                             = &H8044???
%GL_LUMINANCE8_ALPHA8_EXT                             = &H8045???
%GL_LUMINANCE12_ALPHA4_EXT                            = &H8046???
%GL_LUMINANCE12_ALPHA12_EXT                           = &H8047???
%GL_LUMINANCE16_ALPHA16_EXT                           = &H8048???
%GL_INTENSITY_EXT                                     = &H8049???
%GL_INTENSITY4_EXT                                    = &H804A???
%GL_INTENSITY8_EXT                                    = &H804B???
%GL_INTENSITY12_EXT                                   = &H804C???
%GL_INTENSITY16_EXT                                   = &H804D???
%GL_RGB2_EXT                                          = &H804E???
%GL_RGB4_EXT                                          = &H804F???
%GL_RGB5_EXT                                          = &H8050???
%GL_RGB8_EXT                                          = &H8051???
%GL_RGB10_EXT                                         = &H8052???
%GL_RGB12_EXT                                         = &H8053???
%GL_RGB16_EXT                                         = &H8054???
%GL_RGBA2_EXT                                         = &H8055???
%GL_RGBA4_EXT                                         = &H8056???
%GL_RGB5_A1_EXT                                       = &H8057???
%GL_RGBA8_EXT                                         = &H8058???
%GL_RGB10_A2_EXT                                      = &H8059???
%GL_RGBA12_EXT                                        = &H805A???
%GL_RGBA16_EXT                                        = &H805B???
%GL_TEXTURE_RED_SIZE_EXT                              = &H805C???
%GL_TEXTURE_GREEN_SIZE_EXT                            = &H805D???
%GL_TEXTURE_BLUE_SIZE_EXT                             = &H805E???
%GL_TEXTURE_ALPHA_SIZE_EXT                            = &H805F???
%GL_TEXTURE_LUMINANCE_SIZE_EXT                        = &H8060???
%GL_TEXTURE_INTENSITY_SIZE_EXT                        = &H8061???
%GL_REPLACE_EXT                                       = &H8062???
%GL_PROXY_TEXTURE_1D_EXT                              = &H8063???
%GL_PROXY_TEXTURE_2D_EXT                              = &H8064???
%GL_TEXTURE_TOO_LARGE_EXT                             = &H8065???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture3D)
%GL_PACK_SKIP_IMAGES_EXT                              = &H806B???
%GL_PACK_IMAGE_HEIGHT_EXT                             = &H806C???
%GL_UNPACK_SKIP_IMAGES_EXT                            = &H806D???
%GL_UNPACK_IMAGE_HEIGHT_EXT                           = &H806E???
%GL_TEXTURE_3D_EXT                                    = &H806F???
%GL_PROXY_TEXTURE_3D_EXT                              = &H8070???
%GL_TEXTURE_DEPTH_EXT                                 = &H8071???
%GL_TEXTURE_WRAP_R_EXT                                = &H8072???
%GL_MAX_3D_TEXTURE_SIZE_EXT                           = &H8073???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture_filter4)
%GL_FILTER4_SGIS                                      = &H8146???
%GL_TEXTURE_FILTER4_SIZE_SGIS                         = &H8147???
#ENDIF

'#IF NOT %DEF(%GL_EXT_subtexture)
'#ENDIF

'#IF NOT %DEF(%GL_EXT_copy_texture)
'#ENDIF

#IF NOT %DEF(%GL_EXT_histogram)
%GL_HISTOGRAM_EXT                                     = &H8024???
%GL_PROXY_HISTOGRAM_EXT                               = &H8025???
%GL_HISTOGRAM_WIDTH_EXT                               = &H8026???
%GL_HISTOGRAM_FORMAT_EXT                              = &H8027???
%GL_HISTOGRAM_RED_SIZE_EXT                            = &H8028???
%GL_HISTOGRAM_GREEN_SIZE_EXT                          = &H8029???
%GL_HISTOGRAM_BLUE_SIZE_EXT                           = &H802A???
%GL_HISTOGRAM_ALPHA_SIZE_EXT                          = &H802B???
%GL_HISTOGRAM_LUMINANCE_SIZE_EXT                      = &H802C???
%GL_HISTOGRAM_SINK_EXT                                = &H802D???
%GL_MINMAX_EXT                                        = &H802E???
%GL_MINMAX_FORMAT_EXT                                 = &H802F???
%GL_MINMAX_SINK_EXT                                   = &H8030???
%GL_TABLE_TOO_LARGE_EXT                               = &H8031???
#ENDIF

#IF NOT %DEF(%GL_EXT_convolution)
%GL_CONVOLUTION_1D_EXT                                = &H8010???
%GL_CONVOLUTION_2D_EXT                                = &H8011???
%GL_SEPARABLE_2D_EXT                                  = &H8012???
%GL_CONVOLUTION_BORDER_MODE_EXT                       = &H8013???
%GL_CONVOLUTION_FILTER_SCALE_EXT                      = &H8014???
%GL_CONVOLUTION_FILTER_BIAS_EXT                       = &H8015???
%GL_REDUCE_EXT                                        = &H8016???
%GL_CONVOLUTION_FORMAT_EXT                            = &H8017???
%GL_CONVOLUTION_WIDTH_EXT                             = &H8018???
%GL_CONVOLUTION_HEIGHT_EXT                            = &H8019???
%GL_MAX_CONVOLUTION_WIDTH_EXT                         = &H801A???
%GL_MAX_CONVOLUTION_HEIGHT_EXT                        = &H801B???
%GL_POST_CONVOLUTION_RED_SCALE_EXT                    = &H801C???
%GL_POST_CONVOLUTION_GREEN_SCALE_EXT                  = &H801D???
%GL_POST_CONVOLUTION_BLUE_SCALE_EXT                   = &H801E???
%GL_POST_CONVOLUTION_ALPHA_SCALE_EXT                  = &H801F???
%GL_POST_CONVOLUTION_RED_BIAS_EXT                     = &H8020???
%GL_POST_CONVOLUTION_GREEN_BIAS_EXT                   = &H8021???
%GL_POST_CONVOLUTION_BLUE_BIAS_EXT                    = &H8022???
%GL_POST_CONVOLUTION_ALPHA_BIAS_EXT                   = &H8023???
#ENDIF

#IF NOT %DEF(%GL_SGI_color_matrix)
%GL_COLOR_MATRIX_SGI                                  = &H80B1???
%GL_COLOR_MATRIX_STACK_DEPTH_SGI                      = &H80B2???
%GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI                  = &H80B3???
%GL_POST_COLOR_MATRIX_RED_SCALE_SGI                   = &H80B4???
%GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI                 = &H80B5???
%GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI                  = &H80B6???
%GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI                 = &H80B7???
%GL_POST_COLOR_MATRIX_RED_BIAS_SGI                    = &H80B8???
%GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI                  = &H80B9???
%GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI                   = &H80BA???
%GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI                  = &H80BB???
#ENDIF

#IF NOT %DEF(%GL_SGI_color_table)
%GL_COLOR_TABLE_SGI                                   = &H80D0???
%GL_POST_CONVOLUTION_COLOR_TABLE_SGI                  = &H80D1???
%GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI                 = &H80D2???
%GL_PROXY_COLOR_TABLE_SGI                             = &H80D3???
%GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI            = &H80D4???
%GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI           = &H80D5???
%GL_COLOR_TABLE_SCALE_SGI                             = &H80D6???
%GL_COLOR_TABLE_BIAS_SGI                              = &H80D7???
%GL_COLOR_TABLE_FORMAT_SGI                            = &H80D8???
%GL_COLOR_TABLE_WIDTH_SGI                             = &H80D9???
%GL_COLOR_TABLE_RED_SIZE_SGI                          = &H80DA???
%GL_COLOR_TABLE_GREEN_SIZE_SGI                        = &H80DB???
%GL_COLOR_TABLE_BLUE_SIZE_SGI                         = &H80DC???
%GL_COLOR_TABLE_ALPHA_SIZE_SGI                        = &H80DD???
%GL_COLOR_TABLE_LUMINANCE_SIZE_SGI                    = &H80DE???
%GL_COLOR_TABLE_INTENSITY_SIZE_SGI                    = &H80DF???
#ENDIF

#IF NOT %DEF(%GL_SGIS_pixel_texture)
%GL_PIXEL_TEXTURE_SGIS                                = &H8353???
%GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS                    = &H8354???
%GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS                  = &H8355???
%GL_PIXEL_GROUP_COLOR_SGIS                            = &H8356???
#ENDIF

#IF NOT %DEF(%GL_SGIX_pixel_texture)
%GL_PIXEL_TEX_GEN_SGIX                                = &H8139???
%GL_PIXEL_TEX_GEN_MODE_SGIX                           = &H832B???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture4D)
%GL_PACK_SKIP_VOLUMES_SGIS                            = &H8130???
%GL_PACK_IMAGE_DEPTH_SGIS                             = &H8131???
%GL_UNPACK_SKIP_VOLUMES_SGIS                          = &H8132???
%GL_UNPACK_IMAGE_DEPTH_SGIS                           = &H8133???
%GL_TEXTURE_4D_SGIS                                   = &H8134???
%GL_PROXY_TEXTURE_4D_SGIS                             = &H8135???
%GL_TEXTURE_4DSIZE_SGIS                               = &H8136???
%GL_TEXTURE_WRAP_Q_SGIS                               = &H8137???
%GL_MAX_4D_TEXTURE_SIZE_SGIS                          = &H8138???
%GL_TEXTURE_4D_BINDING_SGIS                           = &H814F???
#ENDIF

#IF NOT %DEF(%GL_SGI_texture_color_table)
%GL_TEXTURE_COLOR_TABLE_SGI                           = &H80BC???
%GL_PROXY_TEXTURE_COLOR_TABLE_SGI                     = &H80BD???
#ENDIF

#IF NOT %DEF(%GL_EXT_cmyka)
%GL_CMYK_EXT                                          = &H800C???
%GL_CMYKA_EXT                                         = &H800D???
%GL_PACK_CMYK_HINT_EXT                                = &H800E???
%GL_UNPACK_CMYK_HINT_EXT                              = &H800F???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_object)
%GL_TEXTURE_PRIORITY_EXT                              = &H8066???
%GL_TEXTURE_RESIDENT_EXT                              = &H8067???
%GL_TEXTURE_1D_BINDING_EXT                            = &H8068???
%GL_TEXTURE_2D_BINDING_EXT                            = &H8069???
%GL_TEXTURE_3D_BINDING_EXT                            = &H806A???
#ENDIF

#IF NOT %DEF(%GL_SGIS_detail_texture)
%GL_DETAIL_TEXTURE_2D_SGIS                            = &H8095???
%GL_DETAIL_TEXTURE_2D_BINDING_SGIS                    = &H8096???
%GL_LINEAR_DETAIL_SGIS                                = &H8097???
%GL_LINEAR_DETAIL_ALPHA_SGIS                          = &H8098???
%GL_LINEAR_DETAIL_COLOR_SGIS                          = &H8099???
%GL_DETAIL_TEXTURE_LEVEL_SGIS                         = &H809A???
%GL_DETAIL_TEXTURE_MODE_SGIS                          = &H809B???
%GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS                   = &H809C???
#ENDIF

#IF NOT %DEF(%GL_SGIS_sharpen_texture)
%GL_LINEAR_SHARPEN_SGIS                               = &H80AD???
%GL_LINEAR_SHARPEN_ALPHA_SGIS                         = &H80AE???
%GL_LINEAR_SHARPEN_COLOR_SGIS                         = &H80AF???
%GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS                  = &H80B0???
#ENDIF

#IF NOT %DEF(%GL_EXT_packed_pixels)
%GL_UNSIGNED_BYTE_3_3_2_EXT                           = &H8032???
%GL_UNSIGNED_SHORT_4_4_4_4_EXT                        = &H8033???
%GL_UNSIGNED_SHORT_5_5_5_1_EXT                        = &H8034???
%GL_UNSIGNED_INT_8_8_8_8_EXT                          = &H8035???
%GL_UNSIGNED_INT_10_10_10_2_EXT                       = &H8036???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture_lod)
%GL_TEXTURE_MIN_LOD_SGIS                              = &H813A???
%GL_TEXTURE_MAX_LOD_SGIS                              = &H813B???
%GL_TEXTURE_BASE_LEVEL_SGIS                           = &H813C???
%GL_TEXTURE_MAX_LEVEL_SGIS                            = &H813D???
#ENDIF

#IF NOT %DEF(%GL_SGIS_multisample)
%GL_MULTISAMPLE_SGIS                                  = &H809D???
%GL_SAMPLE_ALPHA_TO_MASK_SGIS                         = &H809E???
%GL_SAMPLE_ALPHA_TO_ONE_SGIS                          = &H809F???
%GL_SAMPLE_MASK_SGIS                                  = &H80A0???
%GL_1PASS_SGIS                                        = &H80A1???
%GL_2PASS_0_SGIS                                      = &H80A2???
%GL_2PASS_1_SGIS                                      = &H80A3???
%GL_4PASS_0_SGIS                                      = &H80A4???
%GL_4PASS_1_SGIS                                      = &H80A5???
%GL_4PASS_2_SGIS                                      = &H80A6???
%GL_4PASS_3_SGIS                                      = &H80A7???
%GL_SAMPLE_BUFFERS_SGIS                               = &H80A8???
%GL_SAMPLES_SGIS                                      = &H80A9???
%GL_SAMPLE_MASK_VALUE_SGIS                            = &H80AA???
%GL_SAMPLE_MASK_INVERT_SGIS                           = &H80AB???
%GL_SAMPLE_PATTERN_SGIS                               = &H80AC???
#ENDIF

#IF NOT %DEF(%GL_EXT_rescale_normal)
%GL_RESCALE_NORMAL_EXT                                = &H803A???
#ENDIF

#IF NOT %DEF(%GL_EXT_vertex_array)
%GL_VERTEX_ARRAY_EXT                                  = &H8074???
%GL_NORMAL_ARRAY_EXT                                  = &H8075???
%GL_COLOR_ARRAY_EXT                                   = &H8076???
%GL_INDEX_ARRAY_EXT                                   = &H8077???
%GL_TEXTURE_COORD_ARRAY_EXT                           = &H8078???
%GL_EDGE_FLAG_ARRAY_EXT                               = &H8079???
%GL_VERTEX_ARRAY_SIZE_EXT                             = &H807A???
%GL_VERTEX_ARRAY_TYPE_EXT                             = &H807B???
%GL_VERTEX_ARRAY_STRIDE_EXT                           = &H807C???
%GL_VERTEX_ARRAY_COUNT_EXT                            = &H807D???
%GL_NORMAL_ARRAY_TYPE_EXT                             = &H807E???
%GL_NORMAL_ARRAY_STRIDE_EXT                           = &H807F???
%GL_NORMAL_ARRAY_COUNT_EXT                            = &H8080???
%GL_COLOR_ARRAY_SIZE_EXT                              = &H8081???
%GL_COLOR_ARRAY_TYPE_EXT                              = &H8082???
%GL_COLOR_ARRAY_STRIDE_EXT                            = &H8083???
%GL_COLOR_ARRAY_COUNT_EXT                             = &H8084???
%GL_INDEX_ARRAY_TYPE_EXT                              = &H8085???
%GL_INDEX_ARRAY_STRIDE_EXT                            = &H8086???
%GL_INDEX_ARRAY_COUNT_EXT                             = &H8087???
%GL_TEXTURE_COORD_ARRAY_SIZE_EXT                      = &H8088???
%GL_TEXTURE_COORD_ARRAY_TYPE_EXT                      = &H8089???
%GL_TEXTURE_COORD_ARRAY_STRIDE_EXT                    = &H808A???
%GL_TEXTURE_COORD_ARRAY_COUNT_EXT                     = &H808B???
%GL_EDGE_FLAG_ARRAY_STRIDE_EXT                        = &H808C???
%GL_EDGE_FLAG_ARRAY_COUNT_EXT                         = &H808D???
%GL_VERTEX_ARRAY_POINTER_EXT                          = &H808E???
%GL_NORMAL_ARRAY_POINTER_EXT                          = &H808F???
%GL_COLOR_ARRAY_POINTER_EXT                           = &H8090???
%GL_INDEX_ARRAY_POINTER_EXT                           = &H8091???
%GL_TEXTURE_COORD_ARRAY_POINTER_EXT                   = &H8092???
%GL_EDGE_FLAG_ARRAY_POINTER_EXT                       = &H8093???
#ENDIF

'#IF NOT %DEF(%GL_EXT_misc_attribute)
'#ENDIF

#IF NOT %DEF(%GL_SGIS_generate_mipmap)
%GL_GENERATE_MIPMAP_SGIS                              = &H8191???
%GL_GENERATE_MIPMAP_HINT_SGIS                         = &H8192???
#ENDIF

#IF NOT %DEF(%GL_SGIX_clipmap)
%GL_LINEAR_CLIPMAP_LINEAR_SGIX                        = &H8170???
%GL_TEXTURE_CLIPMAP_CENTER_SGIX                       = &H8171???
%GL_TEXTURE_CLIPMAP_FRAME_SGIX                        = &H8172???
%GL_TEXTURE_CLIPMAP_OFFSET_SGIX                       = &H8173???
%GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX                = &H8174???
%GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX                   = &H8175???
%GL_TEXTURE_CLIPMAP_DEPTH_SGIX                        = &H8176???
%GL_MAX_CLIPMAP_DEPTH_SGIX                            = &H8177???
%GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX                    = &H8178???
%GL_NEAREST_CLIPMAP_NEAREST_SGIX                      = &H844D???
%GL_NEAREST_CLIPMAP_LINEAR_SGIX                       = &H844E???
%GL_LINEAR_CLIPMAP_NEAREST_SGIX                       = &H844F???
#ENDIF

#IF NOT %DEF(%GL_SGIX_shadow)
%GL_TEXTURE_COMPARE_SGIX                              = &H819A???
%GL_TEXTURE_COMPARE_OPERATOR_SGIX                     = &H819B???
%GL_TEXTURE_LEQUAL_R_SGIX                             = &H819C???
%GL_TEXTURE_GEQUAL_R_SGIX                             = &H819D???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture_edge_clamp)
%GL_CLAMP_TO_EDGE_SGIS                                = &H812F???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture_border_clamp)
%GL_CLAMP_TO_BORDER_SGIS                              = &H812D???
#ENDIF

#IF NOT %DEF(%GL_EXT_blend_minmax)
%GL_FUNC_ADD_EXT                                      = &H8006???
%GL_MIN_EXT                                           = &H8007???
%GL_MAX_EXT                                           = &H8008???
%GL_BLEND_EQUATION_EXT                                = &H8009???
#ENDIF

#IF NOT %DEF(%GL_EXT_blend_subtract)
%GL_FUNC_SUBTRACT_EXT                                 = &H800A???
%GL_FUNC_REVERSE_SUBTRACT_EXT                         = &H800B???
#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_logic_op)
'#ENDIF

#IF NOT %DEF(%GL_SGIX_interlace)
%GL_INTERLACE_SGIX                                    = &H8094???
#ENDIF

#IF NOT %DEF(%GL_SGIX_pixel_tiles)
%GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX                    = &H813E???
%GL_PIXEL_TILE_CACHE_INCREMENT_SGIX                   = &H813F???
%GL_PIXEL_TILE_WIDTH_SGIX                             = &H8140???
%GL_PIXEL_TILE_HEIGHT_SGIX                            = &H8141???
%GL_PIXEL_TILE_GRID_WIDTH_SGIX                        = &H8142???
%GL_PIXEL_TILE_GRID_HEIGHT_SGIX                       = &H8143???
%GL_PIXEL_TILE_GRID_DEPTH_SGIX                        = &H8144???
%GL_PIXEL_TILE_CACHE_SIZE_SGIX                        = &H8145???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture_select)
%GL_DUAL_ALPHA4_SGIS                                  = &H8110???
%GL_DUAL_ALPHA8_SGIS                                  = &H8111???
%GL_DUAL_ALPHA12_SGIS                                 = &H8112???
%GL_DUAL_ALPHA16_SGIS                                 = &H8113???
%GL_DUAL_LUMINANCE4_SGIS                              = &H8114???
%GL_DUAL_LUMINANCE8_SGIS                              = &H8115???
%GL_DUAL_LUMINANCE12_SGIS                             = &H8116???
%GL_DUAL_LUMINANCE16_SGIS                             = &H8117???
%GL_DUAL_INTENSITY4_SGIS                              = &H8118???
%GL_DUAL_INTENSITY8_SGIS                              = &H8119???
%GL_DUAL_INTENSITY12_SGIS                             = &H811A???
%GL_DUAL_INTENSITY16_SGIS                             = &H811B???
%GL_DUAL_LUMINANCE_ALPHA4_SGIS                        = &H811C???
%GL_DUAL_LUMINANCE_ALPHA8_SGIS                        = &H811D???
%GL_QUAD_ALPHA4_SGIS                                  = &H811E???
%GL_QUAD_ALPHA8_SGIS                                  = &H811F???
%GL_QUAD_LUMINANCE4_SGIS                              = &H8120???
%GL_QUAD_LUMINANCE8_SGIS                              = &H8121???
%GL_QUAD_INTENSITY4_SGIS                              = &H8122???
%GL_QUAD_INTENSITY8_SGIS                              = &H8123???
%GL_DUAL_TEXTURE_SELECT_SGIS                          = &H8124???
%GL_QUAD_TEXTURE_SELECT_SGIS                          = &H8125???
#ENDIF

#IF NOT %DEF(%GL_SGIX_sprite)
%GL_SPRITE_SGIX                                       = &H8148???
%GL_SPRITE_MODE_SGIX                                  = &H8149???
%GL_SPRITE_AXIS_SGIX                                  = &H814A???
%GL_SPRITE_TRANSLATION_SGIX                           = &H814B???
%GL_SPRITE_AXIAL_SGIX                                 = &H814C???
%GL_SPRITE_OBJECT_ALIGNED_SGIX                        = &H814D???
%GL_SPRITE_EYE_ALIGNED_SGIX                           = &H814E???
#ENDIF

#IF NOT %DEF(%GL_SGIX_texture_multi_buffer)
%GL_TEXTURE_MULTI_BUFFER_HINT_SGIX                    = &H812E???
#ENDIF

#IF NOT %DEF(%GL_EXT_point_parameters)
%GL_POINT_SIZE_MIN_EXT                                = &H8126???
%GL_POINT_SIZE_MAX_EXT                                = &H8127???
%GL_POINT_FADE_THRESHOLD_SIZE_EXT                     = &H8128???
%GL_DISTANCE_ATTENUATION_EXT                          = &H8129???
#ENDIF

#IF NOT %DEF(%GL_SGIS_point_parameters)
%GL_POINT_SIZE_MIN_SGIS                               = &H8126???
%GL_POINT_SIZE_MAX_SGIS                               = &H8127???
%GL_POINT_FADE_THRESHOLD_SIZE_SGIS                    = &H8128???
%GL_DISTANCE_ATTENUATION_SGIS                         = &H8129???
#ENDIF

#IF NOT %DEF(%GL_SGIX_instruments)
%GL_INSTRUMENT_BUFFER_POINTER_SGIX                    = &H8180???
%GL_INSTRUMENT_MEASUREMENTS_SGIX                      = &H8181???
#ENDIF

#IF NOT %DEF(%GL_SGIX_texture_scale_bias)
%GL_POST_TEXTURE_FILTER_BIAS_SGIX                     = &H8179???
%GL_POST_TEXTURE_FILTER_SCALE_SGIX                    = &H817A???
%GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX               = &H817B???
%GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX              = &H817C???
#ENDIF

#IF NOT %DEF(%GL_SGIX_framezoom)
%GL_FRAMEZOOM_SGIX                                    = &H818B???
%GL_FRAMEZOOM_FACTOR_SGIX                             = &H818C???
%GL_MAX_FRAMEZOOM_FACTOR_SGIX                         = &H818D???
#ENDIF

'#IF NOT %DEF(%GL_SGIX_tag_sample_buffer)
'#ENDIF

#IF NOT %DEF(%GL_SGIX_polynomial_ffd)
%GL_TEXTURE_DEFORMATION_BIT_SGIX                      = &H00000001???
%GL_GEOMETRY_DEFORMATION_BIT_SGIX                     = &H00000002???
%GL_GEOMETRY_DEFORMATION_SGIX                         = &H8194???
%GL_TEXTURE_DEFORMATION_SGIX                          = &H8195???
%GL_DEFORMATIONS_MASK_SGIX                            = &H8196???
%GL_MAX_DEFORMATION_ORDER_SGIX                        = &H8197???
#ENDIF

#IF NOT %DEF(%GL_SGIX_reference_plane)
%GL_REFERENCE_PLANE_SGIX                              = &H817D???
%GL_REFERENCE_PLANE_EQUATION_SGIX                     = &H817E???
#ENDIF

'#IF NOT %DEF(%GL_SGIX_flush_raster)
'#ENDIF

#IF NOT %DEF(%GL_SGIX_depth_texture)
%GL_DEPTH_COMPONENT16_SGIX                            = &H81A5???
%GL_DEPTH_COMPONENT24_SGIX                            = &H81A6???
%GL_DEPTH_COMPONENT32_SGIX                            = &H81A7???
#ENDIF

#IF NOT %DEF(%GL_SGIS_fog_function)
%GL_FOG_FUNC_SGIS                                     = &H812A???
%GL_FOG_FUNC_POINTS_SGIS                              = &H812B???
%GL_MAX_FOG_FUNC_POINTS_SGIS                          = &H812C???
#ENDIF

#IF NOT %DEF(%GL_SGIX_fog_offset)
%GL_FOG_OFFSET_SGIX                                   = &H8198???
%GL_FOG_OFFSET_VALUE_SGIX                             = &H8199???
#ENDIF

#IF NOT %DEF(%GL_HP_image_transform)
%GL_IMAGE_SCALE_X_HP                                  = &H8155???
%GL_IMAGE_SCALE_Y_HP                                  = &H8156???
%GL_IMAGE_TRANSLATE_X_HP                              = &H8157???
%GL_IMAGE_TRANSLATE_Y_HP                              = &H8158???
%GL_IMAGE_ROTATE_ANGLE_HP                             = &H8159???
%GL_IMAGE_ROTATE_ORIGIN_X_HP                          = &H815A???
%GL_IMAGE_ROTATE_ORIGIN_Y_HP                          = &H815B???
%GL_IMAGE_MAG_FILTER_HP                               = &H815C???
%GL_IMAGE_MIN_FILTER_HP                               = &H815D???
%GL_IMAGE_CUBIC_WEIGHT_HP                             = &H815E???
%GL_CUBIC_HP                                          = &H815F???
%GL_AVERAGE_HP                                        = &H8160???
%GL_IMAGE_TRANSFORM_2D_HP                             = &H8161???
%GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP               = &H8162???
%GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP         = &H8163???
#ENDIF

#IF NOT %DEF(%GL_HP_convolution_border_modes)
%GL_IGNORE_BORDER_HP                                  = &H8150???
%GL_CONSTANT_BORDER_HP                                = &H8151???
%GL_REPLICATE_BORDER_HP                               = &H8153???
%GL_CONVOLUTION_BORDER_COLOR_HP                       = &H8154???
#ENDIF

'#IF NOT %DEF(%GL_INGR_palette_buffer)
'#ENDIF

#IF NOT %DEF(%GL_SGIX_texture_add_env)
%GL_TEXTURE_ENV_BIAS_SGIX                             = &H80BE???
#ENDIF

'#IF NOT %DEF(%GL_EXT_color_subtable)
'#ENDIF

#IF NOT %DEF(%GL_PGI_vertex_hints)
%GL_VERTEX_DATA_HINT_PGI                              = &H1A22A???
%GL_VERTEX_CONSISTENT_HINT_PGI                        = &H1A22B???
%GL_MATERIAL_SIDE_HINT_PGI                            = &H1A22C???
%GL_MAX_VERTEX_HINT_PGI                               = &H1A22D???
%GL_VERTEX23_BIT_PGI                                  = &H00000004???
%GL_VERTEX4_BIT_PGI                                   = &H00000008???
%GL_COLOR3_BIT_PGI                                    = &H00010000???
%GL_COLOR4_BIT_PGI                                    = &H00020000???
%GL_EDGEFLAG_BIT_PGI                                  = &H00040000???
%GL_INDEX_BIT_PGI                                     = &H00080000???
%GL_MAT_AMBIENT_BIT_PGI                               = &H00100000???
%GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI                   = &H00200000???
%GL_MAT_DIFFUSE_BIT_PGI                               = &H00400000???
%GL_MAT_EMISSION_BIT_PGI                              = &H00800000???
%GL_MAT_COLOR_INDEXES_BIT_PGI                         = &H01000000???
%GL_MAT_SHININESS_BIT_PGI                             = &H02000000???
%GL_MAT_SPECULAR_BIT_PGI                              = &H04000000???
%GL_NORMAL_BIT_PGI                                    = &H08000000???
%GL_TEXCOORD1_BIT_PGI                                 = &H10000000???
%GL_TEXCOORD2_BIT_PGI                                 = &H20000000???
%GL_TEXCOORD3_BIT_PGI                                 = &H40000000???
%GL_TEXCOORD4_BIT_PGI                                 = &H80000000???
#ENDIF

#IF NOT %DEF(%GL_PGI_misc_hints)
%GL_PREFER_DOUBLEBUFFER_HINT_PGI                      = &H1A1F8???
%GL_CONSERVE_MEMORY_HINT_PGI                          = &H1A1FD???
%GL_RECLAIM_MEMORY_HINT_PGI                           = &H1A1FE???
%GL_NATIVE_GRAPHICS_HANDLE_PGI                        = &H1A202???
%GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI                    = &H1A203???
%GL_NATIVE_GRAPHICS_END_HINT_PGI                      = &H1A204???
%GL_ALWAYS_FAST_HINT_PGI                              = &H1A20C???
%GL_ALWAYS_SOFT_HINT_PGI                              = &H1A20D???
%GL_ALLOW_DRAW_OBJ_HINT_PGI                           = &H1A20E???
%GL_ALLOW_DRAW_WIN_HINT_PGI                           = &H1A20F???
%GL_ALLOW_DRAW_FRG_HINT_PGI                           = &H1A210???
%GL_ALLOW_DRAW_MEM_HINT_PGI                           = &H1A211???
%GL_STRICT_DEPTHFUNC_HINT_PGI                         = &H1A216???
%GL_STRICT_LIGHTING_HINT_PGI                          = &H1A217???
%GL_STRICT_SCISSOR_HINT_PGI                           = &H1A218???
%GL_FULL_STIPPLE_HINT_PGI                             = &H1A219???
%GL_CLIP_NEAR_HINT_PGI                                = &H1A220???
%GL_CLIP_FAR_HINT_PGI                                 = &H1A221???
%GL_WIDE_LINE_HINT_PGI                                = &H1A222???
%GL_BACK_NORMALS_HINT_PGI                             = &H1A223???
#ENDIF

#IF NOT %DEF(%GL_EXT_paletted_texture)
%GL_COLOR_INDEX1_EXT                                  = &H80E2???
%GL_COLOR_INDEX2_EXT                                  = &H80E3???
%GL_COLOR_INDEX4_EXT                                  = &H80E4???
%GL_COLOR_INDEX8_EXT                                  = &H80E5???
%GL_COLOR_INDEX12_EXT                                 = &H80E6???
%GL_COLOR_INDEX16_EXT                                 = &H80E7???
%GL_TEXTURE_INDEX_SIZE_EXT                            = &H80ED???
#ENDIF

#IF NOT %DEF(%GL_EXT_clip_volume_hint)
%GL_CLIP_VOLUME_CLIPPING_HINT_EXT                     = &H80F0???
#ENDIF

#IF NOT %DEF(%GL_SGIX_list_priority)
%GL_LIST_PRIORITY_SGIX                                = &H8182???
#ENDIF

#IF NOT %DEF(%GL_SGIX_ir_instrument1)
%GL_IR_INSTRUMENT1_SGIX                               = &H817F???
#ENDIF

#IF NOT %DEF(%GL_SGIX_calligraphic_fragment)
%GL_CALLIGRAPHIC_FRAGMENT_SGIX                        = &H8183???
#ENDIF

#IF NOT %DEF(%GL_SGIX_texture_lod_bias)
%GL_TEXTURE_LOD_BIAS_S_SGIX                           = &H818E???
%GL_TEXTURE_LOD_BIAS_T_SGIX                           = &H818F???
%GL_TEXTURE_LOD_BIAS_R_SGIX                           = &H8190???
#ENDIF

#IF NOT %DEF(%GL_SGIX_shadow_ambient)
%GL_SHADOW_AMBIENT_SGIX                               = &H80BF???
#ENDIF

'#IF NOT %DEF(%GL_EXT_index_texture)
'#ENDIF

#IF NOT %DEF(%GL_EXT_index_material)
%GL_INDEX_MATERIAL_EXT                                = &H81B8???
%GL_INDEX_MATERIAL_PARAMETER_EXT                      = &H81B9???
%GL_INDEX_MATERIAL_FACE_EXT                           = &H81BA???
#ENDIF

#IF NOT %DEF(%GL_EXT_index_func)
%GL_INDEX_TEST_EXT                                    = &H81B5???
%GL_INDEX_TEST_FUNC_EXT                               = &H81B6???
%GL_INDEX_TEST_REF_EXT                                = &H81B7???
#ENDIF

#IF NOT %DEF(%GL_EXT_index_array_formats)
%GL_IUI_V2F_EXT                                       = &H81AD???
%GL_IUI_V3F_EXT                                       = &H81AE???
%GL_IUI_N3F_V2F_EXT                                   = &H81AF???
%GL_IUI_N3F_V3F_EXT                                   = &H81B0???
%GL_T2F_IUI_V2F_EXT                                   = &H81B1???
%GL_T2F_IUI_V3F_EXT                                   = &H81B2???
%GL_T2F_IUI_N3F_V2F_EXT                               = &H81B3???
%GL_T2F_IUI_N3F_V3F_EXT                               = &H81B4???
#ENDIF

#IF NOT %DEF(%GL_EXT_compiled_vertex_array)
%GL_ARRAY_ELEMENT_LOCK_FIRST_EXT                      = &H81A8???
%GL_ARRAY_ELEMENT_LOCK_COUNT_EXT                      = &H81A9???
#ENDIF

#IF NOT %DEF(%GL_EXT_cull_vertex)
%GL_CULL_VERTEX_EXT                                   = &H81AA???
%GL_CULL_VERTEX_EYE_POSITION_EXT                      = &H81AB???
%GL_CULL_VERTEX_OBJECT_POSITION_EXT                   = &H81AC???
#ENDIF

#IF NOT %DEF(%GL_SGIX_ycrcb)
%GL_YCRCB_422_SGIX                                    = &H81BB???
%GL_YCRCB_444_SGIX                                    = &H81BC???
#ENDIF

#IF NOT %DEF(%GL_SGIX_fragment_lighting)
%GL_FRAGMENT_LIGHTING_SGIX                            = &H8400???
%GL_FRAGMENT_COLOR_MATERIAL_SGIX                      = &H8401???
%GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX                 = &H8402???
%GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX            = &H8403???
%GL_MAX_FRAGMENT_LIGHTS_SGIX                          = &H8404???
%GL_MAX_ACTIVE_LIGHTS_SGIX                            = &H8405???
%GL_CURRENT_RASTER_NORMAL_SGIX                        = &H8406???
%GL_LIGHT_ENV_MODE_SGIX                               = &H8407???
%GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX            = &H8408???
%GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX                = &H8409???
%GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX                 = &H840A???
%GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX    = &H840B???
%GL_FRAGMENT_LIGHT0_SGIX                              = &H840C???
%GL_FRAGMENT_LIGHT1_SGIX                              = &H840D???
%GL_FRAGMENT_LIGHT2_SGIX                              = &H840E???
%GL_FRAGMENT_LIGHT3_SGIX                              = &H840F???
%GL_FRAGMENT_LIGHT4_SGIX                              = &H8410???
%GL_FRAGMENT_LIGHT5_SGIX                              = &H8411???
%GL_FRAGMENT_LIGHT6_SGIX                              = &H8412???
%GL_FRAGMENT_LIGHT7_SGIX                              = &H8413???
#ENDIF

#IF NOT %DEF(%GL_IBM_rasterpos_clip)
%GL_RASTER_POSITION_UNCLIPPED_IBM                     = &H19262???
#ENDIF

#IF NOT %DEF(%GL_HP_texture_lighting)
%GL_TEXTURE_LIGHTING_MODE_HP                          = &H8167???
%GL_TEXTURE_POST_SPECULAR_HP                          = &H8168???
%GL_TEXTURE_PRE_SPECULAR_HP                           = &H8169???
#ENDIF

#IF NOT %DEF(%GL_EXT_draw_range_elements)
%GL_MAX_ELEMENTS_VERTICES_EXT                         = &H80E8???
%GL_MAX_ELEMENTS_INDICES_EXT                          = &H80E9???
#ENDIF

#IF NOT %DEF(%GL_WIN_phong_shading)
%GL_PHONG_WIN                                         = &H80EA???
%GL_PHONG_HINT_WIN                                    = &H80EB???
#ENDIF

#IF NOT %DEF(%GL_WIN_specular_fog)
%GL_FOG_SPECULAR_TEXTURE_WIN                          = &H80EC???
#ENDIF

#IF NOT %DEF(%GL_EXT_light_texture)
%GL_FRAGMENT_MATERIAL_EXT                             = &H8349???
%GL_FRAGMENT_NORMAL_EXT                               = &H834A???
%GL_FRAGMENT_COLOR_EXT                                = &H834C???
%GL_ATTENUATION_EXT                                   = &H834D???
%GL_SHADOW_ATTENUATION_EXT                            = &H834E???
%GL_TEXTURE_APPLICATION_MODE_EXT                      = &H834F???
%GL_TEXTURE_LIGHT_EXT                                 = &H8350???
%GL_TEXTURE_MATERIAL_FACE_EXT                         = &H8351???
%GL_TEXTURE_MATERIAL_PARAMETER_EXT                    = &H8352???
' /* reuse %GL_FRAGMENT_DEPTH_EXT
#ENDIF

#IF NOT %DEF(%GL_SGIX_blend_alpha_minmax)
%GL_ALPHA_MIN_SGIX                                    = &H8320???
%GL_ALPHA_MAX_SGIX                                    = &H8321???
#ENDIF

#IF NOT %DEF(%GL_SGIX_impact_pixel_texture)
%GL_PIXEL_TEX_GEN_Q_CEILING_SGIX                      = &H8184???   ' Removed in version 76
%GL_PIXEL_TEX_GEN_Q_ROUND_SGIX                        = &H8185???   ' Removed in version 76
%GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX                        = &H8186???   ' Removed in version 76
%GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX                  = &H8187???   ' Removed in version 76
%GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX               = &H8188???   ' Removed in version 76
%GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX                       = &H8189???   ' Removed in version 76
%GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX                       = &H818A???   ' Removed in version 76
#ENDIF

#IF NOT %DEF(%GL_EXT_bgra)
%GL_BGR_EXT                                           = &H80E0???
%GL_BGRA_EXT                                          = &H80E1???
#ENDIF

#IF NOT %DEF(%GL_SGIX_async)
%GL_ASYNC_MARKER_SGIX                                 = &H8329???
#ENDIF

#IF NOT %DEF(%GL_SGIX_async_pixel)
%GL_ASYNC_TEX_IMAGE_SGIX                              = &H835C???
%GL_ASYNC_DRAW_PIXELS_SGIX                            = &H835D???
%GL_ASYNC_READ_PIXELS_SGIX                            = &H835E???
%GL_MAX_ASYNC_TEX_IMAGE_SGIX                          = &H835F???
%GL_MAX_ASYNC_DRAW_PIXELS_SGIX                        = &H8360???
%GL_MAX_ASYNC_READ_PIXELS_SGIX                        = &H8361???
#ENDIF

#IF NOT %DEF(%GL_SGIX_async_histogram)
%GL_ASYNC_HISTOGRAM_SGIX                              = &H832C???
%GL_MAX_ASYNC_HISTOGRAM_SGIX                          = &H832D???
#ENDIF

#IF NOT %DEF(%GL_INTEL_texture_scissor)
#ENDIF

#IF NOT %DEF(%GL_INTEL_parallel_arrays)
%GL_PARALLEL_ARRAYS_INTEL                             = &H83F4???
%GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL              = &H83F5???
%GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL              = &H83F6???
%GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL               = &H83F7???
%GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL       = &H83F8???
#ENDIF

#IF NOT %DEF(%GL_HP_occlusion_test)
%GL_OCCLUSION_TEST_HP                                 = &H8165???
%GL_OCCLUSION_TEST_RESULT_HP                          = &H8166???
#ENDIF

#IF NOT %DEF(%GL_EXT_pixel_transform)
%GL_PIXEL_TRANSFORM_2D_EXT                            = &H8330???
%GL_PIXEL_MAG_FILTER_EXT                              = &H8331???
%GL_PIXEL_MIN_FILTER_EXT                              = &H8332???
%GL_PIXEL_CUBIC_WEIGHT_EXT                            = &H8333???
%GL_CUBIC_EXT                                         = &H8334???
%GL_AVERAGE_EXT                                       = &H8335???
%GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT                = &H8336???
%GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT            = &H8337???
%GL_PIXEL_TRANSFORM_2D_MATRIX_EXT                     = &H8338???
#ENDIF

'#IF NOT %DEF(%GL_EXT_pixel_transform_color_table)
'#ENDIF

#IF NOT %DEF(%GL_EXT_shared_texture_palette)
%GL_SHARED_TEXTURE_PALETTE_EXT                        = &H81FB???
#ENDIF

#IF NOT %DEF(%GL_EXT_separate_specular_color)
%GL_LIGHT_MODEL_COLOR_CONTROL_EXT                     = &H81F8???
%GL_SINGLE_COLOR_EXT                                  = &H81F9???
%GL_SEPARATE_SPECULAR_COLOR_EXT                       = &H81FA???
#ENDIF

#IF NOT %DEF(%GL_EXT_secondary_color)
%GL_COLOR_SUM_EXT                                     = &H8458???
%GL_CURRENT_SECONDARY_COLOR_EXT                       = &H8459???
%GL_SECONDARY_COLOR_ARRAY_SIZE_EXT                    = &H845A???
%GL_SECONDARY_COLOR_ARRAY_TYPE_EXT                    = &H845B???
%GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT                  = &H845C???
%GL_SECONDARY_COLOR_ARRAY_POINTER_EXT                 = &H845D???
%GL_SECONDARY_COLOR_ARRAY_EXT                         = &H845E???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_perturb_normal)
%GL_PERTURB_EXT                                       = &H85AE???
%GL_TEXTURE_NORMAL_EXT                                = &H85AF???
#ENDIF

'#IF NOT %DEF(%GL_EXT_multi_draw_arrays)
'#ENDIF

#IF NOT %DEF(%GL_EXT_fog_coord)
%GL_FOG_COORDINATE_SOURCE_EXT                         = &H8450???
%GL_FOG_COORDINATE_EXT                                = &H8451???
%GL_FRAGMENT_DEPTH_EXT                                = &H8452???
%GL_CURRENT_FOG_COORDINATE_EXT                        = &H8453???
%GL_FOG_COORDINATE_ARRAY_TYPE_EXT                     = &H8454???
%GL_FOG_COORDINATE_ARRAY_STRIDE_EXT                   = &H8455???
%GL_FOG_COORDINATE_ARRAY_POINTER_EXT                  = &H8456???
%GL_FOG_COORDINATE_ARRAY_EXT                          = &H8457???
#ENDIF

#IF NOT %DEF(%GL_REND_screen_coordinates)
%GL_SCREEN_COORDINATES_REND                           = &H8490???
%GL_INVERTED_SCREEN_W_REND                            = &H8491???
#ENDIF

#IF NOT %DEF(%GL_EXT_coordinate_frame)
%GL_TANGENT_ARRAY_EXT                                 = &H8439???
%GL_BINORMAL_ARRAY_EXT                                = &H843A???
%GL_CURRENT_TANGENT_EXT                               = &H843B???
%GL_CURRENT_BINORMAL_EXT                              = &H843C???
%GL_TANGENT_ARRAY_TYPE_EXT                            = &H843E???
%GL_TANGENT_ARRAY_STRIDE_EXT                          = &H843F???
%GL_BINORMAL_ARRAY_TYPE_EXT                           = &H8440???
%GL_BINORMAL_ARRAY_STRIDE_EXT                         = &H8441???
%GL_TANGENT_ARRAY_POINTER_EXT                         = &H8442???
%GL_BINORMAL_ARRAY_POINTER_EXT                        = &H8443???
%GL_MAP1_TANGENT_EXT                                  = &H8444???
%GL_MAP2_TANGENT_EXT                                  = &H8445???
%GL_MAP1_BINORMAL_EXT                                 = &H8446???
%GL_MAP2_BINORMAL_EXT                                 = &H8447???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_env_combine)
%GL_COMBINE_EXT                                       = &H8570???
%GL_COMBINE_RGB_EXT                                   = &H8571???
%GL_COMBINE_ALPHA_EXT                                 = &H8572???
%GL_RGB_SCALE_EXT                                     = &H8573???
%GL_ADD_SIGNED_EXT                                    = &H8574???
%GL_INTERPOLATE_EXT                                   = &H8575???
%GL_CONSTANT_EXT                                      = &H8576???
%GL_PRIMARY_COLOR_EXT                                 = &H8577???
%GL_PREVIOUS_EXT                                      = &H8578???
%GL_SOURCE0_RGB_EXT                                   = &H8580???
%GL_SOURCE1_RGB_EXT                                   = &H8581???
%GL_SOURCE2_RGB_EXT                                   = &H8582???
%GL_SOURCE0_ALPHA_EXT                                 = &H8588???
%GL_SOURCE1_ALPHA_EXT                                 = &H8589???
%GL_SOURCE2_ALPHA_EXT                                 = &H858A???
%GL_OPERAND0_RGB_EXT                                  = &H8590???
%GL_OPERAND1_RGB_EXT                                  = &H8591???
%GL_OPERAND2_RGB_EXT                                  = &H8592???
%GL_OPERAND0_ALPHA_EXT                                = &H8598???
%GL_OPERAND1_ALPHA_EXT                                = &H8599???
%GL_OPERAND2_ALPHA_EXT                                = &H859A???
#ENDIF

#IF NOT %DEF(%GL_APPLE_specular_vector)
%GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE                 = &H85B0???
#ENDIF

#IF NOT %DEF(%GL_APPLE_transform_hint)
%GL_TRANSFORM_HINT_APPLE                              = &H85B1???
#ENDIF

#IF NOT %DEF(%GL_SGIX_fog_scale)
%GL_FOG_SCALE_SGIX                                    = &H81FC???   ' Removed in version 76
%GL_FOG_SCALE_VALUE_SGIX                              = &H81FD???   ' Removed in version 76
#ENDIF

#IF NOT %DEF(%GL_SUNX_constant_data)
%GL_UNPACK_CONSTANT_DATA_SUNX                         = &H81D5???
%GL_TEXTURE_CONSTANT_DATA_SUNX                        = &H81D6???
#ENDIF

#IF NOT %DEF(%GL_SUN_global_alpha)
%GL_GLOBAL_ALPHA_SUN                                  = &H81D9???
%GL_GLOBAL_ALPHA_FACTOR_SUN                           = &H81DA???
#ENDIF

#IF NOT %DEF(%GL_SUN_triangle_list)
%GL_RESTART_SUN                                       = &H0001???
%GL_REPLACE_MIDDLE_SUN                                = &H0002???
%GL_REPLACE_OLDEST_SUN                                = &H0003???
%GL_TRIANGLE_LIST_SUN                                 = &H81D7???
%GL_REPLACEMENT_CODE_SUN                              = &H81D8???
%GL_REPLACEMENT_CODE_ARRAY_SUN                        = &H85C0???
%GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN                   = &H85C1???
%GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN                 = &H85C2???
%GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN                = &H85C3???
%GL_R1UI_V3F_SUN                                      = &H85C4???
%GL_R1UI_C4UB_V3F_SUN                                 = &H85C5???
%GL_R1UI_C3F_V3F_SUN                                  = &H85C6???
%GL_R1UI_N3F_V3F_SUN                                  = &H85C7???
%GL_R1UI_C4F_N3F_V3F_SUN                              = &H85C8???
%GL_R1UI_T2F_V3F_SUN                                  = &H85C9???
%GL_R1UI_T2F_N3F_V3F_SUN                              = &H85CA???
%GL_R1UI_T2F_C4F_N3F_V3F_SUN                          = &H85CB???
#ENDIF

'#IF NOT %DEF(%GL_SUN_vertex)
'#ENDIF

#IF NOT %DEF(%GL_EXT_blend_func_separate)
%GL_BLEND_DST_RGB_EXT                                 = &H80C8???
%GL_BLEND_SRC_RGB_EXT                                 = &H80C9???
%GL_BLEND_DST_ALPHA_EXT                               = &H80CA???
%GL_BLEND_SRC_ALPHA_EXT                               = &H80CB???
#ENDIF

#IF NOT %DEF(%GL_INGR_color_clamp)
%GL_RED_MIN_CLAMP_INGR                                = &H8560???
%GL_GREEN_MIN_CLAMP_INGR                              = &H8561???
%GL_BLUE_MIN_CLAMP_INGR                               = &H8562???
%GL_ALPHA_MIN_CLAMP_INGR                              = &H8563???
%GL_RED_MAX_CLAMP_INGR                                = &H8564???
%GL_GREEN_MAX_CLAMP_INGR                              = &H8565???
%GL_BLUE_MAX_CLAMP_INGR                               = &H8566???
%GL_ALPHA_MAX_CLAMP_INGR                              = &H8567???
#ENDIF

#IF NOT %DEF(%GL_INGR_interlace_read)
%GL_INTERLACE_READ_INGR                               = &H8568???
#ENDIF

#IF NOT %DEF(%GL_EXT_stencil_wrap)
%GL_INCR_WRAP_EXT                                     = &H8507???
%GL_DECR_WRAP_EXT                                     = &H8508???
#ENDIF

#IF NOT %DEF(%GL_EXT_422_pixels)
%GL_422_EXT                                           = &H80CC???
%GL_422_REV_EXT                                       = &H80CD???
%GL_422_AVERAGE_EXT                                   = &H80CE???
%GL_422_REV_AVERAGE_EXT                               = &H80CF???
#ENDIF

#IF NOT %DEF(%GL_NV_texgen_reflection)
%GL_NORMAL_MAP_NV                                     = &H8511???
%GL_REFLECTION_MAP_NV                                 = &H8512???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_cube_map)
%GL_NORMAL_MAP_EXT                                    = &H8511???
%GL_REFLECTION_MAP_EXT                                = &H8512???
%GL_TEXTURE_CUBE_MAP_EXT                              = &H8513???
%GL_TEXTURE_BINDING_CUBE_MAP_EXT                      = &H8514???
%GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT                   = &H8515???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT                   = &H8516???
%GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT                   = &H8517???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT                   = &H8518???
%GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT                   = &H8519???
%GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT                   = &H851A???
%GL_PROXY_TEXTURE_CUBE_MAP_EXT                        = &H851B???
%GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT                     = &H851C???
#ENDIF

#IF NOT %DEF(%GL_SUN_convolution_border_modes)
%GL_WRAP_BORDER_SUN                                   = &H81D4???
#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_env_add)
'#ENDIF

#IF NOT %DEF(%GL_EXT_texture_lod_bias)
%GL_MAX_TEXTURE_LOD_BIAS_EXT                          = &H84FD???
%GL_TEXTURE_FILTER_CONTROL_EXT                        = &H8500???
%GL_TEXTURE_LOD_BIAS_EXT                              = &H8501???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_filter_anisotropic)
%GL_TEXTURE_MAX_ANISOTROPY_EXT                        = &H84FE???
%GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT                    = &H84FF???
#ENDIF

#IF NOT %DEF(%GL_EXT_vertex_weighting)
%GL_MODELVIEW0_STACK_DEPTH_EXT                        = &H0BA3???
%GL_MODELVIEW1_STACK_DEPTH_EXT                        = &H8502???
%GL_MODELVIEW0_MATRIX_EXT                             = &H0BA6???
%GL_MODELVIEW1_MATRIX_EXT                             = &H8506???
%GL_VERTEX_WEIGHTING_EXT                              = &H8509???
%GL_MODELVIEW0_EXT                                    = &H1700???
%GL_MODELVIEW1_EXT                                    = &H850A???
%GL_CURRENT_VERTEX_WEIGHT_EXT                         = &H850B???
%GL_VERTEX_WEIGHT_ARRAY_EXT                           = &H850C???
%GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT                      = &H850D???
%GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT                      = &H850E???
%GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT                    = &H850F???
%GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT                   = &H8510???
#ENDIF

#IF NOT %DEF(%GL_NV_light_max_exponent)
%GL_MAX_SHININESS_NV                                  = &H8504???
%GL_MAX_SPOT_EXPONENT_NV                              = &H8505???
#ENDIF

#IF NOT %DEF(%GL_NV_vertex_array_range)
%GL_VERTEX_ARRAY_RANGE_NV                             = &H851D???
%GL_VERTEX_ARRAY_RANGE_LENGTH_NV                      = &H851E???
%GL_VERTEX_ARRAY_RANGE_VALID_NV                       = &H851F???
%GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV                 = &H8520???
%GL_VERTEX_ARRAY_RANGE_POINTER_NV                     = &H8521???
#ENDIF

#IF NOT %DEF(%GL_NV_register_combiners)
%GL_REGISTER_COMBINERS_NV                             = &H8522???
%GL_VARIABLE_A_NV                                     = &H8523???
%GL_VARIABLE_B_NV                                     = &H8524???
%GL_VARIABLE_C_NV                                     = &H8525???
%GL_VARIABLE_D_NV                                     = &H8526???
%GL_VARIABLE_E_NV                                     = &H8527???
%GL_VARIABLE_F_NV                                     = &H8528???
%GL_VARIABLE_G_NV                                     = &H8529???
%GL_CONSTANT_COLOR0_NV                                = &H852A???
%GL_CONSTANT_COLOR1_NV                                = &H852B???
%GL_PRIMARY_COLOR_NV                                  = &H852C???
%GL_SECONDARY_COLOR_NV                                = &H852D???
%GL_SPARE0_NV                                         = &H852E???
%GL_SPARE1_NV                                         = &H852F???
%GL_DISCARD_NV                                        = &H8530???
%GL_E_TIMES_F_NV                                      = &H8531???
%GL_SPARE0_PLUS_SECONDARY_COLOR_NV                    = &H8532???
%GL_UNSIGNED_IDENTITY_NV                              = &H8536???
%GL_UNSIGNED_INVERT_NV                                = &H8537???
%GL_EXPAND_NORMAL_NV                                  = &H8538???
%GL_EXPAND_NEGATE_NV                                  = &H8539???
%GL_HALF_BIAS_NORMAL_NV                               = &H853A???
%GL_HALF_BIAS_NEGATE_NV                               = &H853B???
%GL_SIGNED_IDENTITY_NV                                = &H853C???
%GL_SIGNED_NEGATE_NV                                  = &H853D???
%GL_SCALE_BY_TWO_NV                                   = &H853E???
%GL_SCALE_BY_FOUR_NV                                  = &H853F???
%GL_SCALE_BY_ONE_HALF_NV                              = &H8540???
%GL_BIAS_BY_NEGATIVE_ONE_HALF_NV                      = &H8541???
%GL_COMBINER_INPUT_NV                                 = &H8542???
%GL_COMBINER_MAPPING_NV                               = &H8543???
%GL_COMBINER_COMPONENT_USAGE_NV                       = &H8544???
%GL_COMBINER_AB_DOT_PRODUCT_NV                        = &H8545???
%GL_COMBINER_CD_DOT_PRODUCT_NV                        = &H8546???
%GL_COMBINER_MUX_SUM_NV                               = &H8547???
%GL_COMBINER_SCALE_NV                                 = &H8548???
%GL_COMBINER_BIAS_NV                                  = &H8549???
%GL_COMBINER_AB_OUTPUT_NV                             = &H854A???
%GL_COMBINER_CD_OUTPUT_NV                             = &H854B???
%GL_COMBINER_SUM_OUTPUT_NV                            = &H854C???
%GL_MAX_GENERAL_COMBINERS_NV                          = &H854D???
%GL_NUM_GENERAL_COMBINERS_NV                          = &H854E???
%GL_COLOR_SUM_CLAMP_NV                                = &H854F???
%GL_COMBINER0_NV                                      = &H8550???
%GL_COMBINER1_NV                                      = &H8551???
%GL_COMBINER2_NV                                      = &H8552???
%GL_COMBINER3_NV                                      = &H8553???
%GL_COMBINER4_NV                                      = &H8554???
%GL_COMBINER5_NV                                      = &H8555???
%GL_COMBINER6_NV                                      = &H8556???
%GL_COMBINER7_NV                                      = &H8557???
' /* reuse %GL_TEXTURE0_ARB
' /* reuse %GL_TEXTURE1_ARB
' /* reuse %GL_ZERO
' /* reuse %GL_NONE
' /* reuse %GL_FOG
#ENDIF

#IF NOT %DEF(%GL_NV_fog_distance)
%GL_FOG_DISTANCE_MODE_NV                              = &H855A???
%GL_EYE_RADIAL_NV                                     = &H855B???
%GL_EYE_PLANE_ABSOLUTE_NV                             = &H855C???
' /* reuse %GL_EYE_PLANE
#ENDIF

#IF NOT %DEF(%GL_NV_texgen_emboss)
%GL_EMBOSS_LIGHT_NV                                   = &H855D???
%GL_EMBOSS_CONSTANT_NV                                = &H855E???
%GL_EMBOSS_MAP_NV                                     = &H855F???
#ENDIF

'#IF NOT %DEF(%GL_NV_blend_square)
'#ENDIF

#IF NOT %DEF(%GL_NV_texture_env_combine4)
%GL_COMBINE4_NV                                       = &H8503???
%GL_SOURCE3_RGB_NV                                    = &H8583???
%GL_SOURCE3_ALPHA_NV                                  = &H858B???
%GL_OPERAND3_RGB_NV                                   = &H8593???
%GL_OPERAND3_ALPHA_NV                                 = &H859B???
#ENDIF

'#IF NOT %DEF(%GL_MESA_resize_buffers)
'#ENDIF

'#IF NOT %DEF(%GL_MESA_window_pos)
'#ENDIF

#IF NOT %DEF(%GL_EXT_texture_compression_s3tc)
%GL_COMPRESSED_RGB_S3TC_DXT1_EXT                      = &H83F0???
%GL_COMPRESSED_RGBA_S3TC_DXT1_EXT                     = &H83F1???
%GL_COMPRESSED_RGBA_S3TC_DXT3_EXT                     = &H83F2???
%GL_COMPRESSED_RGBA_S3TC_DXT5_EXT                     = &H83F3???
#ENDIF

#IF NOT %DEF(%GL_IBM_cull_vertex)
%GL_CULL_VERTEX_IBM                                   = 103050???
#ENDIF

'#IF NOT %DEF(%GL_IBM_multimode_draw_arrays)
'#ENDIF

#IF NOT %DEF(%GL_IBM_vertex_array_lists)
%GL_VERTEX_ARRAY_LIST_IBM                             = 103070???
%GL_NORMAL_ARRAY_LIST_IBM                             = 103071???
%GL_COLOR_ARRAY_LIST_IBM                              = 103072???
%GL_INDEX_ARRAY_LIST_IBM                              = 103073???
%GL_TEXTURE_COORD_ARRAY_LIST_IBM                      = 103074???
%GL_EDGE_FLAG_ARRAY_LIST_IBM                          = 103075???
%GL_FOG_COORDINATE_ARRAY_LIST_IBM                     = 103076???
%GL_SECONDARY_COLOR_ARRAY_LIST_IBM                    = 103077???
%GL_VERTEX_ARRAY_LIST_STRIDE_IBM                      = 103080???
%GL_NORMAL_ARRAY_LIST_STRIDE_IBM                      = 103081???
%GL_COLOR_ARRAY_LIST_STRIDE_IBM                       = 103082???
%GL_INDEX_ARRAY_LIST_STRIDE_IBM                       = 103083???
%GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM               = 103084???
%GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM                   = 103085???
%GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM              = 103086???
%GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM             = 103087???
#ENDIF

#IF NOT %DEF(%GL_SGIX_subsample)
%GL_PACK_SUBSAMPLE_RATE_SGIX                          = &H85A0???
%GL_UNPACK_SUBSAMPLE_RATE_SGIX                        = &H85A1???
%GL_PIXEL_SUBSAMPLE_4444_SGIX                         = &H85A2???
%GL_PIXEL_SUBSAMPLE_2424_SGIX                         = &H85A3???
%GL_PIXEL_SUBSAMPLE_4242_SGIX                         = &H85A4???
#ENDIF

'#IF NOT %DEF(%GL_SGIX_ycrcb_subsample)
'#ENDIF

#IF NOT %DEF(%GL_SGIX_ycrcba)
%GL_YCRCB_SGIX                                        = &H8318???
%GL_YCRCBA_SGIX                                       = &H8319???
#ENDIF

#IF NOT %DEF(%GL_SGI_depth_pass_instrument)
%GL_DEPTH_PASS_INSTRUMENT_SGIX                        = &H8310???   ' Removed in version 76
%GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX               = &H8311???   ' Removed in version 76
%GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX                    = &H8312???   ' Removed in version 76
#ENDIF

#IF NOT %DEF(%GL_3DFX_texture_compression_FXT1)
%GL_COMPRESSED_RGB_FXT1_3DFX                          = &H86B0???
%GL_COMPRESSED_RGBA_FXT1_3DFX                         = &H86B1???
#ENDIF

#IF NOT %DEF(%GL_3DFX_multisample)
%GL_MULTISAMPLE_3DFX                                  = &H86B2???
%GL_SAMPLE_BUFFERS_3DFX                               = &H86B3???
%GL_SAMPLES_3DFX                                      = &H86B4???
%GL_MULTISAMPLE_BIT_3DFX                              = &H20000000???
#ENDIF

'#IF NOT %DEF(%GL_3DFX_tbuffer)
'#ENDIF

#IF NOT %DEF(%GL_EXT_multisample)
%GL_MULTISAMPLE_EXT                                   = &H809D???
%GL_SAMPLE_ALPHA_TO_MASK_EXT                          = &H809E???
%GL_SAMPLE_ALPHA_TO_ONE_EXT                           = &H809F???
%GL_SAMPLE_MASK_EXT                                   = &H80A0???
%GL_1PASS_EXT                                         = &H80A1???
%GL_2PASS_0_EXT                                       = &H80A2???
%GL_2PASS_1_EXT                                       = &H80A3???
%GL_4PASS_0_EXT                                       = &H80A4???
%GL_4PASS_1_EXT                                       = &H80A5???
%GL_4PASS_2_EXT                                       = &H80A6???
%GL_4PASS_3_EXT                                       = &H80A7???
%GL_SAMPLE_BUFFERS_EXT                                = &H80A8???
%GL_SAMPLES_EXT                                       = &H80A9???
%GL_SAMPLE_MASK_VALUE_EXT                             = &H80AA???
%GL_SAMPLE_MASK_INVERT_EXT                            = &H80AB???
%GL_SAMPLE_PATTERN_EXT                                = &H80AC???
%GL_MULTISAMPLE_BIT_EXT                               = &H20000000???
#ENDIF

#IF NOT %DEF(%GL_SGIX_vertex_preclip)
%GL_VERTEX_PRECLIP_SGIX                               = &H83EE???
%GL_VERTEX_PRECLIP_HINT_SGIX                          = &H83EF???
#ENDIF

#IF NOT %DEF(%GL_SGIX_convolution_accuracy)
%GL_CONVOLUTION_HINT_SGIX                             = &H8316???
#ENDIF

#IF NOT %DEF(%GL_SGIX_resample)
%GL_PACK_RESAMPLE_SGIX                                = &H842C???
%GL_UNPACK_RESAMPLE_SGIX                              = &H842D???
%GL_RESAMPLE_REPLICATE_SGIX                           = &H842E???
%GL_RESAMPLE_ZERO_FILL_SGIX                           = &H842F???
%GL_RESAMPLE_DECIMATE_SGIX                            = &H8430???
#ENDIF

#IF NOT %DEF(%GL_SGIS_point_line_texgen)
%GL_EYE_DISTANCE_TO_POINT_SGIS                        = &H81F0???
%GL_OBJECT_DISTANCE_TO_POINT_SGIS                     = &H81F1???
%GL_EYE_DISTANCE_TO_LINE_SGIS                         = &H81F2???
%GL_OBJECT_DISTANCE_TO_LINE_SGIS                      = &H81F3???
%GL_EYE_POINT_SGIS                                    = &H81F4???
%GL_OBJECT_POINT_SGIS                                 = &H81F5???
%GL_EYE_LINE_SGIS                                     = &H81F6???
%GL_OBJECT_LINE_SGIS                                  = &H81F7???
#ENDIF

#IF NOT %DEF(%GL_SGIS_texture_color_mask)
%GL_TEXTURE_COLOR_WRITEMASK_SGIS                      = &H81EF???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_env_dot3)
%GL_DOT3_RGB_EXT                                      = &H8740???
%GL_DOT3_RGBA_EXT                                     = &H8741???
#ENDIF

#IF NOT %DEF(%GL_ATI_texture_mirror_once)
%GL_MIRROR_CLAMP_ATI                                  = &H8742???
%GL_MIRROR_CLAMP_TO_EDGE_ATI                          = &H8743???
#ENDIF

#IF NOT %DEF(%GL_NV_fence)
%GL_ALL_COMPLETED_NV                                  = &H84F2???
%GL_FENCE_STATUS_NV                                   = &H84F3???
%GL_FENCE_CONDITION_NV                                = &H84F4???
#ENDIF

#IF NOT %DEF(%GL_IBM_static_data)
%GL_ALL_STATIC_DATA_IBM            = 103060???
%GL_STATIC_VERTEX_ARRAY_IBM        = 103061???
#ENDIF

#IF NOT %DEF(%GL_IBM_texture_mirrored_repeat)
%GL_MIRRORED_REPEAT_IBM                               = &H8370???
#ENDIF

#IF NOT %DEF(%GL_NV_evaluators)
%GL_EVAL_2D_NV                                        = &H86C0???
%GL_EVAL_TRIANGULAR_2D_NV                             = &H86C1???
%GL_MAP_TESSELLATION_NV                               = &H86C2???
%GL_MAP_ATTRIB_U_ORDER_NV                             = &H86C3???
%GL_MAP_ATTRIB_V_ORDER_NV                             = &H86C4???
%GL_EVAL_FRACTIONAL_TESSELLATION_NV                   = &H86C5???
%GL_EVAL_VERTEX_ATTRIB0_NV                            = &H86C6???
%GL_EVAL_VERTEX_ATTRIB1_NV                            = &H86C7???
%GL_EVAL_VERTEX_ATTRIB2_NV                            = &H86C8???
%GL_EVAL_VERTEX_ATTRIB3_NV                            = &H86C9???
%GL_EVAL_VERTEX_ATTRIB4_NV                            = &H86CA???
%GL_EVAL_VERTEX_ATTRIB5_NV                            = &H86CB???
%GL_EVAL_VERTEX_ATTRIB6_NV                            = &H86CC???
%GL_EVAL_VERTEX_ATTRIB7_NV                            = &H86CD???
%GL_EVAL_VERTEX_ATTRIB8_NV                            = &H86CE???
%GL_EVAL_VERTEX_ATTRIB9_NV                            = &H86CF???
%GL_EVAL_VERTEX_ATTRIB10_NV                           = &H86D0???
%GL_EVAL_VERTEX_ATTRIB11_NV                           = &H86D1???
%GL_EVAL_VERTEX_ATTRIB12_NV                           = &H86D2???
%GL_EVAL_VERTEX_ATTRIB13_NV                           = &H86D3???
%GL_EVAL_VERTEX_ATTRIB14_NV                           = &H86D4???
%GL_EVAL_VERTEX_ATTRIB15_NV                           = &H86D5???
%GL_MAX_MAP_TESSELLATION_NV                           = &H86D6???
%GL_MAX_RATIONAL_EVAL_ORDER_NV                        = &H86D7???
#ENDIF

#IF NOT %DEF(%GL_NV_packed_depth_stencil)
%GL_DEPTH_STENCIL_NV                                  = &H84F9???
%GL_UNSIGNED_INT_24_8_NV                              = &H84FA???
#ENDIF

#IF NOT %DEF(%GL_NV_register_combiners2)
%GL_PER_STAGE_CONSTANTS_NV                            = &H8535???
#ENDIF

'#IF NOT %DEF(%GL_NV_texture_compression_vtc)
'#ENDIF

#IF NOT %DEF(%GL_NV_texture_rectangle)
%GL_TEXTURE_RECTANGLE_NV                              = &H84F5???
%GL_TEXTURE_BINDING_RECTANGLE_NV                      = &H84F6???
%GL_PROXY_TEXTURE_RECTANGLE_NV                        = &H84F7???
%GL_MAX_RECTANGLE_TEXTURE_SIZE_NV                     = &H84F8???
#ENDIF

#IF NOT %DEF(%GL_NV_texture_shader)
%GL_OFFSET_TEXTURE_RECTANGLE_NV                       = &H864C???
%GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV                 = &H864D???
%GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV                  = &H864E???
%GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV              = &H86D9???
%GL_UNSIGNED_INT_S8_S8_8_8_NV                         = &H86DA???
%GL_UNSIGNED_INT_8_8_S8_S8_REV_NV                     = &H86DB???
%GL_DSDT_MAG_INTENSITY_NV                             = &H86DC???
%GL_SHADER_CONSISTENT_NV                              = &H86DD???
%GL_TEXTURE_SHADER_NV                                 = &H86DE???
%GL_SHADER_OPERATION_NV                               = &H86DF???
%GL_CULL_MODES_NV                                     = &H86E0???
%GL_OFFSET_TEXTURE_MATRIX_NV                          = &H86E1???
%GL_OFFSET_TEXTURE_2D_MATRIX_NV                       = &H86E1???
%GL_OFFSET_TEXTURE_SCALE_NV                           = &H86E2???
%GL_OFFSET_TEXTURE_2D_SCALE_NV                        = &H86E2???
%GL_OFFSET_TEXTURE_BIAS_NV                            = &H86E3???
%GL_OFFSET_TEXTURE_2D_BIAS_NV                         = &H86E3???
%GL_OFFSET_TEXTURE_2D_MATRIX_NV                       = %GL_OFFSET_TEXTURE_MATRIX_NV   ' Removed in version 76
%GL_OFFSET_TEXTURE_2D_SCALE_NV                        = %GL_OFFSET_TEXTURE_SCALE_NV    ' Removed in version 76
%GL_OFFSET_TEXTURE_2D_BIAS_NV                         = %GL_OFFSET_TEXTURE_BIAS_NV     ' Removed in version 76
%GL_PREVIOUS_TEXTURE_INPUT_NV                         = &H86E4???
%GL_CONST_EYE_NV                                      = &H86E5???
%GL_PASS_THROUGH_NV                                   = &H86E6???
%GL_CULL_FRAGMENT_NV                                  = &H86E7???
%GL_OFFSET_TEXTURE_2D_NV                              = &H86E8???
%GL_DEPENDENT_AR_TEXTURE_2D_NV                        = &H86E9???
%GL_DEPENDENT_GB_TEXTURE_2D_NV                        = &H86EA???
%GL_DOT_PRODUCT_NV                                    = &H86EC???
%GL_DOT_PRODUCT_DEPTH_REPLACE_NV                      = &H86ED???
%GL_DOT_PRODUCT_TEXTURE_2D_NV                         = &H86EE???
%GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV                   = &H86F0???
%GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV                   = &H86F1???
%GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV                   = &H86F2???
%GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV         = &H86F3???
%GL_HILO_NV                                           = &H86F4???
%GL_DSDT_NV                                           = &H86F5???
%GL_DSDT_MAG_NV                                       = &H86F6???
%GL_DSDT_MAG_VIB_NV                                   = &H86F7???
%GL_HILO16_NV                                         = &H86F8???
%GL_SIGNED_HILO_NV                                    = &H86F9???
%GL_SIGNED_HILO16_NV                                  = &H86FA???
%GL_SIGNED_RGBA_NV                                    = &H86FB???
%GL_SIGNED_RGBA8_NV                                   = &H86FC???
%GL_SIGNED_RGB_NV                                     = &H86FE???
%GL_SIGNED_RGB8_NV                                    = &H86FF???
%GL_SIGNED_LUMINANCE_NV                               = &H8701???
%GL_SIGNED_LUMINANCE8_NV                              = &H8702???
%GL_SIGNED_LUMINANCE_ALPHA_NV                         = &H8703???
%GL_SIGNED_LUMINANCE8_ALPHA8_NV                       = &H8704???
%GL_SIGNED_ALPHA_NV                                   = &H8705???
%GL_SIGNED_ALPHA8_NV                                  = &H8706???
%GL_SIGNED_INTENSITY_NV                               = &H8707???
%GL_SIGNED_INTENSITY8_NV                              = &H8708???
%GL_DSDT8_NV                                          = &H8709???
%GL_DSDT8_MAG8_NV                                     = &H870A???
%GL_DSDT8_MAG8_INTENSITY8_NV                          = &H870B???
%GL_SIGNED_RGB_UNSIGNED_ALPHA_NV                      = &H870C???
%GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV                    = &H870D???
%GL_HI_SCALE_NV                                       = &H870E???
%GL_LO_SCALE_NV                                       = &H870F???
%GL_DS_SCALE_NV                                       = &H8710???
%GL_DT_SCALE_NV                                       = &H8711???
%GL_MAGNITUDE_SCALE_NV                                = &H8712???
%GL_VIBRANCE_SCALE_NV                                 = &H8713???
%GL_HI_BIAS_NV                                        = &H8714???
%GL_LO_BIAS_NV                                        = &H8715???
%GL_DS_BIAS_NV                                        = &H8716???
%GL_DT_BIAS_NV                                        = &H8717???
%GL_MAGNITUDE_BIAS_NV                                 = &H8718???
%GL_VIBRANCE_BIAS_NV                                  = &H8719???
%GL_TEXTURE_BORDER_VALUES_NV                          = &H871A???
%GL_TEXTURE_HI_SIZE_NV                                = &H871B???
%GL_TEXTURE_LO_SIZE_NV                                = &H871C???
%GL_TEXTURE_DS_SIZE_NV                                = &H871D???
%GL_TEXTURE_DT_SIZE_NV                                = &H871E???
%GL_TEXTURE_MAG_SIZE_NV                               = &H871F???
#ENDIF

#IF NOT %DEF(%GL_NV_texture_shader2)
%GL_DOT_PRODUCT_TEXTURE_3D_NV                         = &H86EF???
#ENDIF

#IF NOT %DEF(%GL_NV_vertex_array_range2)
%GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV               = &H8533???
#ENDIF

#IF NOT %DEF(%GL_NV_vertex_program)
%GL_VERTEX_PROGRAM_NV                                 = &H8620???
%GL_VERTEX_STATE_PROGRAM_NV                           = &H8621???
%GL_ATTRIB_ARRAY_SIZE_NV                              = &H8623???
%GL_ATTRIB_ARRAY_STRIDE_NV                            = &H8624???
%GL_ATTRIB_ARRAY_TYPE_NV                              = &H8625???
%GL_CURRENT_ATTRIB_NV                                 = &H8626???
%GL_PROGRAM_LENGTH_NV                                 = &H8627???
%GL_PROGRAM_STRING_NV                                 = &H8628???
%GL_MODELVIEW_PROJECTION_NV                           = &H8629???
%GL_IDENTITY_NV                                       = &H862A???
%GL_INVERSE_NV                                        = &H862B???
%GL_TRANSPOSE_NV                                      = &H862C???
%GL_INVERSE_TRANSPOSE_NV                              = &H862D???
%GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV                   = &H862E???
%GL_MAX_TRACK_MATRICES_NV                             = &H862F???
%GL_MATRIX0_NV                                        = &H8630???
%GL_MATRIX1_NV                                        = &H8631???
%GL_MATRIX2_NV                                        = &H8632???
%GL_MATRIX3_NV                                        = &H8633???
%GL_MATRIX4_NV                                        = &H8634???
%GL_MATRIX5_NV                                        = &H8635???
%GL_MATRIX6_NV                                        = &H8636???
%GL_MATRIX7_NV                                        = &H8637???
%GL_CURRENT_MATRIX_STACK_DEPTH_NV                     = &H8640???
%GL_CURRENT_MATRIX_NV                                 = &H8641???
%GL_VERTEX_PROGRAM_POINT_SIZE_NV                      = &H8642???
%GL_VERTEX_PROGRAM_TWO_SIDE_NV                        = &H8643???
%GL_PROGRAM_PARAMETER_NV                              = &H8644???
%GL_ATTRIB_ARRAY_POINTER_NV                           = &H8645???
%GL_PROGRAM_TARGET_NV                                 = &H8646???
%GL_PROGRAM_RESIDENT_NV                               = &H8647???
%GL_TRACK_MATRIX_NV                                   = &H8648???
%GL_TRACK_MATRIX_TRANSFORM_NV                         = &H8649???
%GL_VERTEX_PROGRAM_BINDING_NV                         = &H864A???
%GL_PROGRAM_ERROR_POSITION_NV                         = &H864B???
%GL_VERTEX_ATTRIB_ARRAY0_NV                           = &H8650???
%GL_VERTEX_ATTRIB_ARRAY1_NV                           = &H8651???
%GL_VERTEX_ATTRIB_ARRAY2_NV                           = &H8652???
%GL_VERTEX_ATTRIB_ARRAY3_NV                           = &H8653???
%GL_VERTEX_ATTRIB_ARRAY4_NV                           = &H8654???
%GL_VERTEX_ATTRIB_ARRAY5_NV                           = &H8655???
%GL_VERTEX_ATTRIB_ARRAY6_NV                           = &H8656???
%GL_VERTEX_ATTRIB_ARRAY7_NV                           = &H8657???
%GL_VERTEX_ATTRIB_ARRAY8_NV                           = &H8658???
%GL_VERTEX_ATTRIB_ARRAY9_NV                           = &H8659???
%GL_VERTEX_ATTRIB_ARRAY10_NV                          = &H865A???
%GL_VERTEX_ATTRIB_ARRAY11_NV                          = &H865B???
%GL_VERTEX_ATTRIB_ARRAY12_NV                          = &H865C???
%GL_VERTEX_ATTRIB_ARRAY13_NV                          = &H865D???
%GL_VERTEX_ATTRIB_ARRAY14_NV                          = &H865E???
%GL_VERTEX_ATTRIB_ARRAY15_NV                          = &H865F???
%GL_MAP1_VERTEX_ATTRIB0_4_NV                          = &H8660???
%GL_MAP1_VERTEX_ATTRIB1_4_NV                          = &H8661???
%GL_MAP1_VERTEX_ATTRIB2_4_NV                          = &H8662???
%GL_MAP1_VERTEX_ATTRIB3_4_NV                          = &H8663???
%GL_MAP1_VERTEX_ATTRIB4_4_NV                          = &H8664???
%GL_MAP1_VERTEX_ATTRIB5_4_NV                          = &H8665???
%GL_MAP1_VERTEX_ATTRIB6_4_NV                          = &H8666???
%GL_MAP1_VERTEX_ATTRIB7_4_NV                          = &H8667???
%GL_MAP1_VERTEX_ATTRIB8_4_NV                          = &H8668???
%GL_MAP1_VERTEX_ATTRIB9_4_NV                          = &H8669???
%GL_MAP1_VERTEX_ATTRIB10_4_NV                         = &H866A???
%GL_MAP1_VERTEX_ATTRIB11_4_NV                         = &H866B???
%GL_MAP1_VERTEX_ATTRIB12_4_NV                         = &H866C???
%GL_MAP1_VERTEX_ATTRIB13_4_NV                         = &H866D???
%GL_MAP1_VERTEX_ATTRIB14_4_NV                         = &H866E???
%GL_MAP1_VERTEX_ATTRIB15_4_NV                         = &H866F???
%GL_MAP2_VERTEX_ATTRIB0_4_NV                          = &H8670???
%GL_MAP2_VERTEX_ATTRIB1_4_NV                          = &H8671???
%GL_MAP2_VERTEX_ATTRIB2_4_NV                          = &H8672???
%GL_MAP2_VERTEX_ATTRIB3_4_NV                          = &H8673???
%GL_MAP2_VERTEX_ATTRIB4_4_NV                          = &H8674???
%GL_MAP2_VERTEX_ATTRIB5_4_NV                          = &H8675???
%GL_MAP2_VERTEX_ATTRIB6_4_NV                          = &H8676???
%GL_MAP2_VERTEX_ATTRIB7_4_NV                          = &H8677???
%GL_MAP2_VERTEX_ATTRIB8_4_NV                          = &H8678???
%GL_MAP2_VERTEX_ATTRIB9_4_NV                          = &H8679???
%GL_MAP2_VERTEX_ATTRIB10_4_NV                         = &H867A???
%GL_MAP2_VERTEX_ATTRIB11_4_NV                         = &H867B???
%GL_MAP2_VERTEX_ATTRIB12_4_NV                         = &H867C???
%GL_MAP2_VERTEX_ATTRIB13_4_NV                         = &H867D???
%GL_MAP2_VERTEX_ATTRIB14_4_NV                         = &H867E???
%GL_MAP2_VERTEX_ATTRIB15_4_NV                         = &H867F???
#ENDIF

#IF NOT %DEF(%GL_SGIX_texture_coordinate_clamp)
%GL_TEXTURE_MAX_CLAMP_S_SGIX                          = &H8369???
%GL_TEXTURE_MAX_CLAMP_T_SGIX                          = &H836A???
%GL_TEXTURE_MAX_CLAMP_R_SGIX                          = &H836B???
#ENDIF

#IF NOT %DEF(%GL_SGIX_scalebias_hint)
%GL_SCALEBIAS_HINT_SGIX                               = &H8322???
#ENDIF

#IF NOT %DEF(%GL_OML_interlace)
%GL_INTERLACE_OML                                     = &H8980???
%GL_INTERLACE_READ_OML                                = &H8981???
#ENDIF

#IF NOT %DEF(%GL_OML_subsample)
%GL_FORMAT_SUBSAMPLE_24_24_OML                        = &H8982???
%GL_FORMAT_SUBSAMPLE_244_244_OML                      = &H8983???
#ENDIF

#IF NOT %DEF(%GL_OML_resample)
%GL_PACK_RESAMPLE_OML                                 = &H8984???
%GL_UNPACK_RESAMPLE_OML                               = &H8985???
%GL_RESAMPLE_REPLICATE_OML                            = &H8986???
%GL_RESAMPLE_ZERO_FILL_OML                            = &H8987???
%GL_RESAMPLE_AVERAGE_OML                              = &H8988???
%GL_RESAMPLE_DECIMATE_OML                             = &H8989???
#ENDIF

#IF NOT %DEF(%GL_NV_copy_depth_to_color)
%GL_DEPTH_STENCIL_TO_RGBA_NV                          = &H886E???
%GL_DEPTH_STENCIL_TO_BGRA_NV                          = &H886F???
#ENDIF

#IF NOT %DEF(%GL_ATI_envmap_bumpmap)
%GL_BUMP_ROT_MATRIX_ATI                               = &H8775???
%GL_BUMP_ROT_MATRIX_SIZE_ATI                          = &H8776???
%GL_BUMP_NUM_TEX_UNITS_ATI                            = &H8777???
%GL_BUMP_TEX_UNITS_ATI                                = &H8778???
%GL_DUDV_ATI                                          = &H8779???
%GL_DU8DV8_ATI                                        = &H877A???
%GL_BUMP_ENVMAP_ATI                                   = &H877B???
%GL_BUMP_TARGET_ATI                                   = &H877C???
#ENDIF

#IF NOT %DEF(%GL_ATI_fragment_shader)
%GL_FRAGMENT_SHADER_ATI                               = &H8920???
%GL_REG_0_ATI                                         = &H8921???
%GL_REG_1_ATI                                         = &H8922???
%GL_REG_2_ATI                                         = &H8923???
%GL_REG_3_ATI                                         = &H8924???
%GL_REG_4_ATI                                         = &H8925???
%GL_REG_5_ATI                                         = &H8926???
%GL_REG_6_ATI                                         = &H8927???
%GL_REG_7_ATI                                         = &H8928???
%GL_REG_8_ATI                                         = &H8929???
%GL_REG_9_ATI                                         = &H892A???
%GL_REG_10_ATI                                        = &H892B???
%GL_REG_11_ATI                                        = &H892C???
%GL_REG_12_ATI                                        = &H892D???
%GL_REG_13_ATI                                        = &H892E???
%GL_REG_14_ATI                                        = &H892F???
%GL_REG_15_ATI                                        = &H8930???
%GL_REG_16_ATI                                        = &H8931???
%GL_REG_17_ATI                                        = &H8932???
%GL_REG_18_ATI                                        = &H8933???
%GL_REG_19_ATI                                        = &H8934???
%GL_REG_20_ATI                                        = &H8935???
%GL_REG_21_ATI                                        = &H8936???
%GL_REG_22_ATI                                        = &H8937???
%GL_REG_23_ATI                                        = &H8938???
%GL_REG_24_ATI                                        = &H8939???
%GL_REG_25_ATI                                        = &H893A???
%GL_REG_26_ATI                                        = &H893B???
%GL_REG_27_ATI                                        = &H893C???
%GL_REG_28_ATI                                        = &H893D???
%GL_REG_29_ATI                                        = &H893E???
%GL_REG_30_ATI                                        = &H893F???
%GL_REG_31_ATI                                        = &H8940???
%GL_CON_0_ATI                                         = &H8941???
%GL_CON_1_ATI                                         = &H8942???
%GL_CON_2_ATI                                         = &H8943???
%GL_CON_3_ATI                                         = &H8944???
%GL_CON_4_ATI                                         = &H8945???
%GL_CON_5_ATI                                         = &H8946???
%GL_CON_6_ATI                                         = &H8947???
%GL_CON_7_ATI                                         = &H8948???
%GL_CON_8_ATI                                         = &H8949???
%GL_CON_9_ATI                                         = &H894A???
%GL_CON_10_ATI                                        = &H894B???
%GL_CON_11_ATI                                        = &H894C???
%GL_CON_12_ATI                                        = &H894D???
%GL_CON_13_ATI                                        = &H894E???
%GL_CON_14_ATI                                        = &H894F???
%GL_CON_15_ATI                                        = &H8950???
%GL_CON_16_ATI                                        = &H8951???
%GL_CON_17_ATI                                        = &H8952???
%GL_CON_18_ATI                                        = &H8953???
%GL_CON_19_ATI                                        = &H8954???
%GL_CON_20_ATI                                        = &H8955???
%GL_CON_21_ATI                                        = &H8956???
%GL_CON_22_ATI                                        = &H8957???
%GL_CON_23_ATI                                        = &H8958???
%GL_CON_24_ATI                                        = &H8959???
%GL_CON_25_ATI                                        = &H895A???
%GL_CON_26_ATI                                        = &H895B???
%GL_CON_27_ATI                                        = &H895C???
%GL_CON_28_ATI                                        = &H895D???
%GL_CON_29_ATI                                        = &H895E???
%GL_CON_30_ATI                                        = &H895F???
%GL_CON_31_ATI                                        = &H8960???
%GL_MOV_ATI                                           = &H8961???
%GL_ADD_ATI                                           = &H8963???
%GL_MUL_ATI                                           = &H8964???
%GL_SUB_ATI                                           = &H8965???
%GL_DOT3_ATI                                          = &H8966???
%GL_DOT4_ATI                                          = &H8967???
%GL_MAD_ATI                                           = &H8968???
%GL_LERP_ATI                                          = &H8969???
%GL_CND_ATI                                           = &H896A???
%GL_CND0_ATI                                          = &H896B???
%GL_DOT2_ADD_ATI                                      = &H896C???
%GL_SECONDARY_INTERPOLATOR_ATI                        = &H896D???
%GL_NUM_FRAGMENT_REGISTERS_ATI                        = &H896E???
%GL_NUM_FRAGMENT_CONSTANTS_ATI                        = &H896F???
%GL_NUM_PASSES_ATI                                    = &H8970???
%GL_NUM_INSTRUCTIONS_PER_PASS_ATI                     = &H8971???
%GL_NUM_INSTRUCTIONS_TOTAL_ATI                        = &H8972???
%GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI             = &H8973???
%GL_NUM_LOOPBACK_COMPONENTS_ATI                       = &H8974???
%GL_COLOR_ALPHA_PAIRING_ATI                           = &H8975???
%GL_SWIZZLE_STR_ATI                                   = &H8976???
%GL_SWIZZLE_STQ_ATI                                   = &H8977???
%GL_SWIZZLE_STR_DR_ATI                                = &H8978???
%GL_SWIZZLE_STQ_DQ_ATI                                = &H8979???
%GL_SWIZZLE_STRQ_ATI                                  = &H897A???
%GL_SWIZZLE_STRQ_DQ_ATI                               = &H897B???
%GL_RED_BIT_ATI                                       = &H00000001???
%GL_GREEN_BIT_ATI                                     = &H00000002???
%GL_BLUE_BIT_ATI                                      = &H00000004???
%GL_2X_BIT_ATI                                        = &H00000001???
%GL_4X_BIT_ATI                                        = &H00000002???
%GL_8X_BIT_ATI                                        = &H00000004???
%GL_HALF_BIT_ATI                                      = &H00000008???
%GL_QUARTER_BIT_ATI                                   = &H00000010???
%GL_EIGHTH_BIT_ATI                                    = &H00000020???
%GL_SATURATE_BIT_ATI                                  = &H00000040???
%GL_COMP_BIT_ATI                                      = &H00000002???
%GL_NEGATE_BIT_ATI                                    = &H00000004???
%GL_BIAS_BIT_ATI                                      = &H00000008???
#ENDIF

#IF NOT %DEF(%GL_ATI_pn_triangles)
%GL_PN_TRIANGLES_ATI                                  = &H87F0???
%GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI            = &H87F1???
%GL_PN_TRIANGLES_POINT_MODE_ATI                       = &H87F2???
%GL_PN_TRIANGLES_NORMAL_MODE_ATI                      = &H87F3???
%GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI                = &H87F4???
%GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI                = &H87F5???
%GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI                 = &H87F6???
%GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI               = &H87F7???
%GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI            = &H87F8???
#ENDIF

#IF NOT %DEF(%GL_ATI_vertex_array_object)
%GL_STATIC_ATI                                        = &H8760???
%GL_DYNAMIC_ATI                                       = &H8761???
%GL_PRESERVE_ATI                                      = &H8762???
%GL_DISCARD_ATI                                       = &H8763???
%GL_OBJECT_BUFFER_SIZE_ATI                            = &H8764???
%GL_OBJECT_BUFFER_USAGE_ATI                           = &H8765???
%GL_ARRAY_OBJECT_BUFFER_ATI                           = &H8766???
%GL_ARRAY_OBJECT_OFFSET_ATI                           = &H8767???
#ENDIF

#IF NOT %DEF(%GL_EXT_vertex_shader)
%GL_VERTEX_SHADER_EXT                                 = &H8780???
%GL_VERTEX_SHADER_BINDING_EXT                         = &H8781???
%GL_OP_INDEX_EXT                                      = &H8782???
%GL_OP_NEGATE_EXT                                     = &H8783???
%GL_OP_DOT3_EXT                                       = &H8784???
%GL_OP_DOT4_EXT                                       = &H8785???
%GL_OP_MUL_EXT                                        = &H8786???
%GL_OP_ADD_EXT                                        = &H8787???
%GL_OP_MADD_EXT                                       = &H8788???
%GL_OP_FRAC_EXT                                       = &H8789???
%GL_OP_MAX_EXT                                        = &H878A???
%GL_OP_MIN_EXT                                        = &H878B???
%GL_OP_SET_GE_EXT                                     = &H878C???
%GL_OP_SET_LT_EXT                                     = &H878D???
%GL_OP_CLAMP_EXT                                      = &H878E???
%GL_OP_FLOOR_EXT                                      = &H878F???
%GL_OP_ROUND_EXT                                      = &H8790???
%GL_OP_EXP_BASE_2_EXT                                 = &H8791???
%GL_OP_LOG_BASE_2_EXT                                 = &H8792???
%GL_OP_POWER_EXT                                      = &H8793???
%GL_OP_RECIP_EXT                                      = &H8794???
%GL_OP_RECIP_SQRT_EXT                                 = &H8795???
%GL_OP_SUB_EXT                                        = &H8796???
%GL_OP_CROSS_PRODUCT_EXT                              = &H8797???
%GL_OP_MULTIPLY_MATRIX_EXT                            = &H8798???
%GL_OP_MOV_EXT                                        = &H8799???
%GL_OUTPUT_VERTEX_EXT                                 = &H879A???
%GL_OUTPUT_COLOR0_EXT                                 = &H879B???
%GL_OUTPUT_COLOR1_EXT                                 = &H879C???
%GL_OUTPUT_TEXTURE_COORD0_EXT                         = &H879D???
%GL_OUTPUT_TEXTURE_COORD1_EXT                         = &H879E???
%GL_OUTPUT_TEXTURE_COORD2_EXT                         = &H879F???
%GL_OUTPUT_TEXTURE_COORD3_EXT                         = &H87A0???
%GL_OUTPUT_TEXTURE_COORD4_EXT                         = &H87A1???
%GL_OUTPUT_TEXTURE_COORD5_EXT                         = &H87A2???
%GL_OUTPUT_TEXTURE_COORD6_EXT                         = &H87A3???
%GL_OUTPUT_TEXTURE_COORD7_EXT                         = &H87A4???
%GL_OUTPUT_TEXTURE_COORD8_EXT                         = &H87A5???
%GL_OUTPUT_TEXTURE_COORD9_EXT                         = &H87A6???
%GL_OUTPUT_TEXTURE_COORD10_EXT                        = &H87A7???
%GL_OUTPUT_TEXTURE_COORD11_EXT                        = &H87A8???
%GL_OUTPUT_TEXTURE_COORD12_EXT                        = &H87A9???
%GL_OUTPUT_TEXTURE_COORD13_EXT                        = &H87AA???
%GL_OUTPUT_TEXTURE_COORD14_EXT                        = &H87AB???
%GL_OUTPUT_TEXTURE_COORD15_EXT                        = &H87AC???
%GL_OUTPUT_TEXTURE_COORD16_EXT                        = &H87AD???
%GL_OUTPUT_TEXTURE_COORD17_EXT                        = &H87AE???
%GL_OUTPUT_TEXTURE_COORD18_EXT                        = &H87AF???
%GL_OUTPUT_TEXTURE_COORD19_EXT                        = &H87B0???
%GL_OUTPUT_TEXTURE_COORD20_EXT                        = &H87B1???
%GL_OUTPUT_TEXTURE_COORD21_EXT                        = &H87B2???
%GL_OUTPUT_TEXTURE_COORD22_EXT                        = &H87B3???
%GL_OUTPUT_TEXTURE_COORD23_EXT                        = &H87B4???
%GL_OUTPUT_TEXTURE_COORD24_EXT                        = &H87B5???
%GL_OUTPUT_TEXTURE_COORD25_EXT                        = &H87B6???
%GL_OUTPUT_TEXTURE_COORD26_EXT                        = &H87B7???
%GL_OUTPUT_TEXTURE_COORD27_EXT                        = &H87B8???
%GL_OUTPUT_TEXTURE_COORD28_EXT                        = &H87B9???
%GL_OUTPUT_TEXTURE_COORD29_EXT                        = &H87BA???
%GL_OUTPUT_TEXTURE_COORD30_EXT                        = &H87BB???
%GL_OUTPUT_TEXTURE_COORD31_EXT                        = &H87BC???
%GL_OUTPUT_FOG_EXT                                    = &H87BD???
%GL_SCALAR_EXT                                        = &H87BE???
%GL_VECTOR_EXT                                        = &H87BF???
%GL_MATRIX_EXT                                        = &H87C0???
%GL_VARIANT_EXT                                       = &H87C1???
%GL_INVARIANT_EXT                                     = &H87C2???
%GL_LOCAL_CONSTANT_EXT                                = &H87C3???
%GL_LOCAL_EXT                                         = &H87C4???
%GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT                = &H87C5???
%GL_MAX_VERTEX_SHADER_VARIANTS_EXT                    = &H87C6???
%GL_MAX_VERTEX_SHADER_INVARIANTS_EXT                  = &H87C7???
%GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT             = &H87C8???
%GL_MAX_VERTEX_SHADER_LOCALS_EXT                      = &H87C9???
%GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT      = &H87CA???
%GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT          = &H87CB???
%GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT   = &H87CC???
%GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT        = &H87CD???
%GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT            = &H87CE???
%GL_VERTEX_SHADER_INSTRUCTIONS_EXT                    = &H87CF???
%GL_VERTEX_SHADER_VARIANTS_EXT                        = &H87D0???
%GL_VERTEX_SHADER_INVARIANTS_EXT                      = &H87D1???
%GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT                 = &H87D2???
%GL_VERTEX_SHADER_LOCALS_EXT                          = &H87D3???
%GL_VERTEX_SHADER_OPTIMIZED_EXT                       = &H87D4???
%GL_X_EXT                                             = &H87D5???
%GL_Y_EXT                                             = &H87D6???
%GL_Z_EXT                                             = &H87D7???
%GL_W_EXT                                             = &H87D8???
%GL_NEGATIVE_X_EXT                                    = &H87D9???
%GL_NEGATIVE_Y_EXT                                    = &H87DA???
%GL_NEGATIVE_Z_EXT                                    = &H87DB???
%GL_NEGATIVE_W_EXT                                    = &H87DC???
%GL_ZERO_EXT                                          = &H87DD???
%GL_ONE_EXT                                           = &H87DE???
%GL_NEGATIVE_ONE_EXT                                  = &H87DF???
%GL_NORMALIZED_RANGE_EXT                              = &H87E0???
%GL_FULL_RANGE_EXT                                    = &H87E1???
%GL_CURRENT_VERTEX_EXT                                = &H87E2???
%GL_MVP_MATRIX_EXT                                    = &H87E3???
%GL_VARIANT_VALUE_EXT                                 = &H87E4???
%GL_VARIANT_DATATYPE_EXT                              = &H87E5???
%GL_VARIANT_ARRAY_STRIDE_EXT                          = &H87E6???
%GL_VARIANT_ARRAY_TYPE_EXT                            = &H87E7???
%GL_VARIANT_ARRAY_EXT                                 = &H87E8???
%GL_VARIANT_ARRAY_POINTER_EXT                         = &H87E9???
%GL_INVARIANT_VALUE_EXT                               = &H87EA???
%GL_INVARIANT_DATATYPE_EXT                            = &H87EB???
%GL_LOCAL_CONSTANT_VALUE_EXT                          = &H87EC???
%GL_LOCAL_CONSTANT_DATATYPE_EXT                       = &H87ED???
#ENDIF

#IF NOT %DEF(%GL_ATI_vertex_streams)
%GL_MAX_VERTEX_STREAMS_ATI                            = &H876B???
%GL_VERTEX_STREAM0_ATI                                = &H876C???
%GL_VERTEX_STREAM1_ATI                                = &H876D???
%GL_VERTEX_STREAM2_ATI                                = &H876E???
%GL_VERTEX_STREAM3_ATI                                = &H876F???
%GL_VERTEX_STREAM4_ATI                                = &H8770???
%GL_VERTEX_STREAM5_ATI                                = &H8771???
%GL_VERTEX_STREAM6_ATI                                = &H8772???
%GL_VERTEX_STREAM7_ATI                                = &H8773???
%GL_VERTEX_SOURCE_ATI                                 = &H8774???
#ENDIF

#IF NOT %DEF(%GL_ATI_element_array)
%GL_ELEMENT_ARRAY_ATI                                 = &H8768???
%GL_ELEMENT_ARRAY_TYPE_ATI                            = &H8769???
%GL_ELEMENT_ARRAY_POINTER_ATI                         = &H876A???
#ENDIF

#IF NOT %DEF(%GL_SUN_mesh_array)
%GL_QUAD_MESH_SUN                                     = &H8614???
%GL_TRIANGLE_MESH_SUN                                 = &H8615???
#ENDIF

#IF NOT %DEF(%GL_SUN_slice_accum)
%GL_SLICE_ACCUM_SUN                                   = &H85CC???
#ENDIF

#IF NOT %DEF(%GL_NV_multisample_filter_hint)
%GL_MULTISAMPLE_FILTER_HINT_NV                        = &H8534???
#ENDIF

#IF NOT %DEF(%GL_NV_depth_clamp)
%GL_DEPTH_CLAMP_NV                                    = &H864F???
#ENDIF

#IF NOT %DEF(%GL_NV_occlusion_query)
%GL_PIXEL_COUNTER_BITS_NV                             = &H8864???
%GL_CURRENT_OCCLUSION_QUERY_ID_NV                     = &H8865???
%GL_PIXEL_COUNT_NV                                    = &H8866???
%GL_PIXEL_COUNT_AVAILABLE_NV                          = &H8867???
#ENDIF

#IF NOT %DEF(%GL_NV_point_sprite)
%GL_POINT_SPRITE_NV                                   = &H8861???
%GL_COORD_REPLACE_NV                                  = &H8862???
%GL_POINT_SPRITE_R_MODE_NV                            = &H8863???
#ENDIF

#IF NOT %DEF(%GL_NV_texture_shader3)
%GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV                   = &H8850???
%GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV             = &H8851???
%GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV            = &H8852???
%GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV      = &H8853???
%GL_OFFSET_HILO_TEXTURE_2D_NV                         = &H8854???
%GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV                  = &H8855???
%GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV              = &H8856???
%GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV       = &H8857???
%GL_DEPENDENT_HILO_TEXTURE_2D_NV                      = &H8858???
%GL_DEPENDENT_RGB_TEXTURE_3D_NV                       = &H8859???
%GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV                 = &H885A???
%GL_DOT_PRODUCT_PASS_THROUGH_NV                       = &H885B???
%GL_DOT_PRODUCT_TEXTURE_1D_NV                         = &H885C???
%GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV               = &H885D???
%GL_HILO8_NV                                          = &H885E???
%GL_SIGNED_HILO8_NV                                   = &H885F???
%GL_FORCE_BLUE_TO_ONE_NV                              = &H8860???
#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program1_1)
'#ENDIF

'#IF NOT %DEF(%GL_EXT_shadow_funcs)
'#ENDIF

#IF NOT %DEF(%GL_EXT_stencil_two_side)
%GL_STENCIL_TEST_TWO_SIDE_EXT                         = &H8910???
%GL_ACTIVE_STENCIL_FACE_EXT                           = &H8911???
#ENDIF

#IF NOT %DEF(%GL_ATI_text_fragment_shader)
%GL_TEXT_FRAGMENT_SHADER_ATI                          = &H8200???
#ENDIF

#IF NOT %DEF(%GL_APPLE_client_storage)
%GL_UNPACK_CLIENT_STORAGE_APPLE                       = &H85B2???
#ENDIF

#IF NOT %DEF(%GL_APPLE_element_array)
%GL_ELEMENT_ARRAY_APPLE                               = &H8A0C???
%GL_ELEMENT_ARRAY_TYPE_APPLE                          = &H8A0D???
%GL_ELEMENT_ARRAY_POINTER_APPLE                       = &H8A0E???
#ENDIF

#IF NOT %DEF(%GL_APPLE_fence)
%GL_DRAW_PIXELS_APPLE                                 = &H8A0A???
%GL_FENCE_APPLE                                       = &H8A0B???
#ENDIF

#IF NOT %DEF(%GL_APPLE_vertex_array_object)
%GL_VERTEX_ARRAY_BINDING_APPLE                        = &H85B5???
#ENDIF

#IF NOT %DEF(%GL_APPLE_vertex_array_range)
%GL_VERTEX_ARRAY_RANGE_APPLE                          = &H851D???
%GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE                   = &H851E???
%GL_VERTEX_ARRAY_STORAGE_HINT_APPLE                   = &H851F???
%GL_VERTEX_ARRAY_RANGE_POINTER_APPLE                  = &H8521???
%GL_STORAGE_CLIENT_APPLE                              = &H85B4???
%GL_STORAGE_CACHED_APPLE                              = &H85BE???
%GL_STORAGE_SHARED_APPLE                              = &H85BF???
#ENDIF

#IF NOT %DEF(%GL_APPLE_ycbcr_422)
%GL_YCBCR_422_APPLE                                   = &H85B9???
%GL_UNSIGNED_SHORT_8_8_APPLE                          = &H85BA???
%GL_UNSIGNED_SHORT_8_8_REV_APPLE                      = &H85BB???
#ENDIF

#IF NOT %DEF(%GL_S3_s3tc)
%GL_RGB_S3TC                                          = &H83A0???
%GL_RGB4_S3TC                                         = &H83A1???
%GL_RGBA_S3TC                                         = &H83A2???
%GL_RGBA4_S3TC                                        = &H83A3???
%GL_RGBA_DXT5_S3TC                                    = &H83A4???
%GL_RGBA4_DXT5_S3TC                                   = &H83A5???
#ENDIF

#IF NOT %DEF(%GL_ATI_draw_buffers)
%GL_MAX_DRAW_BUFFERS_ATI                              = &H8824???
%GL_DRAW_BUFFER0_ATI                                  = &H8825???
%GL_DRAW_BUFFER1_ATI                                  = &H8826???
%GL_DRAW_BUFFER2_ATI                                  = &H8827???
%GL_DRAW_BUFFER3_ATI                                  = &H8828???
%GL_DRAW_BUFFER4_ATI                                  = &H8829???
%GL_DRAW_BUFFER5_ATI                                  = &H882A???
%GL_DRAW_BUFFER6_ATI                                  = &H882B???
%GL_DRAW_BUFFER7_ATI                                  = &H882C???
%GL_DRAW_BUFFER8_ATI                                  = &H882D???
%GL_DRAW_BUFFER9_ATI                                  = &H882E???
%GL_DRAW_BUFFER10_ATI                                 = &H882F???
%GL_DRAW_BUFFER11_ATI                                 = &H8830???
%GL_DRAW_BUFFER12_ATI                                 = &H8831???
%GL_DRAW_BUFFER13_ATI                                 = &H8832???
%GL_DRAW_BUFFER14_ATI                                 = &H8833???
%GL_DRAW_BUFFER15_ATI                                 = &H8834???
#ENDIF

#IF NOT %DEF(%GL_ATI_pixel_format_float)
%GL_TYPE_RGBA_FLOAT_ATI                               = &H8820???   ' Renamed in version 76 - see below
%GL_RGBA_FLOAT_MODE_ATI                               = &H8820???
%GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI                   = &H8835???
#ENDIF

#IF NOT %DEF(%GL_ATI_texture_env_combine3)
%GL_MODULATE_ADD_ATI                                  = &H8744???
%GL_MODULATE_SIGNED_ADD_ATI                           = &H8745???
%GL_MODULATE_SUBTRACT_ATI                             = &H8746???
#ENDIF

#IF NOT %DEF(%GL_ATI_texture_float)
%GL_RGBA_FLOAT32_ATI                                  = &H8814???
%GL_RGB_FLOAT32_ATI                                   = &H8815???
%GL_ALPHA_FLOAT32_ATI                                 = &H8816???
%GL_INTENSITY_FLOAT32_ATI                             = &H8817???
%GL_LUMINANCE_FLOAT32_ATI                             = &H8818???
%GL_LUMINANCE_ALPHA_FLOAT32_ATI                       = &H8819???
%GL_RGBA_FLOAT16_ATI                                  = &H881A???
%GL_RGB_FLOAT16_ATI                                   = &H881B???
%GL_ALPHA_FLOAT16_ATI                                 = &H881C???
%GL_INTENSITY_FLOAT16_ATI                             = &H881D???
%GL_LUMINANCE_FLOAT16_ATI                             = &H881E???
%GL_LUMINANCE_ALPHA_FLOAT16_ATI                       = &H881F???
#ENDIF

#IF NOT %DEF(%GL_NV_float_buffer)
%GL_FLOAT_R_NV                                        = &H8880???
%GL_FLOAT_RG_NV                                       = &H8881???
%GL_FLOAT_RGB_NV                                      = &H8882???
%GL_FLOAT_RGBA_NV                                     = &H8883???
%GL_FLOAT_R16_NV                                      = &H8884???
%GL_FLOAT_R32_NV                                      = &H8885???
%GL_FLOAT_RG16_NV                                     = &H8886???
%GL_FLOAT_RG32_NV                                     = &H8887???
%GL_FLOAT_RGB16_NV                                    = &H8888???
%GL_FLOAT_RGB32_NV                                    = &H8889???
%GL_FLOAT_RGBA16_NV                                   = &H888A???
%GL_FLOAT_RGBA32_NV                                   = &H888B???
%GL_TEXTURE_FLOAT_COMPONENTS_NV                       = &H888C???
%GL_FLOAT_CLEAR_COLOR_VALUE_NV                        = &H888D???
%GL_FLOAT_RGBA_MODE_NV                                = &H888E???
#ENDIF

#IF NOT %DEF(%GL_NV_fragment_program)
%GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV          = &H8868???
%GL_FRAGMENT_PROGRAM_NV                               = &H8870???
%GL_MAX_TEXTURE_COORDS_NV                             = &H8871???
%GL_MAX_TEXTURE_IMAGE_UNITS_NV                        = &H8872???
%GL_FRAGMENT_PROGRAM_BINDING_NV                       = &H8873???
%GL_PROGRAM_ERROR_STRING_NV                           = &H8874???
#ENDIF

#IF NOT %DEF(%GL_NV_half_float)
%GL_HALF_FLOAT_NV                                     = &H140B???
#ENDIF

#IF NOT %DEF(%GL_NV_pixel_data_range)
%GL_WRITE_PIXEL_DATA_RANGE_NV                         = &H8878???
%GL_READ_PIXEL_DATA_RANGE_NV                          = &H8879???
%GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV                  = &H887A???
%GL_READ_PIXEL_DATA_RANGE_LENGTH_NV                   = &H887B???
%GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV                 = &H887C???
%GL_READ_PIXEL_DATA_RANGE_POINTER_NV                  = &H887D???
#ENDIF

#IF NOT %DEF(%GL_NV_primitive_restart)
%GL_PRIMITIVE_RESTART_NV                              = &H8558???
%GL_PRIMITIVE_RESTART_INDEX_NV                        = &H8559???
#ENDIF

#IF NOT %DEF(%GL_NV_texture_expand_normal)
%GL_TEXTURE_UNSIGNED_REMAP_MODE_NV                    = &H888F???
#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program2)
'#ENDIF

'#IF NOT %DEF(%GL_ATI_map_object_buffer)
'#ENDIF

#IF NOT %DEF(%GL_ATI_separate_stencil)
%GL_STENCIL_BACK_FUNC_ATI                             = &H8800???
%GL_STENCIL_BACK_FAIL_ATI                             = &H8801???
%GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI                  = &H8802???
%GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI                  = &H8803???
#ENDIF

'#IF NOT %DEF(%GL_ATI_vertex_attrib_array_object)
'#ENDIF

'#IF NOT %DEF(%GL_ATI_vertex_attrib_array_object)
'#ENDIF

'#IF NOT %DEF(%GL_OES_byte_coordinates)
'#ENDIF

#IF NOT %DEF(%GL_OES_fixed_point)
%GL_FIXED_OES                      = &H140C???
#ENDIF

'#IF NOT %DEF(%GL_OES_single_precision)
'#ENDIF

#IF NOT %DEF(%GL_OES_compressed_paletted_texture)
%GL_PALETTE4_RGB8_OES              = &H8B90???
%GL_PALETTE4_RGBA8_OES             = &H8B91???
%GL_PALETTE4_R5_G6_B5_OES          = &H8B92???
%GL_PALETTE4_RGBA4_OES             = &H8B93???
%GL_PALETTE4_RGB5_A1_OES           = &H8B94???
%GL_PALETTE8_RGB8_OES              = &H8B95???
%GL_PALETTE8_RGBA8_OES             = &H8B96???
%GL_PALETTE8_R5_G6_B5_OES          = &H8B97???
%GL_PALETTE8_RGBA4_OES             = &H8B98???
%GL_PALETTE8_RGB5_A1_OES           = &H8B99???
#ENDIF

#IF NOT %DEF(%GL_OES_read_format)
%GL_IMPLEMENTATION_COLOR_READ_TYPE_OES                = &H8B9A???
%GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES              = &H8B9B???
#ENDIF

'#IF NOT %DEF(%GL_OES_query_matrix)
'#ENDIF

#IF NOT %DEF(%GL_EXT_depth_bounds_test)
%GL_DEPTH_BOUNDS_TEST_EXT                             = &H8890???
%GL_DEPTH_BOUNDS_EXT                                  = &H8891???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_mirror_clamp)
%GL_MIRROR_CLAMP_EXT                                  = &H8742???
%GL_MIRROR_CLAMP_TO_EDGE_EXT                          = &H8743???
%GL_MIRROR_CLAMP_TO_BORDER_EXT                        = &H8912???
#ENDIF

#IF NOT %DEF(%GL_EXT_blend_equation_separate)
%GL_BLEND_EQUATION_RGB_EXT                            = &H8009???
%GL_BLEND_EQUATION_ALPHA_EXT                          = &H883D???
#ENDIF

#IF NOT %DEF(%GL_MESA_pack_invert)
%GL_PACK_INVERT_MESA                                  = &H8758???
#ENDIF

#IF NOT %DEF(%GL_MESA_ycbcr_texture)
%GL_UNSIGNED_SHORT_8_8_MESA                           = &H85BA???
%GL_UNSIGNED_SHORT_8_8_REV_MESA                       = &H85BB???
%GL_YCBCR_MESA                                        = &H8757???
#ENDIF

#IF NOT %DEF(%GL_EXT_pixel_buffer_object)
%GL_PIXEL_PACK_BUFFER_EXT                             = &H88EB???
%GL_PIXEL_UNPACK_BUFFER_EXT                           = &H88EC???
%GL_PIXEL_PACK_BUFFER_BINDING_EXT                     = &H88ED???
%GL_PIXEL_UNPACK_BUFFER_BINDING_EXT                   = &H88EF???
#ENDIF

#IF NOT %DEF(%GL_NV_fragment_program_option)
#ENDIF

#IF NOT %DEF(%GL_NV_fragment_program2)
%GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV                  = &H88F4???
%GL_MAX_PROGRAM_CALL_DEPTH_NV                         = &H88F5???
%GL_MAX_PROGRAM_IF_DEPTH_NV                           = &H88F6???
%GL_MAX_PROGRAM_LOOP_DEPTH_NV                         = &H88F7???
%GL_MAX_PROGRAM_LOOP_COUNT_NV                         = &H88F8???
#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program2_option)
'' /* reuse %GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV
'' /* reuse %GL_MAX_PROGRAM_CALL_DEPTH_NV
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program3)
'' /* reuse %GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB
'#ENDIF

#IF NOT %DEF(%GL_EXT_framebuffer_object)
%GL_INVALID_FRAMEBUFFER_OPERATION_EXT                 = &H0506???
%GL_MAX_RENDERBUFFER_SIZE_EXT                         = &H84E8???
%GL_FRAMEBUFFER_BINDING_EXT                           = &H8CA6???
%GL_RENDERBUFFER_BINDING_EXT                          = &H8CA7???
%GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT            = &H8CD0???
%GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT            = &H8CD1???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT          = &H8CD2???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT  = &H8CD3???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT     = &H8CD4???
%GL_FRAMEBUFFER_COMPLETE_EXT                          = &H8CD5???
%GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT             = &H8CD6???
%GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT     = &H8CD7???
%GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT             = &H8CD9???
%GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT                = &H8CDA???
%GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT            = &H8CDB???
%GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT            = &H8CDC???
%GL_FRAMEBUFFER_UNSUPPORTED_EXT                       = &H8CDD???
%GL_MAX_COLOR_ATTACHMENTS_EXT                         = &H8CDF???
%GL_COLOR_ATTACHMENT0_EXT                             = &H8CE0???
%GL_COLOR_ATTACHMENT1_EXT                             = &H8CE1???
%GL_COLOR_ATTACHMENT2_EXT                             = &H8CE2???
%GL_COLOR_ATTACHMENT3_EXT                             = &H8CE3???
%GL_COLOR_ATTACHMENT4_EXT                             = &H8CE4???
%GL_COLOR_ATTACHMENT5_EXT                             = &H8CE5???
%GL_COLOR_ATTACHMENT6_EXT                             = &H8CE6???
%GL_COLOR_ATTACHMENT7_EXT                             = &H8CE7???
%GL_COLOR_ATTACHMENT8_EXT                             = &H8CE8???
%GL_COLOR_ATTACHMENT9_EXT                             = &H8CE9???
%GL_COLOR_ATTACHMENT10_EXT                            = &H8CEA???
%GL_COLOR_ATTACHMENT11_EXT                            = &H8CEB???
%GL_COLOR_ATTACHMENT12_EXT                            = &H8CEC???
%GL_COLOR_ATTACHMENT13_EXT                            = &H8CED???
%GL_COLOR_ATTACHMENT14_EXT                            = &H8CEE???
%GL_COLOR_ATTACHMENT15_EXT                            = &H8CEF???
%GL_DEPTH_ATTACHMENT_EXT                              = &H8D00???
%GL_STENCIL_ATTACHMENT_EXT                            = &H8D20???
%GL_FRAMEBUFFER_EXT                                   = &H8D40???
%GL_RENDERBUFFER_EXT                                  = &H8D41???
%GL_RENDERBUFFER_WIDTH_EXT                            = &H8D42???
%GL_RENDERBUFFER_HEIGHT_EXT                           = &H8D43???
%GL_RENDERBUFFER_INTERNAL_FORMAT_EXT                  = &H8D44???
%GL_STENCIL_INDEX1_EXT                                = &H8D46???
%GL_STENCIL_INDEX4_EXT                                = &H8D47???
%GL_STENCIL_INDEX8_EXT                                = &H8D48???
%GL_STENCIL_INDEX16_EXT                               = &H8D49???
%GL_RENDERBUFFER_RED_SIZE_EXT                         = &H8D50???
%GL_RENDERBUFFER_GREEN_SIZE_EXT                       = &H8D51???
%GL_RENDERBUFFER_BLUE_SIZE_EXT                        = &H8D52???
%GL_RENDERBUFFER_ALPHA_SIZE_EXT                       = &H8D53???
%GL_RENDERBUFFER_DEPTH_SIZE_EXT                       = &H8D54???
%GL_RENDERBUFFER_STENCIL_SIZE_EXT                     = &H8D55???
#ENDIF

'#IF NOT %DEF(%GL_GREMEDY_string_marker)
'#ENDIF

#IF NOT %DEF(%GL_EXT_packed_depth_stencil)
%GL_DEPTH_STENCIL_EXT                                 = &H84F9???
%GL_UNSIGNED_INT_24_8_EXT                             = &H84FA???
%GL_DEPTH24_STENCIL8_EXT                              = &H88F0???
%GL_TEXTURE_STENCIL_SIZE_EXT                          = &H88F1???
#ENDIF

#IF NOT %DEF(%GL_EXT_stencil_clear_tag)
%GL_STENCIL_TAG_BITS_EXT                              = &H88F2???
%GL_STENCIL_CLEAR_TAG_VALUE_EXT                       = &H88F3???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_sRGB)
%GL_SRGB_EXT                                          = &H8C40???
%GL_SRGB8_EXT                                         = &H8C41???
%GL_SRGB_ALPHA_EXT                                    = &H8C42???
%GL_SRGB8_ALPHA8_EXT                                  = &H8C43???
%GL_SLUMINANCE_ALPHA_EXT                              = &H8C44???
%GL_SLUMINANCE8_ALPHA8_EXT                            = &H8C45???
%GL_SLUMINANCE_EXT                                    = &H8C46???
%GL_SLUMINANCE8_EXT                                   = &H8C47???
%GL_COMPRESSED_SRGB_EXT                               = &H8C48???
%GL_COMPRESSED_SRGB_ALPHA_EXT                         = &H8C49???
%GL_COMPRESSED_SLUMINANCE_EXT                         = &H8C4A???
%GL_COMPRESSED_SLUMINANCE_ALPHA_EXT                   = &H8C4B???
%GL_COMPRESSED_SRGB_S3TC_DXT1_EXT                     = &H8C4C???
%GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT               = &H8C4D???
%GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT               = &H8C4E???
%GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT               = &H8C4F???
#ENDIF

#IF NOT %DEF(%GL_EXT_framebuffer_blit)
%GL_READ_FRAMEBUFFER_EXT                              = &H8CA8???
%GL_DRAW_FRAMEBUFFER_EXT                              = &H8CA9???
%GL_READ_FRAMEBUFFER_BINDING_EXT                      = &H8CA6???
%GL_DRAW_FRAMEBUFFER_BINDING_EXT                      = &H8CAA???
#ENDIF

#IF NOT %DEF(%GL_EXT_framebuffer_multisample)
%GL_RENDERBUFFER_SAMPLES_EXT                          = &H8CAB???
%GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT            = &H8D56???
%GL_MAX_SAMPLES_EXT                                   = &H8D57???
#ENDIF

#IF NOT %DEF(%GL_MESAX_texture_stack)
%GL_TEXTURE_1D_STACK_MESAX                            = &H8759???
%GL_TEXTURE_2D_STACK_MESAX                            = &H875A???
%GL_PROXY_TEXTURE_1D_STACK_MESAX                      = &H875B???
%GL_PROXY_TEXTURE_2D_STACK_MESAX                      = &H875C???
%GL_TEXTURE_1D_STACK_BINDING_MESAX                    = &H875D???
%GL_TEXTURE_2D_STACK_BINDING_MESAX                    = &H875E???
#ENDIF

#IF NOT %DEF(%GL_EXT_timer_query)
%GL_TIME_ELAPSED_EXT                                  = &H88BF???
#ENDIF

'#IF NOT %DEF(%GL_EXT_gpu_program_parameters)
'#ENDIF

#IF NOT %DEF(%GL_APPLE_flush_buffer_range)
%GL_BUFFER_SERIALIZED_MODIFY_APPLE                    = &H8A12???
%GL_BUFFER_FLUSHING_UNMAP_APPLE                       = &H8A13???
#ENDIF

#IF NOT %DEF(%GL_NV_gpu_program4)
%GL_MIN_PROGRAM_TEXEL_OFFSET_NV                       = &H8904???
%GL_MAX_PROGRAM_TEXEL_OFFSET_NV                       = &H8905???
%GL_PROGRAM_ATTRIB_COMPONENTS_NV                      = &H8906???
%GL_PROGRAM_RESULT_COMPONENTS_NV                      = &H8907???
%GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV                  = &H8908???
%GL_MAX_PROGRAM_RESULT_COMPONENTS_NV                  = &H8909???
%GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV                    = &H8DA5???
%GL_MAX_PROGRAM_GENERIC_RESULTS_NV                    = &H8DA6???
#ENDIF

#IF NOT %DEF(%GL_NV_geometry_program4)
%GL_LINES_ADJACENCY_EXT                               = &H000A???
%GL_LINE_STRIP_ADJACENCY_EXT                          = &H000B???
%GL_TRIANGLES_ADJACENCY_EXT                           = &H000C???
%GL_TRIANGLE_STRIP_ADJACENCY_EXT                      = &H000D???
%GL_GEOMETRY_PROGRAM_NV                               = &H8C26???
%GL_MAX_PROGRAM_OUTPUT_VERTICES_NV                    = &H8C27???
%GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV            = &H8C28???
%GL_GEOMETRY_VERTICES_OUT_EXT                         = &H8DDA???
%GL_GEOMETRY_INPUT_TYPE_EXT                           = &H8DDB???
%GL_GEOMETRY_OUTPUT_TYPE_EXT                          = &H8DDC???
%GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT              = &H8C29???
%GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT                = &H8DA7???
%GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT          = &H8DA8???
%GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT            = &H8DA9???
%GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT          = &H8CD4???
%GL_PROGRAM_POINT_SIZE_EXT                            = &H8642???
#ENDIF

#IF NOT %DEF(%GL_EXT_geometry_shader4)
%GL_GEOMETRY_SHADER_EXT                               = &H8DD9???
' /* reuse %GL_GEOMETRY_VERTICES_OUT_EXT
' /* reuse %GL_GEOMETRY_INPUT_TYPE_EXT
' /* reuse %GL_GEOMETRY_OUTPUT_TYPE_EXT
' /* reuse %GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT
%GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT               = &H8DDD???
%GL_MAX_VERTEX_VARYING_COMPONENTS_EXT                 = &H8DDE???
%GL_MAX_VARYING_COMPONENTS_EXT                        = &H8B4B???
%GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT               = &H8DDF???
%GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT                  = &H8DE0???
%GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT          = &H8DE1???
' /* reuse %GL_LINES_ADJACENCY_EXT
' /* reuse %GL_LINE_STRIP_ADJACENCY_EXT
' /* reuse %GL_TRIANGLES_ADJACENCY_EXT
' /* reuse %GL_TRIANGLE_STRIP_ADJACENCY_EXT
' /* reuse %GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT
' /* reuse %GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT
' /* reuse %GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT
' /* reuse %GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT
' /* reuse %GL_PROGRAM_POINT_SIZE_EXT
#ENDIF

#IF NOT %DEF(%GL_NV_vertex_program4)
%GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV                    = &H88FD???
#ENDIF

#IF NOT %DEF(%GL_EXT_gpu_shader4)
%GL_SAMPLER_1D_ARRAY_EXT                              = &H8DC0???
%GL_SAMPLER_2D_ARRAY_EXT                              = &H8DC1???
%GL_SAMPLER_BUFFER_EXT                                = &H8DC2???
%GL_SAMPLER_1D_ARRAY_SHADOW_EXT                       = &H8DC3???
%GL_SAMPLER_2D_ARRAY_SHADOW_EXT                       = &H8DC4???
%GL_SAMPLER_CUBE_SHADOW_EXT                           = &H8DC5???
%GL_UNSIGNED_INT_VEC2_EXT                             = &H8DC6???
%GL_UNSIGNED_INT_VEC3_EXT                             = &H8DC7???
%GL_UNSIGNED_INT_VEC4_EXT                             = &H8DC8???
%GL_INT_SAMPLER_1D_EXT                                = &H8DC9???
%GL_INT_SAMPLER_2D_EXT                                = &H8DCA???
%GL_INT_SAMPLER_3D_EXT                                = &H8DCB???
%GL_INT_SAMPLER_CUBE_EXT                              = &H8DCC???
%GL_INT_SAMPLER_2D_RECT_EXT                           = &H8DCD???
%GL_INT_SAMPLER_1D_ARRAY_EXT                          = &H8DCE???
%GL_INT_SAMPLER_2D_ARRAY_EXT                          = &H8DCF???
%GL_INT_SAMPLER_BUFFER_EXT                            = &H8DD0???
%GL_UNSIGNED_INT_SAMPLER_1D_EXT                       = &H8DD1???
%GL_UNSIGNED_INT_SAMPLER_2D_EXT                       = &H8DD2???
%GL_UNSIGNED_INT_SAMPLER_3D_EXT                       = &H8DD3???
%GL_UNSIGNED_INT_SAMPLER_CUBE_EXT                     = &H8DD4???
%GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT                  = &H8DD5???
%GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT                 = &H8DD6???
%GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT                 = &H8DD7???
%GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT                   = &H8DD8???
#ENDIF

'#IF NOT %DEF(%GL_EXT_draw_instanced)
'#ENDIF

#IF NOT %DEF(%GL_EXT_packed_float)
%GL_R11F_G11F_B10F_EXT                                = &H8C3A???
%GL_UNSIGNED_INT_10F_11F_11F_REV_EXT                  = &H8C3B???
%GL_RGBA_SIGNED_COMPONENTS_EXT                        = &H8C3C???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_array)
%GL_TEXTURE_1D_ARRAY_EXT                              = &H8C18???
%GL_PROXY_TEXTURE_1D_ARRAY_EXT                        = &H8C19???
%GL_TEXTURE_2D_ARRAY_EXT                              = &H8C1A???
%GL_PROXY_TEXTURE_2D_ARRAY_EXT                        = &H8C1B???
%GL_TEXTURE_BINDING_1D_ARRAY_EXT                      = &H8C1C???
%GL_TEXTURE_BINDING_2D_ARRAY_EXT                      = &H8C1D???
%GL_MAX_ARRAY_TEXTURE_LAYERS_EXT                      = &H88FF???
%GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT                  = &H884E???
' /* reuse %GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_buffer_object)
%GL_TEXTURE_BUFFER_EXT                                = &H8C2A???
%GL_MAX_TEXTURE_BUFFER_SIZE_EXT                       = &H8C2B???
%GL_TEXTURE_BINDING_BUFFER_EXT                        = &H8C2C???
%GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT             = &H8C2D???
%GL_TEXTURE_BUFFER_FORMAT_EXT                         = &H8C2E???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_compression_latc)
%GL_COMPRESSED_LUMINANCE_LATC1_EXT                    = &H8C70???
%GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT             = &H8C71???
%GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT              = &H8C72???
%GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT       = &H8C73???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_compression_rgtc)
%GL_COMPRESSED_RED_RGTC1_EXT                          = &H8DBB???
%GL_COMPRESSED_SIGNED_RED_RGTC1_EXT                   = &H8DBC???
%GL_COMPRESSED_RED_GREEN_RGTC2_EXT                    = &H8DBD???
%GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT             = &H8DBE???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_shared_exponent)
%GL_RGB9_E5_EXT                                       = &H8C3D???
%GL_UNSIGNED_INT_5_9_9_9_REV_EXT                      = &H8C3E???
%GL_TEXTURE_SHARED_SIZE_EXT                           = &H8C3F???
#ENDIF

#IF NOT %DEF(%GL_NV_depth_buffer_float)
%GL_DEPTH_COMPONENT32F_NV                             = &H8DAB???
%GL_DEPTH32F_STENCIL8_NV                              = &H8DAC???
%GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV                 = &H8DAD???
%GL_DEPTH_BUFFER_FLOAT_MODE_NV                        = &H8DAF???
#ENDIF

'#IF NOT %DEF(%GL_NV_fragment_program4)
'#ENDIF

#IF NOT %DEF(%GL_NV_framebuffer_multisample_coverage)
%GL_RENDERBUFFER_COVERAGE_SAMPLES_NV                  = &H8CAB???
%GL_RENDERBUFFER_COLOR_SAMPLES_NV                     = &H8E10???
%GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV                 = &H8E11???
%GL_MULTISAMPLE_COVERAGE_MODES_NV                     = &H8E12???
#ENDIF

#IF NOT %DEF(%GL_EXT_framebuffer_sRGB)
%GL_FRAMEBUFFER_SRGB_EXT                              = &H8DB9???
%GL_FRAMEBUFFER_SRGB_CAPABLE_EXT                      = &H8DBA???
#ENDIF

'#IF NOT %DEF(%GL_NV_geometry_shader4)
'#ENDIF

#IF NOT %DEF(%GL_NV_parameter_buffer_object)
%GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV          = &H8DA0???
%GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV              = &H8DA1???
%GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV                = &H8DA2???
%GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV              = &H8DA3???
%GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV              = &H8DA4???
#ENDIF

'#IF NOT %DEF(%GL_EXT_draw_buffers2)
'#ENDIF

#IF NOT %DEF(%GL_NV_transform_feedback)
%GL_BACK_PRIMARY_COLOR_NV                             = &H8C77???
%GL_BACK_SECONDARY_COLOR_NV                           = &H8C78???
%GL_TEXTURE_COORD_NV                                  = &H8C79???
%GL_CLIP_DISTANCE_NV                                  = &H8C7A???
%GL_VERTEX_ID_NV                                      = &H8C7B???
%GL_PRIMITIVE_ID_NV                                   = &H8C7C???
%GL_GENERIC_ATTRIB_NV                                 = &H8C7D???
%GL_TRANSFORM_FEEDBACK_ATTRIBS_NV                     = &H8C7E???
%GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV                 = &H8C7F???
%GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV     = &H8C80???
%GL_ACTIVE_VARYINGS_NV                                = &H8C81???
%GL_ACTIVE_VARYING_MAX_LENGTH_NV                      = &H8C82???
%GL_TRANSFORM_FEEDBACK_VARYINGS_NV                    = &H8C83???
%GL_TRANSFORM_FEEDBACK_BUFFER_START_NV                = &H8C84???
%GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV                 = &H8C85???
%GL_TRANSFORM_FEEDBACK_RECORD_NV                      = &H8C86???
%GL_PRIMITIVES_GENERATED_NV                           = &H8C87???
%GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV          = &H8C88???
%GL_RASTERIZER_DISCARD_NV                             = &H8C89???
%GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_ATTRIBS_NV     = &H8C8A???
%GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV        = &H8C8B???
%GL_INTERLEAVED_ATTRIBS_NV                            = &H8C8C???
%GL_SEPARATE_ATTRIBS_NV                               = &H8C8D???
%GL_TRANSFORM_FEEDBACK_BUFFER_NV                      = &H8C8E???
%GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV              = &H8C8F???
%GL_LAYER_NV                                          = &H8DAA???
%GL_NEXT_BUFFER_NV                                    = -2
%GL_SKIP_COMPONENTS4_NV                               = -3
%GL_SKIP_COMPONENTS3_NV                               = -4
%GL_SKIP_COMPONENTS2_NV                               = -5
%GL_SKIP_COMPONENTS1_NV                               = -6
#ENDIF

#IF NOT %DEF(%GL_EXT_bindable_uniform)
%GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT                  = &H8DE2???
%GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT                = &H8DE3???
%GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT                = &H8DE4???
%GL_MAX_BINDABLE_UNIFORM_SIZE_EXT                     = &H8DED???
%GL_UNIFORM_BUFFER_EXT                                = &H8DEE???
%GL_UNIFORM_BUFFER_BINDING_EXT                        = &H8DEF???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_integer)
%GL_RGBA32UI_EXT                                      = &H8D70???
%GL_RGB32UI_EXT                                       = &H8D71???
%GL_ALPHA32UI_EXT                                     = &H8D72???
%GL_INTENSITY32UI_EXT                                 = &H8D73???
%GL_LUMINANCE32UI_EXT                                 = &H8D74???
%GL_LUMINANCE_ALPHA32UI_EXT                           = &H8D75???
%GL_RGBA16UI_EXT                                      = &H8D76???
%GL_RGB16UI_EXT                                       = &H8D77???
%GL_ALPHA16UI_EXT                                     = &H8D78???
%GL_INTENSITY16UI_EXT                                 = &H8D79???
%GL_LUMINANCE16UI_EXT                                 = &H8D7A???
%GL_LUMINANCE_ALPHA16UI_EXT                           = &H8D7B???
%GL_RGBA8UI_EXT                                       = &H8D7C???
%GL_RGB8UI_EXT                                        = &H8D7D???
%GL_ALPHA8UI_EXT                                      = &H8D7E???
%GL_INTENSITY8UI_EXT                                  = &H8D7F???
%GL_LUMINANCE8UI_EXT                                  = &H8D80???
%GL_LUMINANCE_ALPHA8UI_EXT                            = &H8D81???
%GL_RGBA32I_EXT                                       = &H8D82???
%GL_RGB32I_EXT                                        = &H8D83???
%GL_ALPHA32I_EXT                                      = &H8D84???
%GL_INTENSITY32I_EXT                                  = &H8D85???
%GL_LUMINANCE32I_EXT                                  = &H8D86???
%GL_LUMINANCE_ALPHA32I_EXT                            = &H8D87???
%GL_RGBA16I_EXT                                       = &H8D88???
%GL_RGB16I_EXT                                        = &H8D89???
%GL_ALPHA16I_EXT                                      = &H8D8A???
%GL_INTENSITY16I_EXT                                  = &H8D8B???
%GL_LUMINANCE16I_EXT                                  = &H8D8C???
%GL_LUMINANCE_ALPHA16I_EXT                            = &H8D8D???
%GL_RGBA8I_EXT                                        = &H8D8E???
%GL_RGB8I_EXT                                         = &H8D8F???
%GL_ALPHA8I_EXT                                       = &H8D90???
%GL_INTENSITY8I_EXT                                   = &H8D91???
%GL_LUMINANCE8I_EXT                                   = &H8D92???
%GL_LUMINANCE_ALPHA8I_EXT                             = &H8D93???
%GL_RED_INTEGER_EXT                                   = &H8D94???
%GL_GREEN_INTEGER_EXT                                 = &H8D95???
%GL_BLUE_INTEGER_EXT                                  = &H8D96???
%GL_ALPHA_INTEGER_EXT                                 = &H8D97???
%GL_RGB_INTEGER_EXT                                   = &H8D98???
%GL_RGBA_INTEGER_EXT                                  = &H8D99???
%GL_BGR_INTEGER_EXT                                   = &H8D9A???
%GL_BGRA_INTEGER_EXT                                  = &H8D9B???
%GL_LUMINANCE_INTEGER_EXT                             = &H8D9C???
%GL_LUMINANCE_ALPHA_INTEGER_EXT                       = &H8D9D???
%GL_RGBA_INTEGER_MODE_EXT                             = &H8D9E???
#ENDIF

'#IF NOT %DEF(%GL_GREMEDY_frame_terminator)
'#ENDIF

#IF NOT %DEF(%GL_NV_conditional_render)
%GL_QUERY_WAIT_NV                                     = &H8E13???
%GL_QUERY_NO_WAIT_NV                                  = &H8E14???
%GL_QUERY_BY_REGION_WAIT_NV                           = &H8E15???
%GL_QUERY_BY_REGION_NO_WAIT_NV                        = &H8E16???
#ENDIF

#IF NOT %DEF(%GL_NV_present_video)
%GL_FRAME_NV                                          = &H8E26???
%GL_FIELDS_NV                                         = &H8E27???
%GL_CURRENT_TIME_NV                                   = &H8E28???
%GL_NUM_FILL_STREAMS_NV                               = &H8E29???
%GL_PRESENT_TIME_NV                                   = &H8E2A???
%GL_PRESENT_DURATION_NV                               = &H8E2B???
#ENDIF

#IF NOT %DEF(%GL_EXT_transform_feedback)
%GL_TRANSFORM_FEEDBACK_BUFFER_EXT                     = &H8C8E???
%GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT               = &H8C84???
%GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT                = &H8C85???
%GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT             = &H8C8F???
%GL_INTERLEAVED_ATTRIBS_EXT                           = &H8C8C???
%GL_SEPARATE_ATTRIBS_EXT                              = &H8C8D???
%GL_PRIMITIVES_GENERATED_EXT                          = &H8C87???
%GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT         = &H8C88???
%GL_RASTERIZER_DISCARD_EXT                            = &H8C89???
%GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = &H8C8A???
%GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT       = &H8C8B???
%GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT    = &H8C80???
%GL_TRANSFORM_FEEDBACK_VARYINGS_EXT                   = &H8C83???
%GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT                = &H8C7F???
%GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT         = &H8C76???
#ENDIF

#IF NOT %DEF(%GL_EXT_direct_state_access)
%GL_PROGRAM_MATRIX_EXT                                = &H8E2D???
%GL_TRANSPOSE_PROGRAM_MATRIX_EXT                      = &H8E2E???
%GL_PROGRAM_MATRIX_STACK_DEPTH_EXT                    = &H8E2F???
#ENDIF

'#IF NOT %DEF(%GL_EXT_vertex_array_bgra)
''/* reuse GL_BGRA */
'#ENDIF

#IF NOT %DEF(%GL_EXT_texture_swizzle)
%GL_TEXTURE_SWIZZLE_R_EXT                             = &H8E42???
%GL_TEXTURE_SWIZZLE_G_EXT                             = &H8E43???
%GL_TEXTURE_SWIZZLE_B_EXT                             = &H8E44???
%GL_TEXTURE_SWIZZLE_A_EXT                             = &H8E45???
%GL_TEXTURE_SWIZZLE_RGBA_EXT                          = &H8E46???
#ENDIF

#IF NOT %DEF(%GL_NV_explicit_multisample)
%GL_SAMPLE_POSITION_NV                                = &H8E50???
%GL_SAMPLE_MASK_NV                                    = &H8E51???
%GL_SAMPLE_MASK_VALUE_NV                              = &H8E52???
%GL_TEXTURE_BINDING_RENDERBUFFER_NV                   = &H8E53???
%GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV        = &H8E54???
%GL_TEXTURE_RENDERBUFFER_NV                           = &H8E55???
%GL_SAMPLER_RENDERBUFFER_NV                           = &H8E56???
%GL_INT_SAMPLER_RENDERBUFFER_NV                       = &H8E57???
%GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV              = &H8E58???
%GL_MAX_SAMPLE_MASK_WORDS_NV                          = &H8E59???
#ENDIF

#IF NOT %DEF(%GL_NV_transform_feedback2)
%GL_TRANSFORM_FEEDBACK_NV                             = &H8E22???
%GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV               = &H8E23???
%GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV               = &H8E24???
%GL_TRANSFORM_FEEDBACK_BINDING_NV                     = &H8E25???
#ENDIF

#IF NOT %DEF(%GL_ATI_meminfo)
%GL_VBO_FREE_MEMORY_ATI                               = &H87FB???
%GL_TEXTURE_FREE_MEMORY_ATI                           = &H87FC???
%GL_RENDERBUFFER_FREE_MEMORY_ATI                      = &H87FD???
#ENDIF

#IF NOT %DEF(%GL_AMD_performance_monitor)
%GL_COUNTER_TYPE_AMD                                  = &H8BC0???
%GL_COUNTER_RANGE_AMD                                 = &H8BC1???
%GL_UNSIGNED_INT64_AMD                                = &H8BC2???
%GL_PERCENTAGE_AMD                                    = &H8BC3???
%GL_PERFMON_RESULT_AVAILABLE_AMD                      = &H8BC4???
%GL_PERFMON_RESULT_SIZE_AMD                           = &H8BC5???
%GL_PERFMON_RESULT_AMD                                = &H8BC6???
#ENDIF

'#IF NOT %DEF(%GL_AMD_texture_texture4)
'#ENDIF

#IF NOT %DEF(%GL_AMD_vertex_shader_tessellator)
%GL_SAMPLER_BUFFER_AMD                                = &H9001???
%GL_INT_SAMPLER_BUFFER_AMD                            = &H9002???
%GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD                   = &H9003???
%GL_TESSELLATION_MODE_AMD                             = &H9004???
%GL_TESSELLATION_FACTOR_AMD                           = &H9005???
%GL_DISCRETE_AMD                                      = &H9006???
%GL_CONTINUOUS_AMD                                    = &H9007???
#ENDIF

#IF NOT %DEF(%GL_EXT_provoking_vertex)
%GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT      = &H8E4C
%GL_FIRST_VERTEX_CONVENTION_EXT                       = &H8E4D
%GL_LAST_VERTEX_CONVENTION_EXT                        = &H8E4E
%GL_PROVOKING_VERTEX_EXT                              = &H8E4F
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_snorm)
%GL_ALPHA_SNORM                                       = &H9010???
%GL_LUMINANCE_SNORM                                   = &H9011???
%GL_LUMINANCE_ALPHA_SNORM                             = &H9012???
%GL_INTENSITY_SNORM                                   = &H9013???
%GL_ALPHA8_SNORM                                      = &H9014???
%GL_LUMINANCE8_SNORM                                  = &H9015???
%GL_LUMINANCE8_ALPHA8_SNORM                           = &H9016???
%GL_INTENSITY8_SNORM                                  = &H9017???
%GL_ALPHA16_SNORM                                     = &H9018???
%GL_LUMINANCE16_SNORM                                 = &H9019???
%GL_LUMINANCE16_ALPHA16_SNORM                         = &H901A???
%GL_INTENSITY16_SNORM                                 = &H901B???
'/* reuse GL_RED_SNORM */
'/* reuse GL_RG_SNORM */
'/* reuse GL_RGB_SNORM */
'/* reuse GL_RGBA_SNORM */
'/* reuse GL_R8_SNORM */
'/* reuse GL_RG8_SNORM */
'/* reuse GL_RGB8_SNORM */
'/* reuse GL_RGBA8_SNORM */
'/* reuse GL_R16_SNORM */
'/* reuse GL_RG16_SNORM */
'/* reuse GL_RGB16_SNORM */
'/* reuse GL_RGBA16_SNORM */
'/* reuse GL_SIGNED_NORMALIZED */
#ENDIF

'#IF NOT %DEF(%GL_AMD_draw_buffers_blend)
'#ENDIF

#IF NOT %DEF(%GL_APPLE_texture_range)
%GL_TEXTURE_RANGE_LENGTH_APPLE                        = &H85B7???
%GL_TEXTURE_RANGE_POINTER_APPLE                       = &H85B8???
%GL_TEXTURE_STORAGE_HINT_APPLE                        = &H85BC???
%GL_STORAGE_PRIVATE_APPLE                             = &H85BD???
'/* reuse GL_STORAGE_CACHED_APPLE */
'/* reuse GL_STORAGE_SHARED_APPLE */
#ENDIF

#IF NOT %DEF(%GL_APPLE_float_pixels)
%GL_HALF_APPLE                                        = &H140B???
%GL_RGBA_FLOAT32_APPLE                                = &H8814???
%GL_RGB_FLOAT32_APPLE                                 = &H8815???
%GL_ALPHA_FLOAT32_APPLE                               = &H8816???
%GL_INTENSITY_FLOAT32_APPLE                           = &H8817???
%GL_LUMINANCE_FLOAT32_APPLE                           = &H8818???
%GL_LUMINANCE_ALPHA_FLOAT32_APPLE                     = &H8819???
%GL_RGBA_FLOAT16_APPLE                                = &H881A???
%GL_RGB_FLOAT16_APPLE                                 = &H881B???
%GL_ALPHA_FLOAT16_APPLE                               = &H881C???
%GL_INTENSITY_FLOAT16_APPLE                           = &H881D???
%GL_LUMINANCE_FLOAT16_APPLE                           = &H881E???
%GL_LUMINANCE_ALPHA_FLOAT16_APPLE                     = &H881F???
%GL_COLOR_FLOAT_APPLE                                 = &H8A0F???
#ENDIF

#IF NOT %DEF(%GL_APPLE_vertex_program_evaluators)
%GL_VERTEX_ATTRIB_MAP1_APPLE                          = &H8A00???
%GL_VERTEX_ATTRIB_MAP2_APPLE                          = &H8A01???
%GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE                     = &H8A02???
%GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE                    = &H8A03???
%GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE                    = &H8A04???
%GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE                   = &H8A05???
%GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE                     = &H8A06???
%GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE                    = &H8A07???
%GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE                    = &H8A08???
%GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE                   = &H8A09???
#ENDIF

#IF NOT %DEF(%GL_APPLE_aux_depth_stencil)
%GL_AUX_DEPTH_STENCIL_APPLE                           = &H8A14???
#ENDIF

#IF NOT %DEF(%GL_APPLE_object_purgeable)
%GL_BUFFER_OBJECT_APPLE                               = &H85B3???
%GL_RELEASED_APPLE                                    = &H8A19???
%GL_VOLATILE_APPLE                                    = &H8A1A???
%GL_RETAINED_APPLE                                    = &H8A1B???
%GL_UNDEFINED_APPLE                                   = &H8A1C???
%GL_PURGEABLE_APPLE                                   = &H8A1D???
#ENDIF

#IF NOT %DEF(%GL_APPLE_row_bytes)
%GL_PACK_ROW_BYTES_APPLE                              = &H8A15???
%GL_UNPACK_ROW_BYTES_APPLE                            = &H8A16???
#ENDIF

#IF NOT %DEF(%GL_APPLE_rgb_422)
%GL_RGB_422_APPLE                                     = &H8A1F???
'/* reuse GL_UNSIGNED_SHORT_8_8_APPLE */
'/* reuse GL_UNSIGNED_SHORT_8_8_REV_APPLE */
#ENDIF

#IF NOT %DEF(%GL_NV_video_capture)
%GL_VIDEO_BUFFER_NV                                   = &H9020???
%GL_VIDEO_BUFFER_BINDING_NV                           = &H9021???
%GL_FIELD_UPPER_NV                                    = &H9022???
%GL_FIELD_LOWER_NV                                    = &H9023???
%GL_NUM_VIDEO_CAPTURE_STREAMS_NV                      = &H9024???
%GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV               = &H9025???
%GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV                 = &H9026???
%GL_LAST_VIDEO_CAPTURE_STATUS_NV                      = &H9027???
%GL_VIDEO_BUFFER_PITCH_NV                             = &H9028???
%GL_VIDEO_COLOR_CONVERSION_MATRIX_NV                  = &H9029???
%GL_VIDEO_COLOR_CONVERSION_MAX_NV                     = &H902A???
%GL_VIDEO_COLOR_CONVERSION_MIN_NV                     = &H902B???
%GL_VIDEO_COLOR_CONVERSION_OFFSET_NV                  = &H902C???
%GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV                   = &H902D???
%GL_PARTIAL_SUCCESS_NV                                = &H902E???
%GL_SUCCESS_NV                                        = &H902F???
%GL_FAILURE_NV                                        = &H9030???
%GL_YCBYCR8_422_NV                                    = &H9031???
%GL_YCBAYCR8A_4224_NV                                 = &H9032???
%GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV                     = &H9033???
%GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV          = &H9034???
%GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV                     = &H9035???
%GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV          = &H9036???
%GL_Z4Y12Z4CB12Z4CR12_444_NV                          = &H9037???
%GL_VIDEO_CAPTURE_FRAME_WIDTH_NV                      = &H9038???
%GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV                     = &H9039???
%GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV               = &H903A???
%GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV               = &H903B???
%GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV                   = &H903C???
#ENDIF

'#IF NOT %DEF(%GL_NV_copy_image)
'#ENDIF

#IF NOT %DEF(%GL_EXT_separate_shader_objects)
%GL_ACTIVE_PROGRAM_EXT                                = &H8B8D???
#ENDIF

'#IF NOT %DEF(%GL_NV_parameter_buffer_object2)
'#ENDIF

#IF NOT %DEF(%GL_NV_shader_buffer_load)
%GL_BUFFER_GPU_ADDRESS_NV                             = &H8F1D???
%GL_GPU_ADDRESS_NV                                    = &H8F34???
%GL_MAX_SHADER_BUFFER_ADDRESS_NV                      = &H8F35???
#ENDIF

#IF NOT %DEF(%GL_NV_vertex_buffer_unified_memory)
%GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV                    = &H8F1E???
%GL_ELEMENT_ARRAY_UNIFIED_NV                          = &H8F1F???
%GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV                    = &H8F20???
%GL_VERTEX_ARRAY_ADDRESS_NV                           = &H8F21???
%GL_NORMAL_ARRAY_ADDRESS_NV                           = &H8F22???
%GL_COLOR_ARRAY_ADDRESS_NV                            = &H8F23???
%GL_INDEX_ARRAY_ADDRESS_NV                            = &H8F24???
%GL_TEXTURE_COORD_ARRAY_ADDRESS_NV                    = &H8F25???
%GL_EDGE_FLAG_ARRAY_ADDRESS_NV                        = &H8F26???
%GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV                  = &H8F27???
%GL_FOG_COORD_ARRAY_ADDRESS_NV                        = &H8F28???
%GL_ELEMENT_ARRAY_ADDRESS_NV                          = &H8F29???
%GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV                     = &H8F2A???
%GL_VERTEX_ARRAY_LENGTH_NV                            = &H8F2B???
%GL_NORMAL_ARRAY_LENGTH_NV                            = &H8F2C???
%GL_COLOR_ARRAY_LENGTH_NV                             = &H8F2D???
%GL_INDEX_ARRAY_LENGTH_NV                             = &H8F2E???
%GL_TEXTURE_COORD_ARRAY_LENGTH_NV                     = &H8F2F???
%GL_EDGE_FLAG_ARRAY_LENGTH_NV                         = &H8F30???
%GL_SECONDARY_COLOR_ARRAY_LENGTH_NV                   = &H8F31???
%GL_FOG_COORD_ARRAY_LENGTH_NV                         = &H8F32???
%GL_ELEMENT_ARRAY_LENGTH_NV                           = &H8F33???
%GL_DRAW_INDIRECT_UNIFIED_NV                          = &H8F40???
%GL_DRAW_INDIRECT_ADDRESS_NV                          = &H8F41???
%GL_DRAW_INDIRECT_LENGTH_NV                           = &H8F42???
#ENDIF

'#IF NOT %DEF(%GL_NV_texture_barrier)
'#ENDIF

'#IF NOT %DEF(%GL_AMD_shader_stencil_export)
'#ENDIF

'#IF NOT %DEF(%GL_AMD_seamless_cubemap_per_texture)
''/* reuse GL_TEXTURE_CUBE_MAP_SEAMLESS */
'#ENDIF

'#IF NOT %DEF(%GL_AMD_conservative_depth)
'#ENDIF

#IF NOT %DEF(%GL_EXT_shader_image_load_store)
%GL_MAX_IMAGE_UNITS_EXT                               = &H8F38???
%GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = &H8F39???
%GL_IMAGE_BINDING_NAME_EXT                            = &H8F3A???
%GL_IMAGE_BINDING_LEVEL_EXT                           = &H8F3B???
%GL_IMAGE_BINDING_LAYERED_EXT                         = &H8F3C???
%GL_IMAGE_BINDING_LAYER_EXT                           = &H8F3D???
%GL_IMAGE_BINDING_ACCESS_EXT                          = &H8F3E???
%GL_IMAGE_1D_EXT                                      = &H904C???
%GL_IMAGE_2D_EXT                                      = &H904D???
%GL_IMAGE_3D_EXT                                      = &H904E???
%GL_IMAGE_2D_RECT_EXT                                 = &H904F???
%GL_IMAGE_CUBE_EXT                                    = &H9050???
%GL_IMAGE_BUFFER_EXT                                  = &H9051???
%GL_IMAGE_1D_ARRAY_EXT                                = &H9052???
%GL_IMAGE_2D_ARRAY_EXT                                = &H9053???
%GL_IMAGE_CUBE_MAP_ARRAY_EXT                          = &H9054???
%GL_IMAGE_2D_MULTISAMPLE_EXT                          = &H9055???
%GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT                    = &H9056???
%GL_INT_IMAGE_1D_EXT                                  = &H9057???
%GL_INT_IMAGE_2D_EXT                                  = &H9058???
%GL_INT_IMAGE_3D_EXT                                  = &H9059???
%GL_INT_IMAGE_2D_RECT_EXT                             = &H905A???
%GL_INT_IMAGE_CUBE_EXT                                = &H905B???
%GL_INT_IMAGE_BUFFER_EXT                              = &H905C???
%GL_INT_IMAGE_1D_ARRAY_EXT                            = &H905D???
%GL_INT_IMAGE_2D_ARRAY_EXT                            = &H905E???
%GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT                      = &H905F???
%GL_INT_IMAGE_2D_MULTISAMPLE_EXT                      = &H9060???
%GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT                = &H9061???
%GL_UNSIGNED_INT_IMAGE_1D_EXT                         = &H9062???
%GL_UNSIGNED_INT_IMAGE_2D_EXT                         = &H9063???
%GL_UNSIGNED_INT_IMAGE_3D_EXT                         = &H9064???
%GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT                    = &H9065???
%GL_UNSIGNED_INT_IMAGE_CUBE_EXT                       = &H9066???
%GL_UNSIGNED_INT_IMAGE_BUFFER_EXT                     = &H9067???
%GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT                   = &H9068???
%GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT                   = &H9069???
%GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT             = &H906A???
%GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT             = &H906B???
%GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT       = &H906C???
%GL_MAX_IMAGE_SAMPLES_EXT                             = &H906D???
%GL_IMAGE_BINDING_FORMAT_EXT                          = &H906E???
%GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT               = &H00000001???
%GL_ELEMENT_ARRAY_BARRIER_BIT_EXT                     = &H00000002???
%GL_UNIFORM_BARRIER_BIT_EXT                           = &H00000004???
%GL_TEXTURE_FETCH_BARRIER_BIT_EXT                     = &H00000008???
%GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT               = &H00000020???
%GL_COMMAND_BARRIER_BIT_EXT                           = &H00000040???
%GL_PIXEL_BUFFER_BARRIER_BIT_EXT                      = &H00000080???
%GL_TEXTURE_UPDATE_BARRIER_BIT_EXT                    = &H00000100???
%GL_BUFFER_UPDATE_BARRIER_BIT_EXT                     = &H00000200???
%GL_FRAMEBUFFER_BARRIER_BIT_EXT                       = &H00000400???
%GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT                = &H00000800???
%GL_ATOMIC_COUNTER_BARRIER_BIT_EXT                    = &H00001000???
%GL_ALL_BARRIER_BITS_EXT                              = &HFFFFFFFF???
#ENDIF

#IF NOT %DEF(%GL_EXT_vertex_attrib_64bit)
'/* reuse GL_DOUBLE */
%GL_DOUBLE_VEC2_EXT                                   = &H8FFC???
%GL_DOUBLE_VEC3_EXT                                   = &H8FFD???
%GL_DOUBLE_VEC4_EXT                                   = &H8FFE???
%GL_DOUBLE_MAT2_EXT                                   = &H8F46???
%GL_DOUBLE_MAT3_EXT                                   = &H8F47???
%GL_DOUBLE_MAT4_EXT                                   = &H8F48???
%GL_DOUBLE_MAT2x3_EXT                                 = &H8F49???
%GL_DOUBLE_MAT2x4_EXT                                 = &H8F4A???
%GL_DOUBLE_MAT3x2_EXT                                 = &H8F4B???
%GL_DOUBLE_MAT3x4_EXT                                 = &H8F4C???
%GL_DOUBLE_MAT4x2_EXT                                 = &H8F4D???
%GL_DOUBLE_MAT4x3_EXT                                 = &H8F4E???
#ENDIF

#IF NOT %DEF(%GL_NV_gpu_program5)
%GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV               = &H8E5A???
%GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV              = &H8E5B???
%GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV              = &H8E5C???
%GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV     = &H8E5D???
%GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV              = &H8E5E???
%GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV              = &H8E5F???
%GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV              = &H8F44???
%GL_MAX_PROGRAM_SUBROUTINE_NUM_NV                     = &H8F45???
#ENDIF

#IF NOT %DEF(%GL_NV_gpu_shader5)
%GL_INT64_NV                                          = &H140E???
%GL_UNSIGNED_INT64_NV                                 = &H140F???
%GL_INT8_NV                                           = &H8FE0???
%GL_INT8_VEC2_NV                                      = &H8FE1???
%GL_INT8_VEC3_NV                                      = &H8FE2???
%GL_INT8_VEC4_NV                                      = &H8FE3???
%GL_INT16_NV                                          = &H8FE4???
%GL_INT16_VEC2_NV                                     = &H8FE5???
%GL_INT16_VEC3_NV                                     = &H8FE6???
%GL_INT16_VEC4_NV                                     = &H8FE7???
%GL_INT64_VEC2_NV                                     = &H8FE9???
%GL_INT64_VEC3_NV                                     = &H8FEA???
%GL_INT64_VEC4_NV                                     = &H8FEB???
%GL_UNSIGNED_INT8_NV                                  = &H8FEC???
%GL_UNSIGNED_INT8_VEC2_NV                             = &H8FED???
%GL_UNSIGNED_INT8_VEC3_NV                             = &H8FEE???
%GL_UNSIGNED_INT8_VEC4_NV                             = &H8FEF???
%GL_UNSIGNED_INT16_NV                                 = &H8FF0???
%GL_UNSIGNED_INT16_VEC2_NV                            = &H8FF1???
%GL_UNSIGNED_INT16_VEC3_NV                            = &H8FF2???
%GL_UNSIGNED_INT16_VEC4_NV                            = &H8FF3???
%GL_UNSIGNED_INT64_VEC2_NV                            = &H8FF5???
%GL_UNSIGNED_INT64_VEC3_NV                            = &H8FF6???
%GL_UNSIGNED_INT64_VEC4_NV                            = &H8FF7???
%GL_FLOAT16_NV                                        = &H8FF8???
%GL_FLOAT16_VEC2_NV                                   = &H8FF9???
%GL_FLOAT16_VEC3_NV                                   = &H8FFA???
%GL_FLOAT16_VEC4_NV                                   = &H8FFB???
'/* reuse GL_PATCHES */
#ENDIF

#IF NOT %DEF(%GL_NV_shader_buffer_store)
%GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV               = &H00000010???
'/* reuse GL_READ_WRITE */
'/* reuse GL_WRITE_ONLY */
#ENDIF

#IF NOT %DEF(%GL_NV_tessellation_program5)
%GL_MAX_PROGRAM_PATCH_ATTRIBS_NV                      = &H86D8???
%GL_TESS_CONTROL_PROGRAM_NV                           = &H891E???
%GL_TESS_EVALUATION_PROGRAM_NV                        = &H891F???
%GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV          = &H8C74???
%GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV       = &H8C75???
#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_attrib_integer_64bit)
''/* reuse GL_INT64_NV */
''/* reuse GL_UNSIGNED_INT64_NV */
'#ENDIF

#IF NOT %DEF(%GL_NV_multisample_coverage)
%GL_COVERAGE_SAMPLES_NV                               = &H80A9???   ' Removed in version 76
%GL_COLOR_SAMPLES_NV                                  = &H8E20???
'/* reuse GL_SAMPLES_ARB */
#ENDIF

#IF NOT %DEF(%GL_AMD_name_gen_delete)
%GL_DATA_BUFFER_AMD                                   = &H9151???
%GL_PERFORMANCE_MONITOR_AMD                           = &H9152???
%GL_QUERY_OBJECT_AMD                                  = &H9153???
%GL_VERTEX_ARRAY_OBJECT_AMD                           = &H9154???
%GL_SAMPLER_OBJECT_AMD                                = &H9155???
#ENDIF

#IF NOT %DEF(%GL_AMD_debug_output)
%GL_MAX_DEBUG_MESSAGE_LENGTH_AMD                      = &H9143???
%GL_MAX_DEBUG_LOGGED_MESSAGES_AMD                     = &H9144???
%GL_DEBUG_LOGGED_MESSAGES_AMD                         = &H9145???
%GL_DEBUG_SEVERITY_HIGH_AMD                           = &H9146???
%GL_DEBUG_SEVERITY_MEDIUM_AMD                         = &H9147???
%GL_DEBUG_SEVERITY_LOW_AMD                            = &H9148???
%GL_DEBUG_CATEGORY_API_ERROR_AMD                      = &H9149???
%GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD                  = &H914A???
%GL_DEBUG_CATEGORY_DEPRECATION_AMD                    = &H914B???
%GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD             = &H914C???
%GL_DEBUG_CATEGORY_PERFORMANCE_AMD                    = &H914D???
%GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD                = &H914E???
%GL_DEBUG_CATEGORY_APPLICATION_AMD                    = &H914F???
%GL_DEBUG_CATEGORY_OTHER_AMD                          = &H9150???
#ENDIF

#IF NOT %DEF(%GL_NV_vdpau_interop)
%GL_SURFACE_STATE_NV                                  = &H86EB???
%GL_SURFACE_REGISTERED_NV                             = &H86FD???
%GL_SURFACE_MAPPED_NV                                 = &H8700???
%GL_WRITE_DISCARD_NV                                  = &H88BE???
#ENDIF

'#IF NOT %DEF(%GL_AMD_transform_feedback3_lines_triangles)
'#ENDIF

#IF NOT %DEF(%GL_AMD_depth_clamp_separate)
%GL_DEPTH_CLAMP_NEAR_AMD           = &H901E???
%GL_DEPTH_CLAMP_FAR_AMD            = &H901F???
#ENDIF

#IF NOT %DEF(%GL_EXT_texture_sRGB_decode)
%GL_TEXTURE_SRGB_DECODE_EXT        = &H8A48???
%GL_DECODE_EXT                     = &H8A49???
%GL_SKIP_DECODE_EXT                = &H8A4A???
#ENDIF

#IF NOT %DEF(%GL_NV_texture_multisample)
%GL_TEXTURE_COVERAGE_SAMPLES_NV    = &H9045???
%GL_TEXTURE_COLOR_SAMPLES_NV       = &H9046???
#ENDIF

#IF NOT %DEF(%GL_AMD_blend_minmax_factor)
%GL_FACTOR_MIN_AMD                 = &H901C???
%GL_FACTOR_MAX_AMD                 = &H901D???
#ENDIF

#IF NOT %DEF(%GL_AMD_sample_positions)
%GL_SUBSAMPLE_DISTANCE_AMD         = &H883F???
#ENDIF

#IF NOT %DEF(%GL_EXT_x11_sync_object)
%GL_SYNC_X11_FENCE_EXT             = &H90E1???
#ENDIF

'#IF NOT %DEF(%GL_AMD_multi_draw_indirect)
'#ENDIF

#IF NOT %DEF(%GL_EXT_framebuffer_multisample_blit_scaled)
%GL_SCALED_RESOLVE_FASTEST_EXT     = &H90BA???
%GL_SCALED_RESOLVE_NICEST_EXT      = &H90BB???
#ENDIF

#IF NOT %DEF(%GL_NV_path_rendering)
%GL_PATH_FORMAT_SVG_NV                      = &H9070???
%GL_PATH_FORMAT_PS_NV                       = &H9071???
%GL_STANDARD_FONT_NAME_NV                   = &H9072???
%GL_SYSTEM_FONT_NAME_NV                     = &H9073???
%GL_FILE_NAME_NV                            = &H9074???
%GL_PATH_STROKE_WIDTH_NV                    = &H9075???
%GL_PATH_END_CAPS_NV                        = &H9076???
%GL_PATH_INITIAL_END_CAP_NV                 = &H9077???
%GL_PATH_TERMINAL_END_CAP_NV                = &H9078???
%GL_PATH_JOIN_STYLE_NV                      = &H9079???
%GL_PATH_MITER_LIMIT_NV                     = &H907A???
%GL_PATH_DASH_CAPS_NV                       = &H907B???
%GL_PATH_INITIAL_DASH_CAP_NV                = &H907C???
%GL_PATH_TERMINAL_DASH_CAP_NV               = &H907D???
%GL_PATH_DASH_OFFSET_NV                     = &H907E???
%GL_PATH_CLIENT_LENGTH_NV                   = &H907F???
%GL_PATH_FILL_MODE_NV                       = &H9080???
%GL_PATH_FILL_MASK_NV                       = &H9081???
%GL_PATH_FILL_COVER_MODE_NV                 = &H9082???
%GL_PATH_STROKE_COVER_MODE_NV               = &H9083???
%GL_PATH_STROKE_MASK_NV                     = &H9084???
%GL_PATH_SAMPLE_QUALITY_NV                  = &H9085???   ' Removed in version 76
%GL_PATH_STROKE_BOUND_NV                    = &H9086???   ' Removed in version 76
%GL_PATH_STROKE_OVERSAMPLE_COUNT_NV         = &H9087???   ' Removed in version 76
%GL_COUNT_UP_NV                             = &H9088???
%GL_COUNT_DOWN_NV                           = &H9089???
%GL_PATH_OBJECT_BOUNDING_BOX_NV             = &H908A???
%GL_CONVEX_HULL_NV                          = &H908B???
%GL_MULTI_HULLS_NV                          = &H908C???   ' Removed in version 76
%GL_BOUNDING_BOX_NV                         = &H908D???
%GL_TRANSLATE_X_NV                          = &H908E???
%GL_TRANSLATE_Y_NV                          = &H908F???
%GL_TRANSLATE_2D_NV                         = &H9090???
%GL_TRANSLATE_3D_NV                         = &H9091???
%GL_AFFINE_2D_NV                            = &H9092???
%GL_PROJECTIVE_2D_NV                        = &H9093???   ' Removed in version 76
%GL_AFFINE_3D_NV                            = &H9094???
%GL_PROJECTIVE_3D_NV                        = &H9095???   ' Removed in version 76
%GL_TRANSPOSE_AFFINE_2D_NV                  = &H9096???
%GL_TRANSPOSE_PROJECTIVE_2D_NV              = &H9097???   ' Removed in version 76
%GL_TRANSPOSE_AFFINE_3D_NV                  = &H9098???
%GL_TRANSPOSE_PROJECTIVE_3D_NV              = &H9099???   ' Removed in version 76
%GL_UTF8_NV                                 = &H909A???
%GL_UTF16_NV                                = &H909B???
%GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV       = &H909C???
%GL_PATH_COMMAND_COUNT_NV                   = &H909D???
%GL_PATH_COORD_COUNT_NV                     = &H909E???
%GL_PATH_DASH_ARRAY_COUNT_NV                = &H909F???
%GL_PATH_COMPUTED_LENGTH_NV                 = &H90A0???
%GL_PATH_FILL_BOUNDING_BOX_NV               = &H90A1???
%GL_PATH_STROKE_BOUNDING_BOX_NV             = &H90A2???
%GL_SQUARE_NV                               = &H90A3???
%GL_ROUND_NV                                = &H90A4???
%GL_TRIANGULAR_NV                           = &H90A5???
%GL_BEVEL_NV                                = &H90A6???
%GL_MITER_REVERT_NV                         = &H90A7???
%GL_MITER_TRUNCATE_NV                       = &H90A8???
%GL_SKIP_MISSING_GLYPH_NV                   = &H90A9???
%GL_USE_MISSING_GLYPH_NV                    = &H90AA???
%GL_PATH_ERROR_POSITION_NV                  = &H90AB???
%GL_PATH_FOG_GEN_MODE_NV                    = &H90AC???
%GL_ACCUM_ADJACENT_PAIRS_NV                 = &H90AD???
%GL_ADJACENT_PAIRS_NV                       = &H90AE???
%GL_FIRST_TO_REST_NV                        = &H90AF???
%GL_PATH_GEN_MODE_NV                        = &H90B0???
%GL_PATH_GEN_COEFF_NV                       = &H90B1???
%GL_PATH_GEN_COLOR_FORMAT_NV                = &H90B2???
%GL_PATH_GEN_COMPONENTS_NV                  = &H90B3???
%GL_PATH_STENCIL_FUNC_NV                    = &H90B7???
%GL_PATH_STENCIL_REF_NV                     = &H90B8???
%GL_PATH_STENCIL_VALUE_MASK_NV              = &H90B9???
%GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV     = &H90BD???
%GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV      = &H90BE???
%GL_PATH_COVER_DEPTH_FUNC_NV                = &H90BF???
%GL_PATH_DASH_OFFSET_RESET_NV               = &H90B4???
%GL_MOVE_TO_RESETS_NV                       = &H90B5???
%GL_MOVE_TO_CONTINUES_NV                    = &H90B6???
%GL_CLOSE_PATH_NV                           = &H00???
%GL_MOVE_TO_NV                              = &H02???
%GL_RELATIVE_MOVE_TO_NV                     = &H03???
%GL_LINE_TO_NV                              = &H04???
%GL_RELATIVE_LINE_TO_NV                     = &H05???
%GL_HORIZONTAL_LINE_TO_NV                   = &H06???
%GL_RELATIVE_HORIZONTAL_LINE_TO_NV          = &H07???
%GL_VERTICAL_LINE_TO_NV                     = &H08???
%GL_RELATIVE_VERTICAL_LINE_TO_NV            = &H09???
%GL_QUADRATIC_CURVE_TO_NV                   = &H0A???
%GL_RELATIVE_QUADRATIC_CURVE_TO_NV          = &H0B???
%GL_CUBIC_CURVE_TO_NV                       = &H0C???
%GL_RELATIVE_CUBIC_CURVE_TO_NV              = &H0D???
%GL_SMOOTH_QUADRATIC_CURVE_TO_NV            = &H0E???
%GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV   = &H0F???
%GL_SMOOTH_CUBIC_CURVE_TO_NV                = &H10???
%GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV       = &H11???
%GL_SMALL_CCW_ARC_TO_NV                     = &H12???
%GL_RELATIVE_SMALL_CCW_ARC_TO_NV            = &H13???
%GL_SMALL_CW_ARC_TO_NV                      = &H14???
%GL_RELATIVE_SMALL_CW_ARC_TO_NV             = &H15???
%GL_LARGE_CCW_ARC_TO_NV                     = &H16???
%GL_RELATIVE_LARGE_CCW_ARC_TO_NV            = &H17???
%GL_LARGE_CW_ARC_TO_NV                      = &H18???
%GL_RELATIVE_LARGE_CW_ARC_TO_NV             = &H19???
%GL_RESTART_PATH_NV                         = &HF0???
%GL_DUP_FIRST_CUBIC_CURVE_TO_NV             = &HF2???
%GL_DUP_LAST_CUBIC_CURVE_TO_NV              = &HF4???
%GL_RECT_NV                                 = &HF6???
%GL_CIRCULAR_CCW_ARC_TO_NV                  = &HF8???
%GL_CIRCULAR_CW_ARC_TO_NV                   = &HFA???
%GL_CIRCULAR_TANGENT_ARC_TO_NV              = &HFC???
%GL_ARC_TO_NV                               = &HFE???
%GL_RELATIVE_ARC_TO_NV                      = &HFF???
%GL_BOLD_BIT_NV                             = &H01???
%GL_ITALIC_BIT_NV                           = &H02???
%GL_GLYPH_WIDTH_BIT_NV                      = &H01???
%GL_GLYPH_HEIGHT_BIT_NV                     = &H02???
%GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV       = &H04???
%GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV       = &H08???
%GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = &H10???
%GL_GLYPH_VERTICAL_BEARING_X_BIT_NV         = &H20???
%GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV         = &H40???
%GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV   = &H80???
'%GL_GLYPH_HAS_KERNING_NV                    = &H100???        ' Renamed in version 76 - see below
'%GL_FONT_X_MIN_BOUNDS_NV                    = &H00010000???   ' Renamed in version 76 - see below
'%GL_FONT_Y_MIN_BOUNDS_NV                    = &H00020000???   ' Renamed in version 76 - see below
'%GL_FONT_X_MAX_BOUNDS_NV                    = &H00040000???   ' Renamed in version 76 - see below
'%GL_FONT_Y_MAX_BOUNDS_NV                    = &H00080000???   ' Renamed in version 76 - see below
'%GL_FONT_UNITS_PER_EM_NV                    = &H00100000???   ' Renamed in version 76 - see below
'%GL_FONT_ASCENDER_NV                        = &H00200000???   ' Renamed in version 76 - see below
'%GL_FONT_DESCENDER_NV                       = &H00400000???   ' Renamed in version 76 - see below
'%GL_FONT_HEIGHT_NV                          = &H00800000???   ' Renamed in version 76 - see below
'%GL_FONT_MAX_ADVANCE_WIDTH_NV               = &H01000000???   ' Renamed in version 76 - see below
'%GL_FONT_MAX_ADVANCE_HEIGHT_NV              = &H02000000???   ' Renamed in version 76 - see below
'%GL_FONT_UNDERLINE_POSITION_NV              = &H04000000???   ' Renamed in version 76 - see below
'%GL_FONT_UNDERLINE_THICKNESS_NV             = &H08000000???   ' Renamed in version 76 - see below
'%GL_FONT_HAS_KERNING_NV                     = &H10000000???   ' Renamed in version 76 - see below
%GL_GLYPH_HAS_KERNING_BIT_NV                = &H100???
%GL_FONT_X_MIN_BOUNDS_BIT_NV                = &H00010000???
%GL_FONT_Y_MIN_BOUNDS_BIT_NV                = &H00020000???
%GL_FONT_X_MAX_BOUNDS_BIT_NV                = &H00040000???
%GL_FONT_Y_MAX_BOUNDS_BIT_NV                = &H00080000???
%GL_FONT_UNITS_PER_EM_BIT_NV                = &H00100000???
%GL_FONT_ASCENDER_BIT_NV                    = &H00200000???
%GL_FONT_DESCENDER_BIT_NV                   = &H00400000???
%GL_FONT_HEIGHT_BIT_NV                      = &H00800000???
%GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV           = &H01000000???
%GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV          = &H02000000???
%GL_FONT_UNDERLINE_POSITION_BIT_NV          = &H04000000???
%GL_FONT_UNDERLINE_THICKNESS_BIT_NV         = &H08000000???
%GL_FONT_HAS_KERNING_BIT_NV                 = &H10000000???
'/* reuse GL_PRIMARY_COLOR */
'/* reuse GL_PRIMARY_COLOR_NV */
'/* reuse GL_SECONDARY_COLOR_NV */
#ENDIF

#IF NOT %DEF(%GL_AMD_pinned_memory)
%GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = &H9160???
#ENDIF

#IF NOT %DEF(%GL_AMD_stencil_operation_extended)
%GL_SET_AMD                        = &H874A???
%GL_REPLACE_VALUE_AMD              = &H874B???
%GL_STENCIL_OP_VALUE_AMD           = &H874C???
%GL_STENCIL_BACK_OP_VALUE_AMD      = &H874D???
#ENDIF

'#IF NOT %DEF(%GL_AMD_vertex_shader_viewport_index)
'#ENDIF

'#IF NOT %DEF(%GL_AMD_vertex_shader_layer)
'#ENDIF

'#IF NOT %DEF(%GL_NV_bindless_texture)
'#ENDIF

'#IF NOT %DEF(%GL_NV_shader_atomic_float)
'#ENDIF

#IF NOT %DEF(%GL_AMD_query_buffer_object)
%GL_QUERY_BUFFER_AMD               = &H9192???
%GL_QUERY_BUFFER_BINDING_AMD       = &H9193???
%GL_QUERY_RESULT_NO_WAIT_AMD       = &H9194???
#ENDIF

#IF NOT %DEF(%GL_NV_compute_program5)
%GL_COMPUTE_PROGRAM_NV                  = &H90FB???
%GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = &H90FC???
#ENDIF

'#IF NOT %DEF(%GL_NV_shader_storage_buffer_object)
'#ENDIF

'#IF NOT %DEF(%GL_NV_shader_atomic_counters)
'#ENDIF

#IF NOT %DEF(%GL_NV_deep_texture3D)
%GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = &H90D0???
%GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV        = &H90D1???
#ENDIF

'#IF NOT %DEF(%GL_NVX_conditional_render)
'#ENDIF

#IF NOT %DEF(%GL_AMD_sparse_texture)
%GL_VIRTUAL_PAGE_SIZE_X_AMD         = &H9195???
%GL_VIRTUAL_PAGE_SIZE_Y_AMD         = &H9196???
%GL_VIRTUAL_PAGE_SIZE_Z_AMD         = &H9197???
%GL_MAX_SPARSE_TEXTURE_SIZE_AMD     = &H9198???
%GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD  = &H9199???
%GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS = &H919A???
%GL_MIN_SPARSE_LEVEL_AMD            = &H919B???
%GL_MIN_LOD_WARNING_AMD             = &H919C???
%GL_TEXTURE_STORAGE_SPARSE_BIT_AMD  = &H00000001???
#ENDIF

'#IF NOT %DEF(%GL_AMD_shader_trinary_minmax)
'#ENDIF

#IF NOT %DEF(%GL_INTEL_map_texture)
%GL_TEXTURE_MEMORY_LAYOUT_INTEL    = &H83FF???
%GL_LAYOUT_DEFAULT_INTEL           = 0???
%GL_LAYOUT_LINEAR_INTEL            = 1???
%GL_LAYOUT_LINEAR_CPU_CACHED_INTEL = 2???
#ENDIF

'#IF NOT %DEF(%GL_NV_draw_texture)
'#ENDIF

' /*************************************************************/

'#include <stddef.h>
'#ifndef GL_VERSION_2_0
'/* GL type for program/shader text */
'typedef char GLchar;         /* native character */
'#endif

'#ifndef GL_VERSION_1_5
'/* GL types for handling large vertex buffer objects */
'typedef ptrdiff_t GLintptr;
'typedef ptrdiff_t GLsizeiptr;
'#endif

'#ifndef GL_ARB_vertex_buffer_object
'/* GL types for handling large vertex buffer objects */
'typedef ptrdiff_t GLintptrARB;
'typedef ptrdiff_t GLsizeiptrARB;
'#endif

'#ifndef GL_ARB_shader_objects
'/* GL types for program/shader text and shader object handles */
'typedef char GLcharARB;
'typedef unsigned int GLhandleARB;
'#endif

'/* GL type for "half" precision (s10e5) float data in host memory */
'#ifndef GL_ARB_half_float_pixel
'typedef unsigned short GLhalfARB;
'#endif

'#ifndef GL_NV_half_float
'typedef unsigned short GLhalfNV;
'#endif

'#ifndef GLEXT_64_TYPES_DEFINED
'/* This code block is duplicated in glxext.h, so must be protected */
'#define GLEXT_64_TYPES_DEFINED
'/* Define int32_t, int64_t, and uint64_t types for UST/MSC */
'/* (as used in the GL_EXT_timer_query extension). */
'#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
'#include <inttypes.h>
'#elif defined(__sun__)
'#include <inttypes.h>
'#if defined(__STDC__)
'#if defined(__arch64__)
'typedef long int int64_t;
'typedef unsigned long int uint64_t;
'#else
'typedef long long int int64_t;
'typedef unsigned long long int uint64_t;
'#endif /* __arch64__ */
'#endif /* __STDC__ */
'#elif defined( __VMS )
'#include <inttypes.h>
'#elif defined(__SCO__) || defined(__USLC__)
'#include <stdint.h>
'#elif defined(__UNIXOS2__) || defined(__SOL64__)
'typedef long int int32_t;
'typedef long long int int64_t;
'typedef unsigned long long int uint64_t;
'#elif defined(_WIN32) && defined(__GNUC__)
'#include <stdint.h>
'#elif defined(_WIN32)
'typedef __int32 int32_t;
'typedef __int64 int64_t;
'typedef unsigned __int64 uint64_t;
'#else
'/* Fallback if nothing above works */
'#include <inttypes.h>
'#endif
'#endif

'#ifndef GL_EXT_timer_query
'typedef int64_t GLint64EXT;
'typedef uint64_t GLuint64EXT;
'#endif

'#ifndef GL_ARB_sync
'typedef int64_t GLint64;
'typedef uint64_t GLuint64;
'typedef struct __GLsync *GLsync;
'#endif

'#IF NOT %DEF(%GL_ARB_cl_event)
''/* These incomplete types let us declare types compatible with OpenCL's cl_context and cl_event */
''struct _cl_context;
''struct _cl_event;
'#ENDIF

'#IF NOT %DEF(%GL_ARB_debug_output)
''typedef void (APIENTRY *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
'#ENDIF

'#IF NOT %DEF(%GL_AMD_debug_output)
''typedef void (APIENTRY *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
'#ENDIF

'#IF NOT %DEF(%GL_KHR_debug)
''typedef void (APIENTRY *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
'#ENDIF

'#IF NOT %DEF(%GL_NV_vdpau_interop)
''typedef GLintptr GLvdpauSurfaceNV;
'#ENDIF

'#IF NOT %DEF(%GL_OES_fixed_point)
''/* GLint must be 32 bits, a relatively safe assumption on modern CPUs */
''typedef GLint GLfixed;
'#ENDIF

'#IF NOT %DEF(%GL_VERSION_1_2)
'%GL_VERSION_1_2 = 1

' ========================================================================================
' Set the blend color.
' void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
' ========================================================================================
DECLARE SUB glBlendColor (BYVAL red AS SINGLE, BYVAL green AS SINGLE, BYVAL blue AS SINGLE, BYVAL alpha AS SINGLE)

' ========================================================================================
' Set the blend equation
' void glBlendEquation (GLenum mode);
' ========================================================================================
DECLARE SUB glBlendEquation (BYVAL dwMode AS DWORD)

' ========================================================================================
' Render primitives from array data.
' void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
' ========================================================================================
DECLARE SUB glDrawRangeElements (BYVAL dwMode AS DWORD, BYVAL dwStart AS DWORD, BYVAL dwEnd AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL pIndices AS DWORD)

' ========================================================================================
' Specify a three-dimensional texture image.
' void APIENTRY glTexImage3D (GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
' typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat,
' GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexImage3D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
    BYVAL nDepth AS LONG, BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL ppixels AS DWORD)

' ========================================================================================
' Specifies a three-dimensional (3D) texture subimage.
' void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexSubImage3D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
    BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL ppixels AS DWORD)

' ========================================================================================
' Copy a three-dimensional texture subimage.
' void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyTexSubImage3D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

'#ENDIF

' ========================================================================================
' Defines a color lookup table
' void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
' ========================================================================================
DECLARE SUB glColorTable (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' Set color lookup table parameters.
' void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glColorTableParameterfv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Set color lookup table parameters.
' void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glColorTableParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Copy pixels into a color table.
' void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyColorTable (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' Retrieve contents of a color lookup table.
' void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
' ========================================================================================
DECLARE SUB glGetColorTable (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' Get color lookup table parameters.
' void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetColorTableParameterfv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Get color lookup table parameters.
' void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetColorTableParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Respecify a portion of a color table.
' void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
' ========================================================================================
DECLARE SUB glColorSubTable (BYVAL dwTarget AS DWORD, BYVAL nStart AS LONG, BYVAL nCount AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' Respecify a portion of a color table.
' void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyColorSubTable (BYVAL dwTarget AS DWORD, BYVAL nStart AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' Define a one-dimensional convolution filter.
' void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width,
' GLenum format, GLenum type, const GLvoid *image);
' ========================================================================================
DECLARE SUB glConvolutionFilter1D (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pImage AS DWORD)

' ========================================================================================
' Define a two-dimensional convolution filter.
' void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width,
' GLsizei height, GLenum format, GLenum type, const GLvoid *image);
' ========================================================================================
DECLARE SUB glConvolutionFilter2D (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pImage AS DWORD)

' ========================================================================================
' Set convolution parameters.
' void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
' ========================================================================================
DECLARE SUB glConvolutionParameterf (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL params AS SINGLE)

' ========================================================================================
' Set convolution parameters.
' void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glConvolutionParameterfv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Set convolution parameters.
' void glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
' ========================================================================================
DECLARE SUB glConvolutionParameteri (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL params AS LONG)

' ========================================================================================
' Set convolution parameters.
' void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glConvolutionParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Copy pixels into a one-dimensional convolution filter.
' void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyConvolutionFilter1D (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' Copy pixels into a two-dimensional convolution filter.
' void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyConvolutionFilter2D (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' Get current 1D or 2D convolution filter kernel.
' void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
' ========================================================================================
DECLARE SUB glGetConvolutionFilter (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pImage AS DWORD)

' ========================================================================================
' Get convolution parameters.
' void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetConvolutionParameterfv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Get convolution parameters.
' void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetConvolutionParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Get separable convolution filter kernel images.
' void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
' ========================================================================================
DECLARE SUB glGetSeparableFilter (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pRow AS DWORD, BYVAL pColumn AS DWORD, BYVAL pSpan AS DWORD)

' ========================================================================================
' Define a separable two-dimensional convolution filter.
' void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width,
' GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
' ========================================================================================
DECLARE SUB glSeparableFilter2D (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWIdth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pRow AS DWORD, BYVAL pColumn AS DWORD)

' ========================================================================================
' Get histogram table.
' void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
' ========================================================================================
DECLARE SUB glGetHistogram (BYVAL dwTarget AS DWORD, BYVAL bReset AS BYTE, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pValues AS DWORD)

' ========================================================================================
' Get histogram parameters.
' void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetHistogramParameterfv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Get histogram parameters.
' void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetHistogramParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Get minimum and maximum pixel values.
' void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
' ========================================================================================
DECLARE SUB glGetMinmax (BYVAL dwTarget AS DWORD, BYVAL bReset AS BYTE, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL values AS DWORD)

' ========================================================================================
' Get minmax parameters.
' void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMinmaxParameterfv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Get minmax parameters.
' void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMinmaxParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Define histogram table.
' void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
' ========================================================================================
DECLARE SUB glHistogram (BYVAL dwTarget AS DWORD, BYVAL nWidth AS LONG, BYVAL internalformat AS DWORD, BYVAL bSink AS BYTE)

' ========================================================================================
' Define minmax table.
' void glMinmax (GLenum target, GLenum internalformat, GLboolean sink);
' ========================================================================================
DECLARE SUB glMinmax (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL bSink AS BYTE)

' ========================================================================================
' Reset histogram table entries to zero.
' void glResetHistogram (GLenum target);
' ========================================================================================
DECLARE SUB glResetHistogram (BYVAL dwTarget AS DWORD)

' ========================================================================================
' Reset minmax table entries to initial values
' void glResetMinmax (GLenum target);
' ========================================================================================
DECLARE SUB glResetMinmax (BYVAL dwTarget AS DWORD)

' ========================================================================================
' Select server-side active texture unit.
' void glActiveTexture (GLenum texture);
' ========================================================================================
DECLARE SUB glActiveTexture (BYVAL dwTexture AS DWORD)

' ========================================================================================
' Specify mask to modify multisampled pixel fragments
' void glSampleCoverage (GLclampf value, GLboolean invert);
' ========================================================================================
DECLARE SUB glSampleCoverage (BYVAL value AS SINGLE, BYVAL bInvert AS BYTE)

' ========================================================================================
' Specify a three-dimensional texture image in a compressed format.
' void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexImage3D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' Specify a two-dimensional compressed texture image.
' void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexImage2D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' Specify a one-dimensional texture image in a compressed format.
' void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexImage1D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' Specify a three-dimensional texture subimage in a compressed format
' void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset,
' GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexSubImage3D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
   BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' Specify a two-dimensional texture subimage in a compressed format
' void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset,
' GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexSubImage2D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' Specify a one-dimensional texture subimage in a compressed format.
' void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset,
' GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexSubImage1D (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' Return a compressed texture image.
' void glGetCompressedTexImage (GLenum target, GLint level, GLvoid *img);
' ========================================================================================
DECLARE SUB glGetCompressedTexImage (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL pImg AS DWORD)

' ========================================================================================
' Select client-side active texture unit.
' void glClientActiveTexture (GLenum texture);
' ========================================================================================
DECLARE SUB glClientActiveTexture (BYVAL dwTexture AS DWORD)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1d (GLenum target, GLdouble s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1d (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1dv (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1dv (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1f (GLenum target, GLfloat s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1f (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1fv (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1fv (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1i (GLenum target, GLint s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1i (BYVAL dwTarget AS DWORD, BYVAL s AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1iv (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1iv (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1s (GLenum target, GLshort s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1s (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord1sv (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1sv (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2d (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE, BYVAL t AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2dv (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2dv (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2f (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2fv (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2fv (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2i (GLenum target, GLint s, GLint t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2i (BYVAL dwTarget AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2iv (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2iv (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2s (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER, BYVAL t AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord2sv (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2sv (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3d (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE, BYVAL t AS DOUBLE, BYVAL r AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3dv (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3dv (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3f (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL r AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3fv (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3fv (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3i (BYVAL dwTarget AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG, BYVAL r AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3iv (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3iv (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3s (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER, BYVAL t AS INTEGER, BYVAL r AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord3sv (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3sv (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4d (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE, BYVAL t AS DOUBLE, BYVAL r AS DOUBLE, BYVAL q AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4dv (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4dv (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4f (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL r AS SINGLE, BYVAL q AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4fv (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4fv (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4i (BYVAL dwTarget AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG, BYVAL r AS LONG, BYVAL q AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4iv (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4iv (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4s (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER, BYVAL t AS INTEGER, BYVAL r AS INTEGER, BYVAL q AS INTEGER)

' ========================================================================================
' Set the current texture coordinates.
' void glMultiTexCoord4sv (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4sv (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Replace the current matrix with the specified row-major ordered matrix
' void glLoadTransposeMatrixf (const GLfloat *m);
' ========================================================================================
DECLARE SUB glLoadTransposeMatrixf (BYREF m AS SINGLE)

' ========================================================================================
' Replace the current matrix with the specified row-major ordered matrix
' void glLoadTransposeMatrixd (const GLdouble *m);
' ========================================================================================
DECLARE SUB glLoadTransposeMatrixd (BYREF m AS DOUBLE)

' ========================================================================================
' Replace the current matrix with the specified row-major ordered matrix
' void glMultTransposeMatrixf (const GLfloat *m);
' ========================================================================================
DECLARE SUB glMultTransposeMatrixf (BYREF m AS SINGLE)

' ========================================================================================
' Replace the current matrix with the specified row-major ordered matrix
' void glMultTransposeMatrixd (const GLdouble *m);
' ========================================================================================
DECLARE SUB glMultTransposeMatrixd (BYREF m AS DOUBLE)

'#IF NOT %DEF(%GL_VERSION_1_4)
'%GL_VERSION_1_4 = 1

' ========================================================================================
' Specify pixel arithmetic for RGB and alpha components separately.
' void glBlendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
' ========================================================================================
DECLARE SUB glBlendFuncSeparate (BYVAL srcRGB AS DWORD, BYVAL dstRGB AS DWORD, BYVAL srcAlpha AS DWORD, BYVAL dstAlpha AS DWORD)

' ========================================================================================
' Render multiple sets of primitives from array data.
' void glMultiDrawArrays (GLenum mode, GLint *first, GLsizei *count, GLsizei drawcount);
' ========================================================================================
DECLARE SUB glMultiDrawArrays (BYVAL dwMode AS DWORD, BYREF nFirst AS LONG, BYREF nCount AS LONG, BYVAL drawcount AS LONG)

' ========================================================================================
' Render multiple sets of primitives by specifying indices of array data elements.
' void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type,
' const GLvoid* *indices, GLsizei drawcount);
' ========================================================================================
DECLARE SUB glMultiDrawElements (BYVAL dwMode AS DWORD, BYREF nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL drawcount AS LONG)

' ========================================================================================
' Specify parameters for point rasterization.
' void glPointParameterf (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPointParameterf (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' Specify parameters for point rasterization.
' void glPointParameterfv (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glPointParameterfv (BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Specify parameters for point rasterization.
' void glPointParameteri (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glPointParameteri (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' Specify parameters for point rasterization.
' void glPointParameteriv (GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glPointParameteriv (BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

' ========================================================================================
' Set the current fog coordinates.
' void glFogCoordf (GLfloat coord);
' ========================================================================================
DECLARE SUB glFogCoordf (BYVAL fCoord AS SINGLE)

' ========================================================================================
' Set the current fog coordinates.
' void glFogCoordfv (const GLfloat *coord);
' ========================================================================================
DECLARE SUB glFogCoordfv (BYREF fCoord AS SINGLE)

' ========================================================================================
' Set the current fog coordinates.
' void glFogCoordd (GLdouble coord);
' ========================================================================================
DECLARE SUB glFogCoordd (BYVAL dCoord AS DOUBLE)

' ========================================================================================
' Set the current fog coordinates.
' void glFogCoorddv (const GLdouble *coord);
' ========================================================================================
DECLARE SUB glFogCoorddv (BYREF dCoord AS DOUBLE)

' ========================================================================================
' Define an array of fog coordinates
' void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glFogCoordPointer (BYVAL dwType AS DWORD, BYVAL stride AS LONG, BYVAL pCoordinates AS DWORD)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3b (BYVAL red AS BYTE, BYVAL green AS BYTE, BYVAL blue AS BYTE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3bv (const GLbyte *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3bv (BYREF v AS BYTE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3d (BYVAL red AS DOUBLE, BYVAL green AS DOUBLE, BYVAL blue AS DOUBLE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3dv (const GLdouble *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3dv (BYREF v AS DOUBLE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3f (BYVAL red AS SINGLE, BYVAL green AS SINGLE, BYVAL blue AS SINGLE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3fv (const GLfloat *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3fv (BYREF v AS SINGLE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3i (GLint red, GLint green, GLint blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3i (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3iv (const GLint *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3iv (BYREF v AS LONG)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3s (BYVAL red AS INTEGER, BYVAL green AS INTEGER, BYVAL blue AS INTEGER)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3sv (const GLshort *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3sv (BYREF v AS INTEGER)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3ub (BYVAL red AS BYTE, BYVAL green AS BYTE, BYVAL blue AS BYTE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3ubv (const GLubyte *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3ubv (BYREF v AS BYTE)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3ui (BYVAL red AS DWORD, BYVAL green AS DWORD, BYVAL blue AS DWORD)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3uiv (const GLuint *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3uiv (BYREF v AS DWORD)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3us (BYVAL red AS WORD, BYVAL green AS WORD, BYVAL blue AS WORD)

' ========================================================================================
' Set the current secondary color.
' void glSecondaryColor3usv (const GLushort *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3usv (BYREF v AS WORD)

' ========================================================================================
' Define an array of secondary colors.
' void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glSecondaryColorPointer (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2d (GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glWindowPos2d (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2dv (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos2dv (BYREF v AS DOUBLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2f (GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glWindowPos2f (BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2fv (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos2fv (BYREF v AS SINGLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2i (GLint x, GLint y);
' ========================================================================================
DECLARE SUB glWindowPos2i (BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2iv (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos2iv (BYREF v AS LONG)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2s (GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glWindowPos2s (BYVAL x AS INTEGER, BYVAL y AS INTEGER)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos2sv (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos2sv (BYREF v AS INTEGER)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glWindowPos3d (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3dv (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos3dv (BYREF v AS DOUBLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glWindowPos3f (BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3fv (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos3fv (BYREF v AS SINGLE)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3i (GLint x, GLint y, GLint z);
' ========================================================================================
DECLARE SUB glWindowPos3i (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3iv (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos3iv (BYREF v AS LONG)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3s (GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glWindowPos3s (BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER)

' ========================================================================================
' Specify the raster position in window coordinates for pixel operations.
' void glWindowPos3sv (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos3sv (BYREF v AS INTEGER)

'#IF NOT %DEF(%GL_VERSION_1_5)
'%GL_VERSION_1_5 = 1

' ========================================================================================
' Generate query object names
' void glGenQueries (GLsizei n, GLuint *ids);
' ========================================================================================
DECLARE SUB glGenQueries (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' Delete named query objects.
' void glDeleteQueries (GLsizei n, const GLuint *ids);
' ========================================================================================
DECLARE SUB glDeleteQueries (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' Determine if a name corresponds to a query object.
' GLboolean glIsQuery (GLuint id);
' ========================================================================================
DECLARE FUNCTION glIsQuery (BYVAL dwId AS DWORD) AS BYTE

' ========================================================================================
' Delimit the boundaries of a query object.
' void glBeginQuery (GLenum target, GLuint id);
' ========================================================================================
DECLARE SUB glBeginQuery (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD)

' ========================================================================================
' Delimit the boundaries of a query object.
' void glEndQuery (GLenum target);
' ========================================================================================
DECLARE SUB glEndQuery (BYVAL dwTarget AS DWORD)

' ========================================================================================
' Return parameters of a query object target.
' void glGetQueryiv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetQueryiv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Return parameters of a query object.
' void glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetQueryObjectiv (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Return parameters of a query object.
' void glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetQueryObjectuiv (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' Bind a named buffer to a target.
' void glBindBuffer (GLenum target, GLuint buffer);
' ========================================================================================
DECLARE SUB glBindBuffer (BYVAL dwTarget AS DWORD, BYVAL buffer AS DWORD)

' ========================================================================================
' Delete named buffer objects.
' void glDeleteBuffers (GLsizei n, const GLuint *buffers);
' ========================================================================================
DECLARE SUB glDeleteBuffers (BYVAL n AS LONG, BYREF buffers AS DWORD)

' ========================================================================================
' Generate buffer object names.
' void glGenBuffers (GLsizei n, GLuint *buffers);
' ========================================================================================
DECLARE SUB glGenBuffers (BYVAL n AS LONG, BYREF buffers AS DWORD)

' ========================================================================================
' Determine if a name corresponds to a buffer object.
' GLboolean glIsBuffer (GLuint buffer);
' ========================================================================================
DECLARE FUNCTION glIsBuffer (BYVAL buffer AS DWORD) AS BYTE

' ========================================================================================
' Creates and initializes the data store of a buffer object..
' void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
' ========================================================================================
DECLARE SUB glBufferData (BYVAL dwTarget AS DWORD, BYVAL nSize AS DWORD, BYVAL pData AS DWORD, BYVAL dwUsage AS DWORD)

' ========================================================================================
' Modifies some or all of the data contained in a buffer object's data store.
' void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
' ========================================================================================
DECLARE SUB glBufferSubData (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL dwSize AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' Returns a subset of a buffer object's data store.
' void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
' ========================================================================================
DECLARE SUB glGetBufferSubData (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL pSize AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' Map a buffer object's data store.
' GLvoid* glMapBuffer (GLenum target, GLenum access);
' ========================================================================================
DECLARE FUNCTION glMapBuffer (BYVAL dwTarget AS DWORD, BYVAL dwAccess AS DWORD) AS DWORD

' ========================================================================================
' Unmaps a buffer object's data store.
' GLboolean glUnmapBuffer (GLenum target);
' ========================================================================================
DECLARE FUNCTION glUnmapBuffer (BYVAL dwTarget AS DWORD) AS BYTE

' ========================================================================================
' Return parameters of a buffer object.
' void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetBufferParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Return the pointer to a mapped buffer object's data store.
' void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid* *params);
' ========================================================================================
DECLARE SUB glGetBufferPointerv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_2_0)
'%GL_VERSION_2_0 = 1

' ========================================================================================
' Set the RGB blend equation and the alpha blend equation separately.
' void glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
' ========================================================================================
DECLARE SUB glBlendEquationSeparate (BYVAL modeRGB AS DWORD, BYVAL modeAlpha AS DWORD)

' ========================================================================================
' Specifies a list of color buffers to be drawn into
' void glDrawBuffers (GLsizei n, const GLenum *bufs);
' ========================================================================================
DECLARE SUB glDrawBuffers (BYVAL n AS LONG, BYREF bufs AS DWORD)

' ========================================================================================
' Set front and/or back stencil test actions.
' void glStencilOpSeparate (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
' ========================================================================================
DECLARE SUB glStencilOpSeparate (BYVAL dwFace AS DWORD, BYVAL sfail AS DWORD, BYVAL dpfail AS DWORD, BYVAL dppass AS DWORD)

' ========================================================================================
' Set front and/or back DECLARE FUNCTION and reference value for stencil testing.
' void glStencilFuncSeparate (GLenum face, GLenum v, GLint ref, GLuint mask);
' ========================================================================================
DECLARE SUB glStencilFuncSeparate (BYVAL dwFace AS DWORD, BYVAL dwFunc AS DWORD, BYVAL nRef AS LONG, BYVAL dwMask AS DWORD)

' ========================================================================================
' Control the front and/or back writing of individual bits in the stencil planes.
' void glStencilMaskSeparate (GLenum face, GLuint mask);
' ========================================================================================
DECLARE SUB glStencilMaskSeparate (BYVAL dwFace AS DWORD, BYVAL dwMask AS DWORD)

' ========================================================================================
' Attaches a shader object to a program object
' void glAttachShader (GLuint program, GLuint shader);
' ========================================================================================
DECLARE SUB glAttachShader (BYVAL dwProgram AS DWORD, BYVAL dwShader AS DWORD)

' ========================================================================================
' Associates a generic vertex attribute index with a named attribute variable.
' void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
' ========================================================================================
DECLARE SUB glBindAttribLocation (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' Compiles a shader object.
' void glCompileShader (GLuint shader);
' ========================================================================================
DECLARE SUB glCompileShader (BYVAL dwShader AS DWORD)

' ========================================================================================
' Creates a program object.
' GLuint glCreateProgram (void);
' ========================================================================================
DECLARE FUNCTION glCreateProgram () AS DWORD

' ========================================================================================
' Creates a shader object
' GLuint APIENTRY glCreateShader (GLenum);
' typedef GLuint (APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
' ========================================================================================
DECLARE FUNCTION glCreateShader (BYVAL dwShadertype AS DWORD) AS DWORD

' ========================================================================================
' Deletes a program object.
' void glDeleteProgram (GLuint program);
' ========================================================================================
DECLARE SUB glDeleteProgram (BYVAL dwProgram AS DWORD)

' ========================================================================================
' Deletes a shader object.
' void APIENTRY glDeleteShader (GLuint);
' typedef void (APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
' ========================================================================================
DECLARE SUB glDeleteShader (BYVAL dwShader AS DWORD)

' ========================================================================================
' Detaches a shader object from a program object to which it is attached.
' void glDetachShader (GLuint program, GLuint shader);
' ========================================================================================
DECLARE SUB glDetachShader (BYVAL dwProgram AS DWORD, BYVAL dwShader AS DWORD)

' ========================================================================================
' Disable a generic vertex attribute array.
' void glDisableVertexAttribArray (GLuint index);
' ========================================================================================
DECLARE SUB glDisableVertexAttribArray (BYVAL dwIndex AS DWORD)

' ========================================================================================
' Enable a generic vertex attribute array.
' void glEnableVertexAttribArray (GLuint index);
' ========================================================================================
DECLARE SUB glEnableVertexAttribArray (BYVAL dwIndex AS DWORD)

' ========================================================================================
' Returns information about an active attribute variable for the specified program object.
' void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length,
' GLint *size, GLenum *type, GLchar *name);
' ========================================================================================
DECLARE SUB glGetActiveAttrib (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF nSize AS LONG, BYREF dwType AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' Returns information about an active uniform variable for the specified program object.
' void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length,
' GLint *size, GLenum *type, GLchar *name);
' ========================================================================================
DECLARE SUB glGetActiveUniform (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF nSize AS LONG, BYREF dwType AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' Returns the handles of the shader objects attached to a program object.
' void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
' ========================================================================================
DECLARE SUB glGetAttachedShaders (BYVAL dwProgram AS DWORD, BYVAL maxCount AS LONG, BYREF nCount AS LONG, BYREF dwShaders AS DWORD)

' ========================================================================================
' Returns the location of an attribute variable.
' GLint glGetAttribLocation (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetAttribLocation (BYVAL dwProgram AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' Returns a parameter from a program object.
' void glGetProgramiv (GLuint program, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramiv (BYVAL dwProgram AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Returns the information log for a program object.
' void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
' ========================================================================================
DECLARE SUB glGetProgramInfoLog (BYVAL dwProgram AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF infoLog AS BYTE)

' ========================================================================================
' Returns a parameter from a shader object.
' void glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetShaderiv (BYVAL dwShader AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Returns the information log for a shader object.
' void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
' ========================================================================================
DECLARE SUB glGetShaderInfoLog (BYVAL dwProgram AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF infoLog AS BYTE)

' ========================================================================================
' Returns the source code string from a shader object.
' void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
' ========================================================================================
DECLARE SUB glGetShaderSource (BYVAL dwShader AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF szSource AS ASCIIZ)

' ========================================================================================
' Returns the location of a uniform variable.
' GLint glGetUniformLocation (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetUniformLocation (BYVAL dwProgram AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' Returns the value of a uniform variable.
' void glGetUniformfv (GLuint program, GLint location, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetUniformfv (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYREF params AS SINGLE)

' ========================================================================================
' Returns the value of a uniform variable.
' void glGetUniformiv (GLuint program, GLint location, GLint *params);
' ========================================================================================
DECLARE SUB glGetUniformiv (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYREF params AS LONG)

' ========================================================================================
' Return a generic vertex attribute parameter.
' void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribdv (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' Return a generic vertex attribute parameter.
' void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribfv (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' Return a generic vertex attribute parameter.
' void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribiv (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' Return a generic vertex attribute parameter.
' void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glGetVertexAttribPointerv (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYVAL params AS DWORD)

' ========================================================================================
' Determines if a name corresponds to a program object.
' GLboolean glIsProgram (GLuint program);
' ========================================================================================
DECLARE FUNCTION glIsProgram (BYVAL dwProgram AS DWORD) AS BYTE

' ========================================================================================
' Determines if a name corresponds to a shader object.
' GLboolean APIENTRY glIsShader (GLuint);
' typedef GLboolean (APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
' ========================================================================================
DECLARE FUNCTION glIsShader (BYVAL dwShader AS DWORD) AS BYTE

' ========================================================================================
' Links a program object.
' void APIENTRY glLinkProgram (GLuint);
' typedef void (APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
' ========================================================================================
DECLARE SUB glLinkProgram (BYVAL dwProgram AS DWORD)

' ========================================================================================
' Replaces the source code in a shader object.
' void glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
' ========================================================================================
DECLARE SUB glShaderSource (BYVAL dwShader AS DWORD, BYVAL nCount AS LONG, BYREF strings AS STRING, BYREF nLength AS LONG)

' ========================================================================================
' Installs a program object as part of current rendering state.
' void glUseProgram (GLuint program);
' ========================================================================================
DECLARE SUB glUseProgram (BYVAL program AS DWORD)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform1f (GLint location, GLfloat v0);
' ========================================================================================
DECLARE SUB glUniform1f (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform2f (GLint location, GLfloat v0, GLfloat v1);
' ========================================================================================
DECLARE SUB glUniform2f (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
' ========================================================================================
DECLARE SUB glUniform3f (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
' ========================================================================================
DECLARE SUB glUniform4f (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, BYVAL v3 AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform1i (GLint location, GLint v0);
' ========================================================================================
DECLARE SUB glUniform1i (BYVAL nLocation AS LONG, BYVAL v0 AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform2i (GLint location, GLint v0, GLint v1);
' ========================================================================================
DECLARE SUB glUniform2i (BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
' ========================================================================================
DECLARE SUB glUniform3i (BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
' ========================================================================================
DECLARE SUB glUniform4i (BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG, BYVAL v3 AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform1fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF fvalue AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform2fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF fvalue AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform3fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF fvalue AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform4fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF fvalue AS SINGLE)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform1iv (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform1iv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF fvalue AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform2iv (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform2iv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF fvalue AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void APIENTRY glUniform3iv (GLint, GLsizei, const GLint *);
' typedef void (APIENTRYP PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform3iv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' Specify the value of a uniform variable for the current program object.
' void glUniform4iv (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform4iv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' Validates a program object.
' void glValidateProgram (GLuint program);
' ========================================================================================
DECLARE SUB glValidateProgram (BYVAL dwProgram AS DWORD)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib1d (GLuint index, GLdouble x);
' ========================================================================================
DECLARE SUB glVertexAttrib1d (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib1dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1dv (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib1f (GLuint index, GLfloat x);
' ========================================================================================
DECLARE SUB glVertexAttrib1f (BYVAL dwIndex AS DWORD, BYVAL v0 AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib1fv (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1fv (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void APIENTRY glVertexAttrib1s (GLuint, GLshort);
' typedef void (APIENTRYP PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
' ========================================================================================
DECLARE SUB glVertexAttrib1s (BYVAL dwIndex AS DWORD, BYVAL v0 AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib1sv (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1sv (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glVertexAttrib2d (BYVAL dwIndex AS DWORD, BYVAL v0 AS DOUBLE, BYVAL v1 AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib2dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2dv (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glVertexAttrib2f (BYVAL dwIndex AS DWORD, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib2fv (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2fv (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glVertexAttrib2s (BYVAL dwIndex AS DWORD, BYVAL v0 AS INTEGER, BYVAL v1 AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib2sv (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2sv (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glVertexAttrib3d (BYVAL dwIndex AS DWORD, BYVAL v0 AS DOUBLE, BYVAL v1 AS DOUBLE, BYVAL v2 AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib3dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3dv (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glVertexAttrib3f (BYVAL dwIndex AS DWORD, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib3fv (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3fv (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glVertexAttrib3s (BYVAL dwIndex AS DWORD, BYVAL v0 AS INTEGER, BYVAL v1 AS INTEGER, BYVAL v2 AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib3sv (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3sv (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4Nbv (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Niv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4Niv (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Nsv (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4Nsv (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
' ========================================================================================
DECLARE SUB glVertexAttrib4Nub (BYVAL dwIndex AS DWORD, BYVAL v0 AS BYTE, BYVAL v1 AS BYTE, BYVAL v2 AS BYTE, BYVAL v3 AS BYTE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4Nubv (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4Nuiv (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4Nusv (GLuint index, const GLushort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4Nusv (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4bv (GLuint index, const GLbyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4bv (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glVertexAttrib4d (BYVAL dwIndex AS DWORD, BYVAL v0 AS DOUBLE, BYVAL v1 AS DOUBLE, BYVAL v2 AS DOUBLE, BYVAL v3 AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4dv (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glVertexAttrib4f (BYVAL dwIndex AS DWORD, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, BYVAL v3 AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void APIENTRY glVertexAttrib4fv (GLuint, const GLfloat *);
' typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4fv (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4iv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4iv (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
' ========================================================================================
DECLARE SUB glVertexAttrib4s (BYVAL dwIndex AS DWORD, BYVAL v0 AS INTEGER, BYVAL v1 AS INTEGER, BYVAL v2 AS INTEGER, BYVAL v3 AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4sv (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4sv (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4ubv (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4ubv (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4uiv (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4uiv (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttrib4usv (GLuint index, const GLushort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4usv (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' Specifies the value of a generic vertex attribute.
' void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized,
' GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribPointer (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL bNormalized AS BYTE, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_2_1)
'%GL_VERSION_2_1 = 1

' ========================================================================================
' void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2x3fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF fvalue AS SINGLE)

' ========================================================================================
' void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3x2fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF fvalue AS SINGLE)

' ========================================================================================
' void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2x4fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF fvalue AS SINGLE)

' ========================================================================================
' void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4x2fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF fvalue AS SINGLE)

' ========================================================================================
' void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3x4fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF fvalue AS SINGLE)

' ========================================================================================
' void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4x3fv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF fvalue AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_3_0)
'%GL_VERSION_3_0 = 1
'/* OpenGL 3.0 also reuses entry points from these extensions: */
'/* ARB_framebuffer_object */
'/* ARB_map_buffer_range */
'/* ARB_vertex_array_object */
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glColorMaski (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
' ========================================================================================
DECLARE SUB glColorMaski (BYVAL dwIndex AS DWORD, BYVAL r AS BYTE, BYVAL g AS BYTE, BYVAL b AS BYTE, BYVAL a AS BYTE)

' ========================================================================================
' void glGetBooleani_v (GLenum target, GLuint index, GLboolean *data);
' ========================================================================================
DECLARE SUB glGetBooleani_v (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF bData AS BYTE)

' ========================================================================================
' void glGetIntegeri_v (GLenum target, GLuint index, GLint *data);
' ========================================================================================
DECLARE SUB glGetIntegeri_v (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF nData AS LONG)

' ========================================================================================
' void glEnablei (GLenum target, GLuint index);
' ========================================================================================
DECLARE SUB glEnablei (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' void glDisablei (GLenum target, GLuint index);
' ========================================================================================
DECLARE SUB glDisablei (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' GLboolean glIsEnabledi (GLenum target, GLuint index);
' ========================================================================================
DECLARE FUNCTION glIsEnabledi (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD) AS BYTE

' ========================================================================================
' void glBeginTransformFeedback (GLenum primitiveMode);
' ========================================================================================
DECLARE SUB glBeginTransformFeedback (BYVAL primitiveMode AS DWORD)

' ========================================================================================
' void glEndTransformFeedback (void);
' ========================================================================================
DECLARE SUB glEndTransformFeedback

' ========================================================================================
' void glBindBufferRange (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glBindBufferRange (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL pSize AS DWORD)

' ========================================================================================
' void glBindBufferBase (GLenum target, GLuint index, GLuint buffer);
' ========================================================================================
DECLARE SUB glBindBufferBase (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD)

' ========================================================================================
' void glTransformFeedbackVaryings (GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
' ========================================================================================
DECLARE SUB glTransformFeedbackVaryings (BYVAL dwProgram AS DWORD, BYVAL nCount AS LONG, BYREF varyings AS ASCIIZ, BYVAL bufferMode AS DWORD)

' ========================================================================================
' void glGetTransformFeedbackVarying (GLuint program, GLuint index, GLint *location);
' ========================================================================================
DECLARE SUB glGetTransformFeedbackVarying (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYREF nLocation AS LONG)

' ========================================================================================
' void glClampColor (GLenum target, GLenum clamp);
' ========================================================================================
DECLARE SUB glClampColor (BYVAL dwTarget AS DWORD, BYVAL dwClamp AS DWORD)

' ========================================================================================
' void glBeginConditionalRender (GLuint id, GLenum mode);
' ========================================================================================
DECLARE SUB glBeginConditionalRender (BYVAL dwId AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' void glEndConditionalRender (void);
' ========================================================================================
DECLARE SUB glEndConditionalRender

' ========================================================================================
' void glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribIPointer (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glGetVertexAttribIiv (GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribIiv (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetVertexAttribIuiv (GLuint index, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribIuiv (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glVertexAttribI1i (GLuint index, GLint x);
' ========================================================================================
DECLARE SUB glVertexAttribI1i (BYVAL dwIndex AS DWORD, BYVAL x AS LONG)

' ========================================================================================
' void APIENTRY glVertexAttribI2i (GLuint, GLint, GLint);
' typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint x, GLint y);
' ========================================================================================
DECLARE SUB glVertexAttribI2i (BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' void glVertexAttribI3i (GLuint index, GLint x, GLint y, GLint z);
' ========================================================================================
DECLARE SUB glVertexAttribI3i (BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' void glVertexAttribI4i (GLuint index, GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glVertexAttribI4i (BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glVertexAttribI1ui (GLuint index, GLuint x);
' ========================================================================================
DECLARE SUB glVertexAttribI1ui (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD)

' ========================================================================================
' void glVertexAttribI2ui (GLuint index, GLuint x, GLuint y);
' ========================================================================================
DECLARE SUB glVertexAttribI2ui (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD)

' ========================================================================================
' void glVertexAttribI3ui (GLuint index, GLuint x, GLuint y, GLuint z);
' ========================================================================================
DECLARE SUB glVertexAttribI3ui (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD)

' ========================================================================================
' void glVertexAttribI4ui (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
' ========================================================================================
DECLARE SUB glVertexAttribI4ui (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD, BYVAL w AS DWORD)

' ========================================================================================
' void glVertexAttribI1iv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI1iv (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI2iv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI2iv (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI3iv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI3iv (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI4iv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4iv (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI1uiv (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI1uiv (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI2uiv (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI2uiv (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI3uiv (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI3uiv (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI4uiv (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4uiv (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI4bv (GLuint index, const GLbyte *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4bv (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttribI4sv (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4sv (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttribI4ubv (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4ubv (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttribI4usv (GLuint index, const GLushort *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4usv (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glGetUniformuiv (GLuint program, GLint location, GLuint *params);
' ========================================================================================
DECLARE SUB glGetUniformuiv (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYREF params AS DWORD)

' ========================================================================================
' void glBindFragDataLocation (GLuint program, GLuint color, const GLchar *name);
' ========================================================================================
DECLARE SUB glBindFragDataLocation (BYVAL dwProgram AS DWORD, BYVAL dwColor AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' GLint glGetFragDataLocation (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetFragDataLocation (BYVAL dwProgram AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' void glUniform1ui (GLint location, GLuint v0);
' ========================================================================================
DECLARE SUB glUniform1ui (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD)

' ========================================================================================
' void glUniform2ui (GLint location, GLuint v0, GLuint v1);
' ========================================================================================
DECLARE SUB glUniform2ui (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD)

' ========================================================================================
' void glUniform3ui (GLint location, GLuint v0, GLuint v1, GLuint v2);
' ========================================================================================
DECLARE SUB glUniform3ui (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD)

' ========================================================================================
' void glUniform4ui (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
' ========================================================================================
DECLARE SUB glUniform4ui (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD, BYVAL v3 AS DWORD)

' ========================================================================================
' void glUniform1uiv (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform1uiv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glUniform2uiv (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform2uiv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glUniform3uiv (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform3uiv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glUniform4uiv (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform4uiv (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glTexParameterIiv (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glTexParameterIiv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glTexParameterIuiv (GLenum target, GLenum pname, const GLuint *params);
' ========================================================================================
DECLARE SUB glTexParameterIuiv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glGetTexParameterIiv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetTexParameterIiv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetTexParameterIuiv (GLenum target, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetTexParameterIuiv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glClearBufferiv (GLenum buffer, const GLint *value);
' ========================================================================================
DECLARE SUB glClearBufferiv (BYVAL dwBuffer AS DWORD, BYREF value AS LONG)

' ========================================================================================
' void glClearBufferuiv (GLenum buffer, const GLuint *value);
' ========================================================================================
DECLARE SUB glClearBufferuiv (BYVAL dwBuffer AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' void glClearBufferfv (GLenum buffer, const GLfloat *value);
' ========================================================================================
DECLARE SUB glClearBufferfv (BYVAL dwBuffer AS DWORD, BYREF value AS SINGLE)

' ========================================================================================
' void glClearBufferfi (GLenum buffer, GLfloat depth, GLint stencil);
' ========================================================================================
DECLARE SUB glClearBufferfi (BYVAL dwBuffer AS DWORD, BYVAL fDepth AS SINGLE, BYVAL nStencil AS LONG)

' ========================================================================================
' const GLubyte * glGetStringi (GLenum name, GLuint index);
' ========================================================================================
DECLARE FUNCTION glGetStringi (BYVAL dwName AS DWORD, BYVAL dwIndex AS DWORD) AS DWORD

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_3_1)
'    %GL_VERSION_3_1 = 1
'/* OpenGL 3.1 also reuses entry points from these extensions: */
'/* ARB_copy_buffer */
'/* ARB_uniform_buffer_object */

' ========================================================================================
' void APIENTRY glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
' ========================================================================================
DECLARE SUB glDrawArraysInstanced (BYVAL dwMode AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS LONG, BYVAL instancecount AS LONG)

' ========================================================================================
' void APIENTRY glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
' ========================================================================================
DECLARE SUB glDrawElementsInstanced (BYVAL dwMode AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL instancecount AS LONG)

' ========================================================================================
' void APIENTRY glTexBuffer (GLenum target, GLenum internalformat, GLuint buffer);
' ========================================================================================
DECLARE SUB glTexBuffer (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwBuffer AS DWORD)

' ========================================================================================
' void APIENTRY glPrimitiveRestartIndex (GLuint index);
' ========================================================================================
DECLARE SUB glPrimitiveRestartIndex (BYVAL dwIndex AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_3_2)
'%GL_VERSION_3_2 = 1
'/* OpenGL 3.2 also reuses entry points from these extensions: */
'/* ARB_draw_elements_base_vertex */
'/* ARB_provoking_vertex */
'/* ARB_sync */
'/* ARB_texture_multisample */

' ========================================================================================
' void APIENTRY glGetInteger64i_v (GLenum target, GLuint index, GLint64 *data);
' ========================================================================================
DECLARE SUB glGetInteger64i_v (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF qdata AS QUAD)

' ========================================================================================
' void APIENTRY glGetBufferParameteri64v (GLenum target, GLenum pname, GLint64 *params);
' ========================================================================================
DECLARE SUB glGetBufferParameteri64v (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF qparams AS QUAD)

' ========================================================================================
' void APIENTRY glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTexture (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_3_3)
'    %GL_VERSION_3_3 = 1
'/* OpenGL 3.3 also reuses entry points from these extensions: */
'/* ARB_blend_func_extended */
'/* ARB_sampler_objects */
'/* ARB_explicit_attrib_location, but it has none */
'/* ARB_occlusion_query2 (no entry points) */
'/* ARB_shader_bit_encoding (no entry points) */
'/* ARB_texture_rgb10_a2ui (no entry points) */
'/* ARB_texture_swizzle (no entry points) */
'/* ARB_timer_query */
'/* ARB_vertex_type_2_10_10_10_rev */
' ========================================================================================
' GLAPI void APIENTRY glVertexAttribDivisor (GLuint index, GLuint divisor);
' ========================================================================================
DECLARE SUB glVertexAttribDivisor (BYVAL dwIndex AS DWORD, BYVAL dwDivisor AS DWORD)
'#ENDIF

'#IF NOT %DEF(%GL_VERSION_4_0)
'    %GL_VERSION_4_0 = 1
'/* OpenGL 4.0 also reuses entry points from these extensions: */
'/* ARB_texture_query_lod (no entry points) */
'/* ARB_draw_indirect */
'/* ARB_gpu_shader5 (no entry points) */
'/* ARB_gpu_shader_fp64 */
'/* ARB_shader_subroutine */
'/* ARB_tessellation_shader */
'/* ARB_texture_buffer_object_rgb32 (no entry points) */
'/* ARB_texture_cube_map_array (no entry points) */
'/* ARB_texture_gather (no entry points) */
'/* ARB_transform_feedback2 */
'/* ARB_transform_feedback3 */
' ========================================================================================
' GLAPI void APIENTRY glMinSampleShading (GLclampf value);
' ========================================================================================
DECLARE SUB glMinSampleShading (BYVAL value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glBlendEquationi (GLuint buf, GLenum mode);
' ========================================================================================
DECLARE SUB glBlendEquationi (BYVAL buf AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBlendEquationSeparatei (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
' ========================================================================================
DECLARE SUB glBlendEquationSeparatei (BYVAL buf AS DWORD, BYVAL modeRGB AS DWORD, BYVAL modeAlpha AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBlendFunci (GLuint buf, GLenum src, GLenum dst);
' ========================================================================================
DECLARE SUB glBlendFunci (BYVAL buf AS DWORD, BYVAL src AS DWORD, BYVAL dst AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBlendFuncSeparatei (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
' ========================================================================================
DECLARE SUB glBlendFuncSeparatei (BYVAL buf AS DWORD, BYVAL srcRGB AS DWORD, BYVAL dstRGB AS DWORD, BYVAL srcAlpha AS DWORD, BYVAL dstAlpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_VERSION_4_1)
'    %GL_VERSION_4_1 = 1
'/* OpenGL 4.1 reuses entry points from these extensions: */
'/* ARB_ES2_compatibility */
'/* ARB_get_program_binary */
'/* ARB_separate_shader_objects */
'/* ARB_shader_precision (no entry points) */
'/* ARB_vertex_attrib_64bit */
'/* ARB_viewport_array */
'#ENDIF

'#IF NOT %DEF(%GL_VERSION_4_2)
'    %GL_VERSION_4_2 = 1
'/* OpenGL 4.2 reuses entry points from these extensions: */
'/* ARB_base_instance */
'/* ARB_shading_language_420pack (no entry points) */
'/* ARB_transform_feedback_instanced */
'/* ARB_compressed_texture_pixel_storage (no entry points) */
'/* ARB_conservative_depth (no entry points) */
'/* ARB_internalformat_query */
'/* ARB_map_buffer_alignment (no entry points) */
'/* ARB_shader_atomic_counters */
'/* ARB_shader_image_load_store */
'/* ARB_shading_language_packing (no entry points) */
'/* ARB_texture_storage */
'#ENDIF

#IF NOT %DEF(%GL_VERSION_4_3)
%GL_VERSION_4_3 = 1
'/* OpenGL 4.3 reuses entry points from these extensions: */
'/* ARB_arrays_of_arrays (no entry points, GLSL only) */
'/* ARB_fragment_layer_viewport (no entry points, GLSL only) */
'/* ARB_shader_image_size (no entry points, GLSL only) */
'/* ARB_ES3_compatibility (no entry points) */
'/* ARB_clear_buffer_object */
'/* ARB_compute_shader */
'/* ARB_copy_image */
'/* KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes) */
'/* ARB_explicit_uniform_location (no entry points) */
'/* ARB_framebuffer_no_attachments */
'/* ARB_internalformat_query2 */
'/* ARB_invalidate_subdata */
'/* ARB_multi_draw_indirect */
'/* ARB_program_interface_query */
'/* ARB_robust_buffer_access_behavior (no entry points) */
'/* ARB_shader_storage_buffer_object */
'/* ARB_stencil_texturing (no entry points) */
'/* ARB_texture_buffer_range */
'/* ARB_texture_query_levels (no entry points) */
'/* ARB_texture_storage_multisample */
'/* ARB_texture_view */
'/* ARB_vertex_attrib_binding */
#ENDIF

'#IF NOT %DEF(%GL_ARB_multitexture)
'%GL_ARB_multitexture  = 1

' ========================================================================================
' Select active texture unit.
' void glActiveTextureARB (GLenum texture);
' ========================================================================================
DECLARE SUB glActiveTextureARB (BYVAL dwTexture AS DWORD)

' ========================================================================================
' Select active texture unit.
' void glClientActiveTextureARB (GLenum texture);
' ========================================================================================
DECLARE SUB glClientActiveTextureARB (BYVAL dwTexture AS DWORD)

' ========================================================================================
' void glMultiTexCoord1dARB (GLenum target, GLdouble s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1dARB (BYVAL dwUnit AS DWORD, BYVAL s AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord1dvARB (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1dvARB (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord1fARB (GLenum target, GLfloat s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1fARB (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE)

' ========================================================================================
' void glMultiTexCoord1fvARB (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1fvARB (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glMultiTexCoord1iARB (GLenum target, GLint s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1iARB (BYVAL dwTarget AS DWORD, BYVAL s AS LONG)

' ========================================================================================
' void glMultiTexCoord1ivARB (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1ivARB (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glMultiTexCoord1sARB (GLenum target, GLshort s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1sARB (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER)

' ========================================================================================
' void glMultiTexCoord1svARB (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1svARB (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glMultiTexCoord2dARB (GLenum target, GLdouble s, GLdouble t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2dARB (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE, BYVAL t AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord2dvARB (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2dvARB (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord2fARB (GLenum target, GLfloat s, GLfloat t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2fARB (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE)

' ========================================================================================
' void glMultiTexCoord2fvARB (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2fvARB (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glMultiTexCoord2iARB (GLenum target, GLint s, GLint t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2iARB (BYVAL dwTarget AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG)

' ========================================================================================
' void glMultiTexCoord2ivARB (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2ivARB (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glMultiTexCoord2sARB (GLenum target, GLshort s, GLshort t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2sARB (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER, BYVAL t AS INTEGER)

' ========================================================================================
' void glMultiTexCoord2svARB (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2svARB (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glMultiTexCoord3dARB (GLenum target, GLdouble s, GLdouble t, GLdouble r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3dARB (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE, BYVAL t AS DOUBLE, BYVAL u AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord3dvARB (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3dvARB (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord3fARB (GLenum target, GLfloat s, GLfloat t, GLfloat r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3fARB (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL u AS SINGLE)

' ========================================================================================
' void glMultiTexCoord3fvARB (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3fvARB (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glMultiTexCoord3iARB (GLenum target, GLint s, GLint t, GLint r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3iARB (BYVAL dwTarget AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG, BYVAL u AS LONG)

' ========================================================================================
' void glMultiTexCoord3ivARB (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3ivARB (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glMultiTexCoord3sARB (GLenum target, GLshort s, GLshort t, GLshort r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3sARB (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER, BYVAL t AS INTEGER, BYVAL u AS INTEGER)

' ========================================================================================
' void glMultiTexCoord3svARB (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3svARB (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void APIENTRY glMultiTexCoord4dARB (GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
' typedef void (APIENTRYP PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4dARB (BYVAL dwTarget AS DWORD, BYVAL s AS DOUBLE, BYVAL t AS DOUBLE, BYVAL u AS DOUBLE, BYVAL v AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord4dvARB (GLenum target, const GLdouble *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4dvARB (BYVAL dwTarget AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glMultiTexCoord4fARB (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4fARB (BYVAL dwTarget AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL u AS SINGLE, BYVAL v AS SINGLE)

' ========================================================================================
' void glMultiTexCoord4fvARB (GLenum target, const GLfloat *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4fvARB (BYVAL dwTarget AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glMultiTexCoord4iARB (GLenum target, GLint s, GLint t, GLint r, GLint q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4iARB (BYVAL dwTarget AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG, BYVAL u AS LONG, BYVAL v AS LONG)

' ========================================================================================
' void glMultiTexCoord4ivARB (GLenum target, const GLint *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4ivARB (BYVAL dwTarget AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glMultiTexCoord4sARB (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4sARB (BYVAL dwTarget AS DWORD, BYVAL s AS INTEGER, BYVAL t AS INTEGER, BYVAL u AS INTEGER, BYVAL v AS INTEGER)

' ========================================================================================
' void glMultiTexCoord4svARB (GLenum target, const GLshort *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4svARB (BYVAL dwTarget AS DWORD, BYREF v AS INTEGER)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_transpose_matrix)
'%GL_ARB_transpose_matrix = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glLoadTransposeMatrixfARB (const GLfloat *m);
' ========================================================================================
DECLARE SUB glLoadTransposeMatrixfARB (BYREF m AS SINGLE)

' ========================================================================================
' void glLoadTransposeMatrixdARB (const GLdouble *m);
' ========================================================================================
DECLARE SUB glLoadTransposeMatrixdARB (BYREF m AS DOUBLE)

' ========================================================================================
' void glMultTransposeMatrixfARB (const GLfloat *m);
' ========================================================================================
DECLARE SUB glMultTransposeMatrixfARB (BYREF m AS SINGLE)

' ========================================================================================
' void glMultTransposeMatrixdARB (const GLdouble *m);
' ========================================================================================
DECLARE SUB glMultTransposeMatrixdARB (BYREF m AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_multisample)
'%GL_ARB_multisample = 1

' ========================================================================================
' void glSampleCoverageARB (GLclampf value, GLboolean invert);
' ========================================================================================
DECLARE SUB glSampleCoverageARB (BYVAL fValue AS SINGLE, BYVAL bInvert AS BYTE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_env_add)
'%GL_ARB_texture_env_add = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_cube_map)
'%GL_ARB_texture_cube_map = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_compression)
'%GL_ARB_texture_compression = 1

' ========================================================================================
' void glCompressedTexImage3DARB (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexImage3DARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glCompressedTexImage2DARB (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexImage2DARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void APIENTRY glCompressedTexImage1DARB (GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
' void glCompressedTexImage1DARB (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexImage1DARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glCompressedTexSubImage3DARB (GLenum target, GLint level, GLint xoffset,
' GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexSubImage3DARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
   BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glCompressedTexSubImage2DARB (GLenum target, GLint level, GLint xoffset,
' GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexSubImage2DARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glCompressedTexSubImage1DARB (GLenum target, GLint level, GLint xoffset,
' GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
' ========================================================================================
DECLARE SUB glCompressedTexSubImage1DARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glGetCompressedTexImageARB (GLenum target, GLint level, GLvoid *img);
' ========================================================================================
DECLARE SUB glGetCompressedTexImageARB (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL pImg AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_border_clamp)
'%GL_ARB_texture_border_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_point_parameters)
'%GL_ARB_point_parameters = 1

' ========================================================================================
' void glPointParameterfARB (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPointParameterfARB (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void APIENTRY glPointParameterfvARB (GLenum, const GLfloat *);
' typedef void (APIENTRYP PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glPointParameterfvARB (BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_blend)
'%GL_ARB_vertex_blend = 1

' ========================================================================================
' void glWeightbvARB (GLint size, const GLbyte *weights);
' ========================================================================================
DECLARE SUB glWeightbvARB (BYVAL nSize AS LONG, BYREF weights AS BYTE)

' ========================================================================================
' void glWeightsvARB (GLint size, const GLshort *weights);
' ========================================================================================
DECLARE SUB glWeightsvARB (BYVAL nSize AS LONG, BYREF weights AS INTEGER)

' ========================================================================================
' void APIENTRY glWeightivARB (GLint, const GLint *);
' typedef void (APIENTRYP PFNGLWEIGHTIVARBPROC) (GLint size, const GLint *weights);
' ========================================================================================
DECLARE SUB glWeightivARB (BYVAL nSize AS LONG, BYREF weights AS LONG)

' ========================================================================================
' void APIENTRY glWeightfvARB (GLint, const GLfloat *);
' typedef void (APIENTRYP PFNGLWEIGHTFVARBPROC) (GLint size, const GLfloat *weights);
' ========================================================================================
DECLARE SUB glWeightfvARB (BYVAL nSize AS LONG, BYREF weights AS SINGLE)

' ========================================================================================
' void APIENTRY glWeightdvARB (GLint, const GLdouble *);
' typedef void (APIENTRYP PFNGLWEIGHTDVARBPROC) (GLint size, const GLdouble *weights);
' ========================================================================================
DECLARE SUB glWeightdvARB (BYVAL nSize AS LONG, BYREF weights AS DOUBLE)

' ========================================================================================
' void glWeightubvARB (GLint size, const GLubyte *weights);
' ========================================================================================
DECLARE SUB glWeightubvARB (BYVAL nSize AS LONG, BYREF weights AS BYTE)

' ========================================================================================
' void glWeightusvARB (GLint size, const GLushort *weights);
' ========================================================================================
DECLARE SUB glWeightusvARB (BYVAL nSize AS LONG, BYREF weights AS WORD)

' ========================================================================================
' void glWeightuivARB (GLint size, const GLuint *weights);
' ========================================================================================
DECLARE SUB glWeightuivARB (BYVAL n AS LONG, BYREF weights AS DWORD)

' ========================================================================================
' void glWeightPointerARB (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glWeightPointerARB (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glVertexBlendARB (GLint count);
' ========================================================================================
DECLARE SUB glVertexBlendARB (BYVAL nCount AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_matrix_palette)
'%GL_ARB_matrix_palette = 1

' ========================================================================================
' void glCurrentPaletteMatrixARB (GLint index);
' ========================================================================================
DECLARE SUB glCurrentPaletteMatrixARB (BYVAL index AS LONG)

' ========================================================================================
' void glMatrixIndexubvARB (GLint size, const GLubyte *indices);
' ========================================================================================
DECLARE SUB glMatrixIndexubvARB (BYVAL nSize AS LONG, BYREF indices AS BYTE)

' ========================================================================================
' void glMatrixIndexusvARB (GLint size, const GLushort *indices);
' ========================================================================================
DECLARE SUB glMatrixIndexusvARB (BYVAL nSize AS LONG, BYREF indices AS WORD)

' ========================================================================================
' void glMatrixIndexuivARB (GLint size, const GLuint *indices);
' ========================================================================================
DECLARE SUB glMatrixIndexuivARB (BYVAL nSize AS LONG, BYREF indices AS DWORD)

' ========================================================================================
' void glMatrixIndexPointerARB (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glMatrixIndexPointerARB (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_env_combine)
'%GL_ARB_texture_env_combine = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_env_crossbar)
'%GL_ARB_texture_env_crossbar = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_env_dot3)
'%GL_ARB_texture_env_dot3 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_mirrored_repeat)
'%GL_ARB_texture_mirrored_repeat = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_depth_texture)
'%GL_ARB_depth_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shadow)
'%GL_ARB_shadow = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shadow_ambient)
'%GL_ARB_shadow_ambient = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_window_pos)
'%GL_ARB_window_pos = 1

' ========================================================================================
' void glWindowPos2dARB (GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glWindowPos2dARB (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void glWindowPos2dvARB (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos2dvARB (BYREF v AS DOUBLE)

' ========================================================================================
' void glWindowPos2fARB (GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glWindowPos2fARB (BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' void glWindowPos2fvARB (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos2fvARB (BYREF v AS SINGLE)

' ========================================================================================
' void glWindowPos2iARB (GLint x, GLint y);
' ========================================================================================
DECLARE SUB glWindowPos2iARB (BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' void glWindowPos2ivARB (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos2ivARB (BYREF v AS LONG)

' ========================================================================================
' void glWindowPos2sARB (GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glWindowPos2sARB (BYVAL x AS INTEGER, BYVAL y AS INTEGER)

' ========================================================================================
' void glWindowPos2svARB (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos2svARB (BYREF v AS INTEGER)

' ========================================================================================
' void glWindowPos3dARB (GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glWindowPos3dARB (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glWindowPos3dvARB (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos3dvARB (BYREF v AS DOUBLE)

' ========================================================================================
' void glWindowPos3fARB (GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glWindowPos3fARB (BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void APIENTRY glWindowPos3fvARB (const GLfloat *);
' typedef void (APIENTRYP PFNGLWINDOWPOS3FVARBPROC) (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos3fvARB (BYREF v AS SINGLE)

' ========================================================================================
' void glWindowPos3iARB (GLint x, GLint y, GLint z);
' ========================================================================================
DECLARE SUB glWindowPos3iARB (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' void glWindowPos3ivARB (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos3ivARB (BYREF v AS LONG)

' ========================================================================================
' void glWindowPos3sARB (GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glWindowPos3sARB (BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER)

' ========================================================================================
' void glWindowPos3svARB (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos3svARB (BYREF v AS INTEGER)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_program)
'%GL_ARB_vertex_program = 1

' ========================================================================================
' void glVertexAttrib1dARB (GLuint index, GLdouble x);
' ========================================================================================
DECLARE SUB glVertexAttrib1dARB (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE)

' ========================================================================================
' void glVertexAttrib1dvARB (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1dvARB (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib1fARB (GLuint index, GLfloat x);
' ========================================================================================
DECLARE SUB glVertexAttrib1fARB (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE)

' ========================================================================================
' void glVertexAttrib1fvARB (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1fvARB (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib1sARB (GLuint index, GLshort x);
' ========================================================================================
DECLARE SUB glVertexAttrib1sARB (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER)

' ========================================================================================
' void glVertexAttrib1svARB (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1svARB (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib2dARB (GLuint index, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glVertexAttrib2dARB (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void glVertexAttrib2dvARB (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2dvARB (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib2fARB (GLuint index, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glVertexAttrib2fARB (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' void glVertexAttrib2fvARB (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2fvARB (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib2sARB (GLuint index, GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glVertexAttrib2sARB (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER)

' ========================================================================================
' void glVertexAttrib2svARB (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2svARB (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib3dARB (GLuint index, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glVertexAttrib3dARB (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glVertexAttrib3dvARB (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3dvARB (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib3fARB (GLuint index, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glVertexAttrib3fARB (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glVertexAttrib3fvARB (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3fvARB (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib3sARB (GLuint index, GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glVertexAttrib3sARB (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER)

' ========================================================================================
' void glVertexAttrib3svARB (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3svARB (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib4NbvARB (GLuint index, const GLbyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4NbvARB (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttrib4NivARB (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4NivARB (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttrib4NsvARB (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4NsvARB (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib4NubARB (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
' ========================================================================================
DECLARE SUB glVertexAttrib4NubARB (BYVAL dwIndex AS DWORD, BYVAL x AS BYTE, BYVAL y AS BYTE, BYVAL z AS BYTE, BYVAL w AS BYTE)

' ========================================================================================
' void glVertexAttrib4NubvARB (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4NubvARB (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttrib4NuivARB (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4NuivARB (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttrib4NusvARB (GLuint index, const GLushort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4NusvARB (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttrib4bvARB (GLuint index, const GLbyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4bvARB (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttrib4dARB (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glVertexAttrib4dARB (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glVertexAttrib4dvARB (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4dvARB (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib4fARB (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glVertexAttrib4fARB (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glVertexAttrib4fvARB (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4fvARB (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib4ivARB (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4ivARB (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttrib4sARB (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
' ========================================================================================
DECLARE SUB glVertexAttrib4sARB (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER, BYVAL w AS INTEGER)

' ========================================================================================
' void glVertexAttrib4svARB (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4svARB (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib4ubvARB (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4ubvARB (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttrib4uivARB (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4uivARB (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttrib4usvARB (GLuint index, const GLushort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4usvARB (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttribPointerARB (GLuint index, GLint size, GLenum type,
' GLboolean normalized, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribPointerARB (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL bNormalized AS BYTE, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glEnableVertexAttribArrayARB (GLuint index);
' ========================================================================================
DECLARE SUB glEnableVertexAttribArrayARB (BYVAL dwIndex AS DWORD)

' ========================================================================================
' void glDisableVertexAttribArrayARB (GLuint index);
' ========================================================================================
DECLARE SUB glDisableVertexAttribArrayARB (BYVAL dwIndex AS DWORD)

' ========================================================================================
' void glProgramStringARB (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
' ========================================================================================
DECLARE SUB glProgramStringARB (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL nLen AS LONG, BYVAL pString AS DWORD)

' ========================================================================================
' void glBindProgramARB (GLenum target, GLuint program);
' ========================================================================================
DECLARE SUB glBindProgramARB (BYVAL dwTarget AS DWORD, BYVAL dwProgram AS DWORD)

' ========================================================================================
' void glDeleteProgramsARB (GLsizei n, const GLuint *programs);
' ========================================================================================
DECLARE SUB glDeleteProgramsARB (BYVAL n AS LONG, BYREF programs AS DWORD)

' ========================================================================================
' void glGenProgramsARB (GLsizei n, GLuint *programs);
' ========================================================================================
DECLARE SUB glGenProgramsARB (BYVAL n AS LONG, BYREF programs AS DWORD)

' ========================================================================================
' void glProgramEnvParameter4dARB (GLenum target, GLuint index, GLdouble x, GLdouble y,
' GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glProgramEnvParameter4dARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glProgramEnvParameter4dvARB (GLenum target, GLuint index, const GLdouble *params);
' ========================================================================================
DECLARE SUB glProgramEnvParameter4dvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glProgramEnvParameter4fARB (GLenum target, GLuint index, GLfloat x, GLfloat y,
' GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glProgramEnvParameter4fARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glProgramEnvParameter4fvARB (GLenum target, GLuint index, const GLfloat *params);
' ========================================================================================
DECLARE SUB glProgramEnvParameter4fvARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glProgramLocalParameter4dARB (GLenum target, GLuint index, GLdouble x, GLdouble y,
' GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glProgramLocalParameter4dARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glProgramLocalParameter4dvARB (GLenum target, GLuint index, const GLdouble *params);
' ========================================================================================
DECLARE SUB glProgramLocalParameter4dvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glProgramLocalParameter4fARB (GLenum target, GLuint index, GLfloat x, GLfloat y,
' GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glProgramLocalParameter4fARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glProgramLocalParameter4fvARB (GLenum target, GLuint index, const GLfloat *params);
' ========================================================================================
DECLARE SUB glProgramLocalParameter4fvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetProgramEnvParameterdvARB (GLenum target, GLuint index, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetProgramEnvParameterdvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetProgramEnvParameterfvARB (GLenum target, GLuint index, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetProgramEnvParameterfvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetProgramLocalParameterdvARB (GLenum target, GLuint index, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetProgramLocalParameterdvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetProgramLocalParameterfvARB (GLenum target, GLuint index, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetProgramLocalParameterfvARB (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetProgramivARB (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramivARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetProgramStringARB (GLenum target, GLenum pname, GLvoid *string);
' ========================================================================================
DECLARE SUB glGetProgramStringARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL pstring AS DWORD)

' ========================================================================================
' void glGetVertexAttribdvARB (GLuint index, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribdvARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetVertexAttribfvARB (GLuint index, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribfvARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetVertexAttribivARB (GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribivARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetVertexAttribPointervARB (GLuint index, GLenum pname, GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glGetVertexAttribPointervARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' GLboolean glIsProgramARB (GLuint program);
' ========================================================================================
DECLARE FUNCTION glIsProgramARB (BYVAL dwProgram AS DWORD) AS BYTE

'#ENDIF

'#IF NOT %DEF(%GL_ARB_fragment_program)
'%GL_ARB_fragment_program = 1
''/* All ARB_fragment_program entry points are shared with ARB_vertex_program. */
'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_buffer_object)
'%GL_ARB_vertex_buffer_object = 1

' ========================================================================================
' void glBindBufferARB (GLenum target, GLuint buffer);
' ========================================================================================
DECLARE SUB glBindBufferARB (BYVAL dwTarget AS DWORD, BYVAL dwBuffer AS DWORD)

' ========================================================================================
' void glDeleteBuffersARB (GLsizei n, const GLuint *buffers);
' ========================================================================================
DECLARE SUB glDeleteBuffersARB (BYVAL n AS LONG, BYREF dwBuffers AS DWORD)

' ========================================================================================
' void glGenBuffersARB (GLsizei n, GLuint *buffers);
' ========================================================================================
DECLARE SUB glGenBuffersARB (BYVAL n AS LONG, BYREF dwBuffers AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsBufferARB (GLuint);
' typedef GLboolean (APIENTRYP PFNGLISBUFFERARBPROC) (GLuint buffer);
' ========================================================================================
DECLARE FUNCTION glIsBufferARB (BYVAL dwBuffer AS DWORD) AS BYTE

' ========================================================================================
' void glBufferDataARB (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
' ========================================================================================
DECLARE SUB glBufferDataARB (BYVAL dwTarget AS DWORD, BYVAL dwSize AS DWORD, BYVAL pData AS DWORD, BYVAL dwUsage AS DWORD)

' ========================================================================================
' void glBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
' ========================================================================================
DECLARE SUB glBufferSubDataARB (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glGetBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
' ========================================================================================
DECLARE SUB glGetBufferSubDataARB (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' GLvoid* glMapBufferARB (GLenum target, GLenum access);
' ========================================================================================
DECLARE FUNCTION glMapBufferARB (BYVAL dwTarget AS DWORD, BYVAL dwAccess AS DWORD) AS DWORD

' ========================================================================================
' GLboolean glUnmapBufferARB (GLenum target);
' ========================================================================================
DECLARE FUNCTION glUnmapBufferARB (BYVAL dwTarget AS DWORD) AS BYTE

' ========================================================================================
' void glGetBufferParameterivARB (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetBufferParameterivARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params aS LONG)

' ========================================================================================
' void glGetBufferPointervARB (GLenum target, GLenum pname, GLvoid* *params);
' ========================================================================================
DECLARE SUB glGetBufferPointervARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_occlusion_query)
'%GL_ARB_occlusion_query = 1

' ========================================================================================
' void glGenQueriesARB (GLsizei n, GLuint *ids);
' ========================================================================================
DECLARE SUB glGenQueriesARB (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' void glDeleteQueriesARB (GLsizei n, const GLuint *ids);
' ========================================================================================
DECLARE SUB glDeleteQueriesARB (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' GLboolean glIsQueryARB (GLuint id);
' ========================================================================================
DECLARE FUNCTION glIsQueryARB (BYVAL dwId AS DWORD) AS BYTE

' ========================================================================================
' void glBeginQueryARB (GLenum target, GLuint id);
' ========================================================================================
DECLARE SUB glBeginQueryARB (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD)

' ========================================================================================
' void glEndQueryARB (GLenum target);
' ========================================================================================
DECLARE SUB glEndQueryARB (BYVAL dwTarget AS DWORD)

' ========================================================================================
' void glGetQueryivARB (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetQueryivARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetQueryObjectivARB (GLuint id, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetQueryObjectivARB (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetQueryObjectuivARB (GLuint id, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetQueryObjectuivARB (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_objects)
'%GL_ARB_shader_objects = 1

' ========================================================================================
' void glDeleteObjectARB (GLhandleARB obj);
' ========================================================================================
DECLARE SUB glDeleteObjectARB (BYVAL dwObj AS DWORD)

' ========================================================================================
' GLhandleARB glGetHandleARB (GLenum pname);
' ========================================================================================
DECLARE FUNCTION glGetHandleARB (BYVAL pname AS DWORD) AS DWORD

' ========================================================================================
' void glDetachObjectARB (GLhandleARB containerObj, GLhandleARB attachedObj);
' ========================================================================================
DECLARE SUB glDetachObjectARB (BYVAL containerObj AS DWORD, BYVAL attachedObj AS DWORD)

' ========================================================================================
' GLhandleARB glCreateShaderObjectARB (GLenum shaderType);
' ========================================================================================
DECLARE FUNCTION glCreateShaderObjectARB (BYVAL shaderType AS DWORD) AS DWORD

' ========================================================================================
' void glShaderSourceARB (GLhandleARB shaderObj, GLsizei count, const GLcharARB* *string, const GLint *length);
' ========================================================================================
DECLARE SUB glShaderSourceARB (BYVAL shaderObj AS DWORD, BYVAL nCount AS LONG, BYREF strings AS STRING, BYREF nLength AS LONG)

' ========================================================================================
' void glCompileShaderARB (GLhandleARB shaderObj);
' ========================================================================================
DECLARE SUB glCompileShaderARB (BYVAL shaderObj AS DWORD)

' ========================================================================================
' GLhandleARB glCreateProgramObjectARB (void);
' ========================================================================================
DECLARE FUNCTION glCreateProgramObjectARB () AS DWORD

' ========================================================================================
' void glAttachObjectARB (GLhandleARB containerObj, GLhandleARB obj);
' ========================================================================================
DECLARE SUB glAttachObjectARB (BYVAL dwContainerObj AS  DWORD, BYVAL dwObj AS DWORD)

' ========================================================================================
' void glLinkProgramARB (GLhandleARB programObj);
' ========================================================================================
DECLARE SUB glLinkProgramARB (BYVAL programObj AS DWORD)

' ========================================================================================
' void glUseProgramObjectARB (GLhandleARB programObj);
' ========================================================================================
DECLARE SUB glUseProgramObjectARB (BYVAL programObj AS DWORD)

' ========================================================================================
' void glValidateProgramARB (GLhandleARB programObj);
' ========================================================================================
DECLARE SUB glValidateProgramARB (BYVAL programObj AS DWORD)

' ========================================================================================
' void glUniform1fARB (GLint location, GLfloat v0);
' ========================================================================================
DECLARE SUB glUniform1fARB (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE)

' ========================================================================================
' void glUniform2fARB (GLint location, GLfloat v0, GLfloat v1);
' ========================================================================================
DECLARE SUB glUniform2fARB (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE)

' ========================================================================================
' void APIENTRY glUniform3fARB (GLint, GLfloat, GLfloat, GLfloat);
' typedef void (APIENTRYP PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
' ========================================================================================
DECLARE SUB glUniform3fARB (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE)

' ========================================================================================
' void glUniform4fARB (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
' ========================================================================================
DECLARE SUB glUniform4fARB (BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, BYVAL v3 AS SINGLE)

' ========================================================================================
' void glUniform1iARB (GLint location, GLint v0);
' ========================================================================================
DECLARE SUB glUniform1iARB (BYVAL nLocation AS LONG, BYVAL v0 AS LONG)

' ========================================================================================
' void glUniform2iARB (GLint location, GLint v0, GLint v1);
' ========================================================================================
DECLARE SUB glUniform2iARB (BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG)

' ========================================================================================
' void glUniform3iARB (GLint location, GLint v0, GLint v1, GLint v2);
' ========================================================================================
DECLARE SUB glUniform3iARB (BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG)

' ========================================================================================
' void glUniform4iARB (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
' ========================================================================================
DECLARE SUB glUniform4iARB (BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG, BYVAL v3 AS LONG)

' ========================================================================================
' void glUniform1fvARB (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform1fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glUniform2fvARB (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform2fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glUniform3fvARB (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform3fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glUniform4fvARB (GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniform4fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glUniform1ivARB (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform1ivARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glUniform2ivARB (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform2ivARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glUniform3ivARB (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform3ivARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glUniform4ivARB (GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glUniform4ivARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glUniformMatrix2fvARB (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glUniformMatrix3fvARB (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glUniformMatrix4fvARB (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4fvARB (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glGetObjectParameterfvARB (GLhandleARB obj, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetObjectParameterfvARB (BYVAL dwObj AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetObjectParameterivARB (GLhandleARB obj, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetObjectParameterivARB (BYVAL dwObj AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetInfoLogARB (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
' ========================================================================================
DECLARE SUB glGetInfoLogARB (BYVAL dwObj AS DWORD, BYVAL maxLength AS LONG, BYREF nLength AS LONG, BYREF infoLog AS ASCIIZ)

' ========================================================================================
' void glGetAttachedObjectsARB (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
' ========================================================================================
DECLARE SUB glGetAttachedObjectsARB (BYVAL containerObj AS DWORD, BYVAL maxCount AS LONG, BYREF nCount AS LONG, BYREF dwObj AS DWORD)

' ========================================================================================
' GLint glGetUniformLocationARB (GLhandleARB programObj, const GLcharARB *name);
' ========================================================================================
DECLARE FUNCTION glGetUniformLocationARB (BYVAL programObj AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' void glGetActiveUniformARB (GLhandleARB programObj, GLuint index, GLsizei maxLength,
' GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
' ========================================================================================
DECLARE SUB glGetActiveUniformARB (BYVAL programObj AS DWORD, BYVAL dwIndex AS DWORD, BYVAL maxLength AS LONG, BYREF nLength AS LONG, BYREF nSize AS LONG, BYREF dwType AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' void glGetUniformfvARB (GLhandleARB programObj, GLint location, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetUniformfvARB (BYVAL programObj AS DWORD, BYVAL nLocation AS LONG, BYREF params AS SINGLE)

' ========================================================================================
' void glGetUniformivARB (GLhandleARB programObj, GLint location, GLint *params);
' ========================================================================================
DECLARE SUB glGetUniformivARB (BYVAL programObj AS DWORD, BYVAL nLocation AS LONG, BYREF params AS LONG)

' ========================================================================================
' void glGetShaderSourceARB (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
' ========================================================================================
DECLARE SUB glGetShaderSourceARB (BYVAL dwObj AS DWORD, BYVAL maxLength AS LONG, BYREF nLength AS LONG, BYREF szSource AS ASCIIZ)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_shader)
'%GL_ARB_vertex_shader = 1

' ========================================================================================
' void glBindAttribLocationARB (GLhandleARB programObj, GLuint index, const GLcharARB *name);
' ========================================================================================
DECLARE SUB glBindAttribLocationARB (BYVAL programObj AS DWORD, BYVAL dwIndex AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' void glGetActiveAttribARB (GLhandleARB programObj, GLuint index, GLsizei maxLength,
' GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
' ========================================================================================
DECLARE SUB glGetActiveAttribARB (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYVAL maxLength AS LONG, BYREF nLength AS LONG, BYREF nSize AS LONG, BYREF dwType AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' GLint glGetAttribLocationARB (GLhandleARB programObj, const GLcharARB *name);
' ========================================================================================
DECLARE FUNCTION glGetAttribLocationARB (BYVAL programObj AS DWORD, BYREF szName AS ASCIIZ) AS LONG

'#ENDIF

'#IF NOT %DEF(%GL_ARB_fragment_shader)
'%GL_ARB_fragment_shader = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shading_language_100)
'%GL_ARB_shading_language_100 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_non_power_of_two)
'%GL_ARB_texture_non_power_of_two = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_point_sprite)
'%GL_ARB_point_sprite = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_fragment_program_shadow)
'%GL_ARB_fragment_program_shadow = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_draw_buffers)
'%GL_ARB_draw_buffers = 1

' ========================================================================================
' void glDrawBuffersARB (GLsizei n, const GLenum *bufs);
' ========================================================================================
DECLARE SUB glDrawBuffersARB (BYVAL n AS LONG, BYREF bufs AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_rectangle)
'%GL_ARB_texture_rectangle = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_color_buffer_float)
'%GL_ARB_color_buffer_float = 1

' ========================================================================================
' void APIENTRY glClampColorARB (GLenum, GLenum);
' typedef void (APIENTRYP PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
' ========================================================================================
DECLARE SUB glClampColorARB (BYVAL dwTarget AS DWORD, BYVAL dwClamp AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_half_float_pixel)
'%GL_ARB_half_float_pixel = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_float)
'%GL_ARB_texture_float = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_pixel_buffer_object)
'%GL_ARB_pixel_buffer_object = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_depth_buffer_float)
'%GL_ARB_depth_buffer_float = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_draw_instanced)
'%GL_ARB_draw_instanced = 1

' ========================================================================================
' void glDrawArraysInstancedARB (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
' ========================================================================================
DECLARE SUB glDrawArraysInstancedARB (BYVAL dwMode AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS  LONG, BYVAL primcount AS LONG)

' ========================================================================================
' void glDrawElementsInstancedARB (GLenum mode, GLsizei count, GLenum type,
' const GLvoid *indices, GLsizei primcount);
' ========================================================================================
DECLARE SUB glDrawElementsInstancedARB (BYVAL dwMode AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL primcount AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_framebuffer_object)
'%GL_ARB_framebuffer_object = 1

' ========================================================================================
' GLboolean glIsRenderbuffer (GLuint renderbuffer);
' ========================================================================================
DECLARE FUNCTION glIsRenderbuffer (BYVAL dwrenderbuffer AS DWORD) AS BYTE

' ========================================================================================
' void glBindRenderbuffer (GLenum target, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glBindRenderbuffer (BYVAL dwTarget AS DWORD, BYVAL dwrenderbuffer AS DWORD)

' ========================================================================================
' void glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers);
' ========================================================================================
DECLARE SUB glDeleteRenderbuffers (BYVAL n AS LONG, BYREF dwrenderbuffers AS DWORD)

' ========================================================================================
' void APIENTRY glGenRenderbuffers (GLsizei, GLuint *);
' typedef void (APIENTRYP PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint *renderbuffers);
' ========================================================================================
DECLARE SUB glGenRenderbuffers (BYVAL n AS LONG, BYREF dwrenderbuffers AS DWORD)

' ========================================================================================
' void glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glRenderbufferStorage (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetRenderbufferParameteriv (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLboolean glIsFramebuffer (GLuint framebuffer);
' ========================================================================================
DECLARE FUNCTION glIsFramebuffer (BYVAL dwframebuffer AS DWORD) AS BYTE

' ========================================================================================
' void glBindFramebuffer (GLenum target, GLuint framebuffer);
' ========================================================================================
DECLARE SUB glBindFramebuffer (BYVAL dwTarget AS DWORD, BYVAL dwframebuffer AS DWORD)

' ========================================================================================
' void glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers);
' ========================================================================================
DECLARE SUB glDeleteFramebuffers (BYVAL n AS LONG, BYREF dwframebuffers AS DWORD)

' ========================================================================================
' void glGenFramebuffers (GLsizei n, GLuint *framebuffers);
' ========================================================================================
DECLARE SUB glGenFramebuffers (BYVAL n AS LONG, BYREF dwframebuffers AS DWORD)

' ========================================================================================
' GLenum glCheckFramebufferStatus (GLenum target);
' ========================================================================================
DECLARE FUNCTION glCheckFramebufferStatus (BYVAL dwTarget AS DWORD) AS DWORD

' ========================================================================================
' void glFramebufferTexture1D (GLenum target, GLenum attachment, GLenum textarget,
' GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTexture1D (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwtexttarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget,
' GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTexture2D (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwtexttarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glFramebufferTexture3D (GLenum target, GLenum attachment, GLenum textarget,
' GLuint texture, GLint level, GLint zoffset);
' ========================================================================================
DECLARE SUB glFramebufferTexture3D (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwtexttarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL zoffset AS LONG)

' ========================================================================================
' void glFramebufferRenderbuffer (GLenum target, GLenum attachment,
' GLenum renderbuffertarget, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glFramebufferRenderbuffer (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwrenderbuffertarget AS DWORD, BYVAL dwrenderbuffer AS DWORD)

' ========================================================================================
' void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment,
' GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFramebufferAttachmentParameteriv (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGenerateMipmap (GLenum target);
' ========================================================================================
DECLARE SUB glGenerateMipmap (BYVAL dwTarget AS DWORD)

' ========================================================================================
' void glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0,
' GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
' ========================================================================================
DECLARE SUB glBlitFramebuffer (BYVAL srcX0 AS LONG, BYVAL srcY0 AS LONG, BYVAL srcX1 AS LONG, BYVAL srcY1 AS LONG, BYVAL dstX0 AS LONG, BYVAL dstY0 AS LONG, BYVAL dstX1 AS LONG, BYVAL dstY1 AS LONG, BYVAL dwMask AS DWORD, BYVAL dwfilter AS DWORD)

' ========================================================================================
' void glRenderbufferStorageMultisample (GLenum target, GLsizei samples,
' GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glRenderbufferStorageMultisample (BYVAL dwTarget AS DWORD, BYVAL nSamples AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture,
' GLint level, GLint layer);
' ========================================================================================
DECLARE SUB glFramebufferTextureLayer (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL nLayer AS LONG)

'#ENDIF ' /* GL_GLEXT_PROTOTYPES */
'#ENDIF

'#IF NOT %DEF(%GL_ARB_framebuffer_sRGB)
'%GL_ARB_framebuffer_sRGB = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_geometry_shader4)
'%GL_ARB_geometry_shader4 = 1

' ========================================================================================
' void glProgramParameteriARB (GLuint program, GLenum pname, GLint value);
' ========================================================================================
DECLARE SUB glProgramParameteriARB (BYVAL dwProgram AS DWORD, BYVAL pname AS DWORD, BYVAL value AS LONG)

' ========================================================================================
' void glFramebufferTextureARB (GLenum target, GLenum attachment, GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTextureARB (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glFramebufferTextureLayerARB (GLenum target, GLenum attachment, GLuint texture,
' GLint level, GLint layer);
' ========================================================================================
DECLARE SUB glFramebufferTextureLayerARB (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL nLayer AS LONG)

' ========================================================================================
' void glFramebufferTextureFaceARB (GLenum target, GLenum attachment, GLuint texture,
' GLint level, GLenum face);
' ========================================================================================
DECLARE SUB glFramebufferTextureFaceARB (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL dwFace AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_half_float_vertex)
'%GL_ARB_half_float_vertex = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_instanced_arrays)
'%GL_ARB_instanced_arrays = 1

' ========================================================================================
' void glVertexAttribDivisor (GLuint index, GLuint divisor);
' Note: Some 3.3 drivers expose glVertexAttribDivisor instead of glVertexAttribDivisorARB.
' ========================================================================================
DECLARE SUB glVertexAttribDivisor (BYVAL dwIndex AS DWORD, BYVAL dwDivisor AS DWORD)

' ========================================================================================
' void glVertexAttribDivisorARB (GLuint index, GLuint divisor);
' ========================================================================================
DECLARE SUB glVertexAttribDivisorARB (BYVAL dwIndex AS DWORD, BYVAL dwDivisor AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_map_buffer_range)
'%GL_ARB_map_buffer_range = 1

' ========================================================================================
' void glMapBufferRange (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
' ========================================================================================
DECLARE SUB glMapBufferRange (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL plength AS LONG, BYVAL dwAccess AS DWORD)

' ========================================================================================
' void glFlushMappedBufferRange (GLenum target, GLintptr offset, GLsizeiptr length);
' ========================================================================================
DECLARE SUB glFlushMappedBufferRange (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL plength AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_buffer_object)
'%GL_ARB_texture_buffer_object = 1

' ========================================================================================
' void glTexBufferARB (GLenum target, GLenum internalformat, GLuint buffer);
' ========================================================================================
DECLARE SUB glTexBufferARB (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwBuffer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_compression_rgtc)
'%GL_ARB_texture_compression_rgtc = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_rg)
'%GL_ARB_texture_rg = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_array_object)
'%GL_ARB_vertex_array_object = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glBindVertexArray (GLuint array);
' ========================================================================================
DECLARE SUB glBindVertexArray (BYVAL dwArray AS DWORD)

' ========================================================================================
' void glDeleteVertexArrays (GLsizei n, const GLuint *arrays);
' ========================================================================================
DECLARE SUB glDeleteVertexArrays (BYVAL n AS LONG, BYREF dwArrays AS DWORD)

' ========================================================================================
' void glGenVertexArrays (GLsizei n, GLuint *arrays);
' ========================================================================================
DECLARE SUB glGenVertexArrays (BYVAL n AS LONG, BYREF dwArrays AS DWORD)

' ========================================================================================
' GLboolean glIsVertexArray (GLuint array);
' ========================================================================================
DECLARE FUNCTION glIsVertexArray (BYVAL dwArray AS DWORD) AS BYTE

'#ENDIF

'#IF NOT %DEF(%GL_ARB_uniform_buffer_object)
'%GL_ARB_uniform_buffer_object = 1

' ========================================================================================
' void APIENTRY glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices);
' ========================================================================================
DECLARE SUB glGetUniformIndices (BYVAL program AS DWORD, BYVAL uniformCount AS LONG, BYREF uniformNames AS ASCIIZ, BYREF uniformIndices AS DWORD)

' ========================================================================================
' void APIENTRY glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetActiveUniformsiv (BYVAL program AS DWORD, BYVAL uniformCount AS LONG, BYREF uniformIndices AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void APIENTRY glGetActiveUniformName (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
' ========================================================================================
DECLARE SUB glGetActiveUniformName (BYVAL program AS DWORD, BYVAL uniformIndex AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF uniformName AS ASCIIZ)

' ========================================================================================
' GLuint APIENTRY glGetUniformBlockIndex (GLuint program, const GLchar *uniformBlockName);
' ========================================================================================
DECLARE FUNCTION glGetUniformBlockIndex (BYVAL program AS DWORD, BYREF uniformBlockName AS ASCIIZ) AS DWORD

' ========================================================================================
' void APIENTRY glGetActiveUniformBlockiv (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetActiveUniformBlockiv (BYVAL program AS DWORD, BYVAL uniformBlockIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void APIENTRY glGetActiveUniformBlockName (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
' ========================================================================================
DECLARE SUB glGetActiveUniformBlockName (BYVAL program AS DWORD, BYVAL uniformBlockIndex AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF uniformBlockName AS ASCIIZ)

' ========================================================================================
' void APIENTRY glUniformBlockBinding (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
' ========================================================================================
DECLARE SUB glUniformBlockBinding (BYVAL program AS DWORD, BYVAL uniformBlockIndex AS DWORD, BYVAL uniformBlockBinding AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_compatibility)
'%GL_ARB_compatibility = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_copy_buffer)
'%GL_ARB_copy_buffer = 1

' ========================================================================================
' void APIENTRY glCopyBufferSubData (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glCopyBufferSubData (BYVAL readTarget AS DWORD, BYVAL writeTarget AS DWORD, BYVAL readOffset AS LONG, BYVAL writeOffset AS LONG, BYVAL psize AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_texture_lod)
'%GL_ARB_shader_texture_lod = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_depth_clamp)
'%GL_ARB_depth_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_draw_elements_base_vertex)
'%GL_ARB_draw_elements_base_vertex = 1

' ========================================================================================
' void APIENTRY glDrawElementsBaseVertex (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
' ========================================================================================
DECLARE SUB glDrawElementsBaseVertex (BYVAL dwMode AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL basevertex AS LONG)

' ========================================================================================
' void APIENTRY glDrawRangeElementsBaseVertex (GLenum mode, GLuint start, GLuint end,
' GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
' ========================================================================================
DECLARE SUB glDrawRangeElementsBaseVertex (BYVAL dwMode AS DWORD, BYVAL dwStart AS DWORD, BYVAL dwEnd AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL basevertex AS LONG)

' ========================================================================================
' void APIENTRY glDrawElementsInstancedBaseVertex (GLenum mode, GLsizei count, GLenum type,
' const GLvoid *indices, GLsizei instancecount, GLint basevertex);
' ========================================================================================
DECLARE SUB glDrawElementsInstancedBaseVertex (BYVAL dwMode AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL instancecount AS LONG, BYVAL basevertex AS LONG)

' ========================================================================================
' void APIENTRY glMultiDrawElementsBaseVertex (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, const GLint *basevertex);
' ========================================================================================
DECLARE SUB glMultiDrawElementsBaseVertex (BYVAL dwMode AS DWORD, BYREF nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL primcount AS LONG, BYREF basevertex AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_fragment_coord_conventions)
'%GL_ARB_fragment_coord_conventions = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_provoking_vertex)
'%GL_ARB_provoking_vertex = 1

' ========================================================================================
' void APIENTRY glProvokingVertex (GLenum mode);
' ========================================================================================
DECLARE SUB glProvokingVertex (BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_seamless_cube_map)
'%GL_ARB_seamless_cube_map = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_sync)
'%GL_ARB_sync = 1

' ========================================================================================
' GLsync APIENTRY glFenceSync (GLenum condition, GLbitfield flags);
' ========================================================================================
DECLARE FUNCTION glFenceSync (BYVAL dwCondition AS DWORD, BYVAL dwFlags AS DWORD) AS DWORD

' ========================================================================================
' GLboolean APIENTRY glIsSync (GLsync sync);
' ========================================================================================
DECLARE FUNCTION glIsSync (BYVAL dwSync AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glDeleteSync (GLsync sync);
' ========================================================================================
DECLARE SUB glDeleteSync (BYVAL dwSync AS DWORD)

' ========================================================================================
' GLenum APIENTRY glClientWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
' ========================================================================================
DECLARE FUNCTION glClientWaitSync (BYVAL dwSync AS DWORD, BYVAL dwFlags AS DWORD, BYVAL qTimeout AS QUAD) AS DWORD

' ========================================================================================
' void APIENTRY glWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
' ========================================================================================
DECLARE SUB glWaitSync (BYVAL dwSync AS DWORD, BYVAL dwFlags AS DWORD, BYVAL qTimeout AS QUAD)

' ========================================================================================
' void APIENTRY glGetInteger64v (GLenum pname, GLint64 *params);
' ========================================================================================
DECLARE SUB glGetInteger64v (BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' void APIENTRY glGetSynciv (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
' ========================================================================================
DECLARE SUB glGetSynciv (BYVAL dwSync AS DWORD, BYVAL pname AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF values AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_multisample)
'%GL_ARB_texture_multisample = 1

' ========================================================================================
' void APIENTRY glTexImage2DMultisample (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
' ========================================================================================
DECLARE SUB glTexImage2DMultisample (BYVAL dwTarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL fixedsamplelocations AS BYTE)

' ========================================================================================
' void APIENTRY glTexImage3DMultisample (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
' ========================================================================================
DECLARE SUB glTexImage3DMultisample (BYVAL dwTarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL fixedsamplelocations AS BYTE)

' ========================================================================================
' void APIENTRY glGetMultisamplefv (GLenum pname, GLuint index, GLfloat *val);
' ========================================================================================
DECLARE SUB glGetMultisamplefv (BYVAL pname AS DWORD, BYVAL dwIndex AS DWORD, BYREF fVal AS SINGLE)

' ========================================================================================
' void APIENTRY glSampleMaski (GLuint index, GLbitfield mask);
' ========================================================================================
DECLARE SUB glSampleMaski (BYVAL dwIndex AS DWORD, BYVAL dwMask AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_array_bgra)
'%GL_ARB_vertex_array_bgra = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_draw_buffers_blend)
'%GL_ARB_draw_buffers_blend = 1

' ========================================================================================
' GLAPI void APIENTRY glBlendEquationiARB (GLuint buf, GLenum mode);
' ========================================================================================
DECLARE SUB glBlendEquationiARB (BYVAL buf AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBlendEquationSeparateiARB (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
' ========================================================================================
DECLARE SUB glBlendEquationSeparateiARB (BYVAL buf AS DWORD, BYVAL modeRGB AS DWORD, BYVAL modeAlpha AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBlendFunciARB (GLuint buf, GLenum src, GLenum dst);
' ========================================================================================
DECLARE SUB glBlendFunciARB (BYVAL buf AS DWORD, BYVAL src AS DWORD, BYVAL dst AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBlendFuncSeparateiARB (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
' ========================================================================================
DECLARE SUB glBlendFuncSeparateiARB (BYVAL buf AS DWORD, BYVAL srcRGB AS DWORD, BYVAL dstRGB AS DWORD, BYVAL srcAlpha AS DWORD, BYVAL dstAlpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_sample_shading)
'%GL_ARB_sample_shading = 1

' ========================================================================================
' GLAPI void APIENTRY glMinSampleShadingARB (GLclampf value);
' ========================================================================================
DECLARE SUB glMinSampleShadingARB (BYVAL value AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_cube_map_array)
'%GL_ARB_texture_cube_map_array = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_gather)
'%GL_ARB_texture_gather = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_query_lod)
'%GL_ARB_texture_query_lod = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shading_language_include)
'%GL_ARB_shading_language_include = 1

' ========================================================================================
' void APIENTRY glNamedStringARB (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
' ========================================================================================
DECLARE SUB glNamedStringARB (BYVAL dwType AS DWORD, BYVAL namelen AS LONG, BYREF szName AS ASCIIZ, BYVAL stringlen AS LONG, BYREF szstring AS ASCIIZ)

' ========================================================================================
' void APIENTRY glDeleteNamedStringARB (GLint namelen, const GLchar *name);
' ========================================================================================
DECLARE SUB glDeleteNamedStringARB (BYVAL namelen AS LONG, BYREF szName AS ASCIIZ)

' ========================================================================================
' void APIENTRY glCompileShaderIncludeARB (GLuint shader, GLsizei count, const GLchar* *path, const GLint *length);
' ========================================================================================
DECLARE SUB glCompileShaderIncludeARB (BYVAL shader AS DWORD, BYVAL nCount AS LONG, BYREF szPath AS ASCIIZ, BYREF nLength AS LONG)

' ========================================================================================
' GLboolean APIENTRY glIsNamedStringARB (GLint namelen, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glIsNamedStringARB (BYVAL namelen AS LONG, BYREF szName AS ASCIIZ) AS BYTE

' ========================================================================================
' void APIENTRY glGetNamedStringARB (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
' ========================================================================================
DECLARE SUB glGetNamedStringARB (BYVAL namelen AS LONG, BYREF szName AS ASCIIZ, BYVAL bufSize AS LONG, BYREF stringlen AS LONG, BYREF szstring AS ASCIIZ)

' ========================================================================================
' void APIENTRY glGetNamedStringivARB (GLint namelen, const GLchar *name, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedStringivARB (BYVAL namelen AS LONG, BYREF szName AS ASCIIZ, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#ifndef GL_ARB_texture_compression_bptc
'#define GL_ARB_texture_compression_bptc 1
'#endif

'#IF NOT %DEF(%GL_ARB_blend_func_extended)
'%GL_ARB_blend_func_extended = 1

' ========================================================================================
' void APIENTRY glBindFragDataLocationIndexed (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
' ========================================================================================
DECLARE SUB glBindFragDataLocationIndexed (BYVAL program AS DWORD, BYVAL colorNumber AS DWORD, BYVAL dwIndex AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' GLint APIENTRY glGetFragDataIndex (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetFragDataIndex (BYVAL namelen AS DWORD, BYREF szName AS ASCIIZ) AS LONG

'#ENDIF

'#IF NOT %DEF(%GL_ARB_explicit_attrib_location)
'    %GL_ARB_explicit_attrib_location = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_occlusion_query2)
'%GL_ARB_occlusion_query2 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_sampler_objects)
'%GL_ARB_sampler_objects = 1

' ========================================================================================
' void APIENTRY glGenSamplers (GLsizei count, GLuint *samplers);
' ========================================================================================
DECLARE SUB glGenSamplers (BYVAL nCount AS LONG, BYREF samplers AS DWORD)

' ========================================================================================
' void APIENTRY glDeleteSamplers (GLsizei count, const GLuint *samplers);
' ========================================================================================
DECLARE SUB glDeleteSamplers (BYVAL nCount AS LONG, BYREF samplers AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsSampler (GLuint sampler);
' ========================================================================================
DECLARE FUNCTION glIsSampler (BYVAL sampler AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glBindSampler (GLuint unit, GLuint sampler);
' ========================================================================================
DECLARE SUB glBindSampler (BYVAL dwUnit AS DWORD, BYVAL sampler AS DWORD)

' ========================================================================================
' void APIENTRY glSamplerParameteri (GLuint sampler, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glSamplerParameteri (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void APIENTRY glSamplerParameteriv (GLuint sampler, GLenum pname, const GLint *param);
' ========================================================================================
DECLARE SUB glSamplerParameteriv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' void APIENTRY glSamplerParameterf (GLuint sampler, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glSamplerParameterf (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void APIENTRY glSamplerParameterfv (GLuint sampler, GLenum pname, const GLfloat *param);
' ========================================================================================
DECLARE SUB glSamplerParameterfv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF param AS SINGLE)

' ========================================================================================
' void APIENTRY glSamplerParameterIiv (GLuint sampler, GLenum pname, const GLint *param);
' ========================================================================================
DECLARE SUB glSamplerParameterIiv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' void APIENTRY glSamplerParameterIuiv (GLuint sampler, GLenum pname, const GLuint *param);
' ========================================================================================
DECLARE SUB glSamplerParameterIuiv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF param AS DWORD)

' ========================================================================================
' void APIENTRY glGetSamplerParameteriv (GLuint sampler, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetSamplerParameteriv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' void APIENTRY glGetSamplerParameterIiv (GLuint sampler, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetSamplerParameterIiv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void APIENTRY glGetSamplerParameterfv (GLuint sampler, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetSamplerParameterfv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void APIENTRY glGetSamplerParameterIuiv (GLuint sampler, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetSamplerParameterIuiv (BYVAL sampler AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_bit_encoding)
'%GL_ARB_shader_bit_encoding = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_rgb10_a2ui)
'    %GL_ARB_texture_rgb10_a2ui = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_swizzle)
'%GL_ARB_texture_swizzle = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_timer_query)
'%GL_ARB_timer_query = 1

' ========================================================================================
' void APIENTRY glQueryCounter (GLuint id, GLenum target);
' ========================================================================================
DECLARE SUB glQueryCounter (BYVAL dwId AS DWORD, BYVAL dwTarget AS DWORD)

' ========================================================================================
' void APIENTRY glGetQueryObjecti64v (GLuint id, GLenum pname, GLint64 *params);
' ========================================================================================
DECLARE SUB glGetQueryObjecti64v (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' void APIENTRY glGetQueryObjectui64v (GLuint id, GLenum pname, GLuint64 *params);
' ========================================================================================
DECLARE SUB glGetQueryObjectui64v (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_type_2_10_10_10_rev)
'%GL_ARB_vertex_type_2_10_10_10_rev = 1

' ========================================================================================
' void APIENTRY glVertexP2ui (GLenum type, GLuint value);
' ========================================================================================
DECLARE SUB glVertexP2ui (BYVAL dwType AS DWORD, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexP2uiv (GLenum type, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexP2uiv (BYVAL dwType AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexP3ui (GLenum type, GLuint value);
' ========================================================================================
DECLARE SUB glVertexP3ui (BYVAL dwType AS DWORD, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexP3uiv (GLenum type, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexP3uiv (BYVAL dwType AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexP4ui (GLenum type, GLuint value);
' ========================================================================================
DECLARE SUB glVertexP4ui (BYVAL dwType AS DWORD, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexP4uiv (GLenum type, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexP4uiv (BYVAL dwType AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP1ui (GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glTexCoordP1ui (BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP1uiv (GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glTexCoordP1uiv (BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP2ui (GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glTexCoordP2ui (BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP2uiv (GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glTexCoordP2uiv (BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP3ui (GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glTexCoordP3ui (BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP3uiv (GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glTexCoordP3uiv (BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP4ui (GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glTexCoordP4ui (BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glTexCoordP4uiv (GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glTexCoordP4uiv (BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP1ui (GLenum texture, GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP1ui (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP1uiv (GLenum texture, GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP1uiv (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP2ui (GLenum texture, GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP2ui (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP2uiv (GLenum texture, GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP2uiv (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP3ui (GLenum texture, GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP3ui (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP3uiv (GLenum texture, GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP3uiv (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP4ui (GLenum texture, GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP4ui (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glMultiTexCoordP4uiv (GLenum texture, GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoordP4uiv (BYVAL dwTexture AS DWORD, BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glNormalP3ui (GLenum type, GLuint coords);
' ========================================================================================
DECLARE SUB glNormalP3ui (BYVAL dwType AS DWORD, BYVAL dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glNormalP3uiv (GLenum type, const GLuint *coords);
' ========================================================================================
DECLARE SUB glNormalP3uiv (BYVAL dwType AS DWORD, BYREF dwCoords AS DWORD)

' ========================================================================================
' void APIENTRY glColorP3ui (GLenum type, GLuint color);
' ========================================================================================
DECLARE SUB glColorP3ui (BYVAL dwType AS DWORD, BYVAL dwColor AS DWORD)

' ========================================================================================
' void APIENTRY glColorP3uiv (GLenum type, const GLuint *color);
' ========================================================================================
DECLARE SUB glColorP3uiv (BYVAL dwType AS DWORD, BYREF dwColor AS DWORD)

' ========================================================================================
' void APIENTRY glColorP4ui (GLenum type, GLuint color);
' ========================================================================================
DECLARE SUB glColorP4ui (BYVAL dwType AS DWORD, BYVAL dwColor AS DWORD)

' ========================================================================================
' void APIENTRY glColorP4uiv (GLenum type, const GLuint *color);
' ========================================================================================
DECLARE SUB glColorP4uiv (BYVAL dwType AS DWORD, BYREF dwColor AS DWORD)

' ========================================================================================
' void APIENTRY glSecondaryColorP3ui (GLenum type, GLuint color);
' ========================================================================================
DECLARE SUB glSecondaryColorP3ui (BYVAL dwType AS DWORD, BYVAL dwColor AS DWORD)

' ========================================================================================
' void APIENTRY glSecondaryColorP3uiv (GLenum type, const GLuint *color);
' ========================================================================================
DECLARE SUB glSecondaryColorP3uiv (BYVAL dwType AS DWORD, BYREF dwColor AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP1ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
' ========================================================================================
DECLARE SUB glVertexAttribP1ui (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP1uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexAttribP1uiv (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYREF value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP2ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
' ========================================================================================
DECLARE SUB glVertexAttribP2ui (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP2uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexAttribP2uiv (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYREF value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP3ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
' ========================================================================================
DECLARE SUB glVertexAttribP3ui (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP3uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexAttribP3uiv (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYREF value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP4ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
' ========================================================================================
DECLARE SUB glVertexAttribP4ui (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYVAL value AS DWORD)

' ========================================================================================
' void APIENTRY glVertexAttribP4uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
' ========================================================================================
DECLARE SUB glVertexAttribP4uiv (BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYREF value AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_draw_indirect)
'%GL_ARB_draw_indirect = 1

' ========================================================================================
' void APIENTRY glDrawArraysIndirect (GLenum mode, const GLvoid *indirect);
' ========================================================================================
DECLARE SUB glDrawArraysIndirect (BYVAL dwMode AS DWORD, BYVAL indirect AS DWORD)

' ========================================================================================
' void APIENTRY glDrawElementsIndirect (GLenum mode, GLenum type, const GLvoid *indirect);
' ========================================================================================
DECLARE SUB glDrawElementsIndirect (BYVAL dwMode AS DWORD, BYVAL dwType AS DWORD, BYVAL indirect AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_gpu_shader5)
'    %GL_ARB_gpu_shader5 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_gpu_shader_fp64)
'%GL_ARB_gpu_shader_fp64 = 1

' ========================================================================================
' void APIENTRY glUniform1d (GLint location, GLdouble x);
' ========================================================================================
DECLARE SUB glUniform1d (BYVAL location AS LONG, BYVAL x AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform2d (GLint location, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glUniform2d (BYVAL location AS LONG, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform3d (GLint location, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glUniform3d (BYVAL location AS LONG, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform4d (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glUniform4d (BYVAL location AS LONG, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform1dv (GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniform1dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform2dv (GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniform2dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform3dv (GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniform3dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniform4dv (GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniform4dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix2x3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2x3dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix2x4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix2x4dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix3x2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3x2dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix3x4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix3x4dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix4x2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4x2dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glUniformMatrix4x3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glUniformMatrix4x3dv (BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glGetUniformdv (GLuint program, GLint location, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetUniformdv (BYVAL program AS DWORD, BYVAL location AS LONG, BYREF params AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_subroutine)
'%GL_ARB_shader_subroutine = 1

' ========================================================================================
' GLint APIENTRY glGetSubroutineUniformLocation (GLuint program, GLenum shadertype, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetSubroutineUniformLocation (BYVAL program AS DWORD, BYVAL shadertype AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' GLuint APIENTRY glGetSubroutineIndex (GLuint program, GLenum shadertype, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetSubroutineIndex (BYVAL program AS DWORD, BYVAL shadertype AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' void APIENTRY glGetActiveSubroutineUniformiv (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
' ========================================================================================
DECLARE SUB glGetActiveSubroutineUniformiv (BYVAL program AS DWORD, BYVAL shadertype AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF values AS LONG)

' ========================================================================================
' void APIENTRY glGetActiveSubroutineUniformName (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
' ========================================================================================
DECLARE SUB glGetActiveSubroutineUniformName (BYVAL program AS DWORD, BYVAL shadertype AS DWORD, BYVAL dwIndex AS DWORD, BYVAL bufsize AS LONG, BYREF nLength AS LONG, BYREF szName AS ASCIIZ)

' ========================================================================================
' void APIENTRY glGetActiveSubroutineName (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
' ========================================================================================
DECLARE SUB glGetActiveSubroutineName (BYVAL program AS DWORD, BYVAL shadertype AS DWORD, BYVAL dwIndex AS DWORD, BYVAL bufsize AS LONG, BYREF nLength AS LONG, BYREF szName AS ASCIIZ)

' ========================================================================================
' void APIENTRY glUniformSubroutinesuiv (GLenum shadertype, GLsizei count, const GLuint *indices);
' ========================================================================================
DECLARE SUB glUniformSubroutinesuiv (BYVAL shadertype AS DWORD, BYVAL nCount AS LONG, BYREF dwIndices AS DWORD)

' ========================================================================================
' void APIENTRY glGetUniformSubroutineuiv (GLenum shadertype, GLint location, GLuint *params);
' ========================================================================================
DECLARE SUB glGetUniformSubroutineuiv (BYVAL shadertype AS DWORD, BYVAL location AS LONG, BYREF params AS DWORD)

' ========================================================================================
' void APIENTRY glGetProgramStageiv (GLuint program, GLenum shadertype, GLenum pname, GLint *values);
' ========================================================================================
DECLARE SUB glGetProgramStageiv (BYVAL program AS DWORD, BYVAL shadertype AS DWORD, BYVAL pname AS DWORD, BYREF values AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_tessellation_shader)
'%GL_ARB_tessellation_shader = 1

' ========================================================================================
' void APIENTRY glPatchParameteri (GLenum pname, GLint value);
' ========================================================================================
DECLARE SUB glPatchParameteri (BYVAL pname AS DWORD, BYVAL value AS LONG)

' ========================================================================================
' void APIENTRY glPatchParameterfv (GLenum pname, const GLfloat *values);
' ========================================================================================
DECLARE SUB glPatchParameterfv (BYVAL pname AS DWORD, BYREF values AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_buffer_object_rgb32)
'%GL_ARB_texture_buffer_object_rgb32 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_transform_feedback2)
'%GL_ARB_transform_feedback2 = 1

' ========================================================================================
' void APIENTRY glBindTransformFeedback (GLenum target, GLuint id);
' ========================================================================================
DECLARE SUB glBindTransformFeedback (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD)

' ========================================================================================
' void APIENTRY glDeleteTransformFeedbacks (GLsizei n, const GLuint *ids);
' ========================================================================================
DECLARE SUB glDeleteTransformFeedbacks (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' void APIENTRY glGenTransformFeedbacks (GLsizei n, GLuint *ids);
' ========================================================================================
DECLARE SUB glGenTransformFeedbacks (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsTransformFeedback (GLuint id);
' ========================================================================================
DECLARE FUNCTION glIsTransformFeedback (BYVAL dwId AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glPauseTransformFeedback (void);
' ========================================================================================
DECLARE SUB glPauseTransformFeedback

' ========================================================================================
' void APIENTRY glResumeTransformFeedback (void);
' ========================================================================================
DECLARE SUB glResumeTransformFeedback

' ========================================================================================
' void APIENTRY glDrawTransformFeedback (GLenum mode, GLuint id);
' ========================================================================================
DECLARE SUB glDrawTransformFeedback (BYVAL dwMode AS DWORD, BYVAL dwId AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_transform_feedback3)
'%GL_ARB_transform_feedback3 = 1

' ========================================================================================
' void APIENTRY glDrawTransformFeedbackStream (GLenum mode, GLuint id, GLuint stream);
' ========================================================================================
DECLARE SUB glDrawTransformFeedbackStream (BYVAL dwMode AS DWORD, BYVAL dwId AS DWORD, BYVAL dwStream AS DWORD)

' ========================================================================================
' void APIENTRY glBeginQueryIndexed (GLenum target, GLuint index, GLuint id);
' ========================================================================================
DECLARE SUB glBeginQueryIndexed (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL dwId AS DWORD)

' ========================================================================================
' void APIENTRY glEndQueryIndexed (GLenum target, GLuint index);
' ========================================================================================
DECLARE SUB glEndQueryIndexed (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' void APIENTRY glGetQueryIndexediv (GLenum target, GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetQueryIndexediv (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_ES2_compatibility)
'%GL_ARB_ES2_compatibility = 1
' ========================================================================================
' GLAPI void APIENTRY glReleaseShaderCompiler (void);
' ========================================================================================
DECLARE SUB glReleaseShaderCompiler

' ========================================================================================
' GLAPI void APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
' ========================================================================================
DECLARE SUB glShaderBinary (BYVAL dwCount AS DWORD, BYREF shaders AS DWORD, BYVAL binaryformat AS DWORD, BYVAL pbinary AS DWORD, BYVAL length AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
' ========================================================================================
DECLARE SUB glGetShaderPrecisionFormat (BYVAL shadertype AS DWORD, BYVAL precisiontype AS DWORD, BYREF lrange AS LONG, BYREF precision AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glDepthRangef (GLclampf n, GLclampf f);
' ========================================================================================
DECLARE SUB glDepthRangef(BYVAL n AS SINGLE, BYVAL f AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glClearDepthf (GLclampf d);
' ========================================================================================
DECLARE SUB glClearDepthf(BYVAL d AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_get_program_binary)
'%GL_ARB_get_program_binary = 1
' ========================================================================================
' GLAPI void APIENTRY glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
' ========================================================================================
DECLARE SUB glGetProgramBinary(BYVAL program AS DWORD, BYVAL bufSize AS DWORD, BYREF length AS DWORD, BYREF binaryFormat AS DWORD, BYVAL pbinary AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramBinary (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
' ========================================================================================
DECLARE SUB glProgramBinary(BYVAL program AS DWORD, BYVAL binaryFormat AS DWORD, BYVAL pbinary AS DWORD, BYVAL length AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramParameteri (GLuint program, GLenum pname, GLint value);
' ========================================================================================
DECLARE SUB glProgramParameteri(BYVAL program AS DWORD, BYVAL pname AS DWORD, BYVAL value AS LONG)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_separate_shader_objects)
'%GL_ARB_separate_shader_objects = 1
' ========================================================================================
' GLAPI void APIENTRY glUseProgramStages (GLuint pipeline, GLbitfield stages, GLuint program);
' ========================================================================================
DECLARE SUB glUseProgramStages(BYVAL pipeline AS DWORD, BYVAL stages AS DWORD, BYVAL program AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glActiveShaderProgram (GLuint pipeline, GLuint program);
' ========================================================================================
DECLARE SUB glActiveShaderProgram(BYVAL pipeline AS DWORD, BYVAL program AS DWORD)

' ========================================================================================
' GLAPI GLuint APIENTRY glCreateShaderProgramv (GLenum type, GLsizei count, const GLchar* const *strings);
' ========================================================================================
DECLARE FUNCTION glCreateShaderProgramv(BYVAL dwType AS DWORD, BYVAL dwCount AS DWORD, BYREF strings AS STRING) AS DWORD

' ========================================================================================
' GLAPI void APIENTRY glBindProgramPipeline (GLuint pipeline);
' ========================================================================================
DECLARE SUB glBindProgramPipeline(BYVAL pipeline AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glDeleteProgramPipelines (GLsizei n, const GLuint *pipelines);
' ========================================================================================
DECLARE SUB glDeleteProgramPipelines(BYVAL n AS DWORD, BYREF pipelines AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGenProgramPipelines (GLsizei n, GLuint *pipelines);
' ========================================================================================
DECLARE SUB glGenProgramPipelines(BYVAL n AS DWORD, BYREF pipelines AS DWORD)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsProgramPipeline (GLuint pipeline);
' ========================================================================================
DECLARE FUNCTION glIsProgramPipeline(BYVAL pipeline AS DWORD) AS LONG

' ========================================================================================
' GLAPI void APIENTRY glGetProgramPipelineiv (GLuint pipeline, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramPipelineiv(BYVAL pipeline AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1i (GLuint program, GLint location, GLint v0);
' ========================================================================================
DECLARE SUB glProgramUniform1i(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1iv (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform1iv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1f (GLuint program, GLint location, GLfloat v0);
' ========================================================================================
DECLARE SUB glProgramUniform1f(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform1fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1d (GLuint program, GLint location, GLdouble v0);
' ========================================================================================
DECLARE SUB glProgramUniform1d(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform1dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1ui (GLuint program, GLint location, GLuint v0);
' ========================================================================================
DECLARE SUB glProgramUniform1ui(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform1uiv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2i (GLuint program, GLint location, GLint v0, GLint v1);
' ========================================================================================
DECLARE SUB glProgramUniform2i(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2iv (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform2iv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2f (GLuint program, GLint location, GLfloat v0, GLfloat v1);
' ========================================================================================
DECLARE SUB glProgramUniform2f(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform2fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2d (GLuint program, GLint location, GLdouble v0, GLdouble v1);
' ========================================================================================
DECLARE SUB glProgramUniform2d(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DOUBLE, BYVAL v1 AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform2dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2ui (GLuint program, GLint location, GLuint v0, GLuint v1);
' ========================================================================================
DECLARE SUB glProgramUniform2ui(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform2uiv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3i (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
' ========================================================================================
DECLARE SUB glProgramUniform3i(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3iv (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform3iv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3f (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
' ========================================================================================
DECLARE SUB glProgramUniform3f(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform3fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3d (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
' ========================================================================================
DECLARE SUB glProgramUniform3d(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DOUBLE, BYVAL v1 AS DOUBLE, BYVAL v2 AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform3dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3ui (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
' ========================================================================================
DECLARE SUB glProgramUniform3ui(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform3uiv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4i (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
' ========================================================================================
DECLARE SUB glProgramUniform4i(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG, BYVAL v3 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4iv (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform4iv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4f (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
' ========================================================================================
DECLARE SUB glProgramUniform4f(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, BYVAL v3 AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform4fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4d (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
' ========================================================================================
DECLARE SUB glProgramUniform4d(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DOUBLE, BYVAL v1 AS DOUBLE, BYVAL v2 AS DOUBLE, BYVAL v3 AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform4dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4ui (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
' ========================================================================================
DECLARE SUB glProgramUniform4ui(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD, BYVAL v3 AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform4uiv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYREF value AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix2x3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x3fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix3x2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x2fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix2x4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x4fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix4x2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x2fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix3x4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x4fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix4x3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x3fv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix2x3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x3dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix3x2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x2dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix2x4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x4dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix4x2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x2dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix3x4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x4dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformMatrix4x3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x3dv(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL dwCount AS DWORD, BYVAL transpose AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glValidateProgramPipeline (GLuint pipeline);
' ========================================================================================
DECLARE SUB glValidateProgramPipeline(BYVAL pipeline AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetProgramPipelineInfoLog (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
' ========================================================================================
DECLARE SUB glGetProgramPipelineInfoLog(BYVAL pipeline AS DWORD, BYVAL bufSize AS DWORD, BYREF length AS DWORD, BYREF infoLog AS ASCIIZ)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_vertex_attrib_64bit)
'%GL_ARB_vertex_attrib_64bit = 1
' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1d (GLuint index, GLdouble x);
' ========================================================================================
DECLARE SUB glVertexAttribL1d(BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2d (GLuint index, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glVertexAttribL2d(BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glVertexAttribL3d(BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glVertexAttribL4d(BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL1dv(BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL2dv(BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL3dv(BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4dv (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL4dv(BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribLPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribLPointer(BYVAL dwIndex AS DWORD, BYREF nsize AS LONG, BYVAL dwStride AS DWORD, BYVAL p AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetVertexAttribLdv (GLuint index, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribLdv(BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_viewport_array)
'%GL_ARB_viewport_array = 1
' ========================================================================================
' GLAPI void APIENTRY glViewportArrayv (GLuint first, GLsizei count, const GLfloat *v);
' ========================================================================================
DECLARE SUB glViewportArrayv(BYVAL dwFirst AS DWORD, BYVAL dwCount AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glViewportIndexedf (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
' ========================================================================================
DECLARE SUB glViewportIndexedf(BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL w AS SINGLE, BYVAL h AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glViewportIndexedfv (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glViewportIndexedfv(BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glScissorArrayv (GLuint first, GLsizei count, const GLint *v);
' ========================================================================================
DECLARE SUB glScissorArrayv(BYVAL dwFirst AS DWORD, BYVAL dwCount AS DWORD, BYREF v AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glScissorIndexed (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glScissorIndexed(BYVAL dwIndex AS DWORD, BYVAL nLeft AS LONG, BYVAL nBottom AS LONG, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glScissorIndexedv (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glScissorIndexedv(BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glDepthRangeArrayv (GLuint first, GLsizei count, const GLclampd *v);
' ========================================================================================
DECLARE SUB glDepthRangeArrayv(BYVAL dwFirst AS DWORD, BYVAL dwCount AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glDepthRangeIndexed (GLuint index, GLclampd n, GLclampd f);
' ========================================================================================
DECLARE SUB glDepthRangeIndexed(BYVAL dwIndex AS DWORD, BYVAL n AS DOUBLE, BYVAL f AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glGetFloati_v (GLenum target, GLuint index, GLfloat *data);
' ========================================================================================
DECLARE SUB glGetFloati_v(BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF fltdata AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetDoublei_v (GLenum target, GLuint index, GLdouble *data);
' ========================================================================================
DECLARE SUB glGetDoublei_v(BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF dbldata AS DOUBLE)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_cl_event)
'%GL_ARB_cl_event = 1
' ========================================================================================
' GLAPI GLsync APIENTRY glCreateSyncFromCLeventARB (struct _cl_context * context, struct _cl_event * event, GLbitfield flags);
' ========================================================================================
DECLARE FUNCTION glCreateSyncFromCLeventARB(BYVAL pContext AS DWORD, BYVAL pEvent AS DWORD, BYVAL flags AS DWORD) AS DWORD
'#ENDIF

'#IF NOT %DEF(%GL_ARB_debug_output)
'%GL_ARB_debug_output = 1
' ========================================================================================
' GLAPI void APIENTRY glDebugMessageControlARB (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
' ========================================================================================
DECLARE SUB glDebugMessageControlARB(BYVAL dwSource AS DWORD, BYVAL dwType AS DWORD, BYVAL severity AS DWORD, BYVAL dwCount AS DWORD, BYREF ids AS DWORD, BYVAL enabled AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageInsertARB (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
' ========================================================================================
DECLARE SUB glDebugMessageInsertARB(BYVAL dwSource AS DWORD, BYVAL dwType AS DWORD, BYVAL dwId AS DWORD, BYVAL severity AS DWORD, BYVAL length AS DWORD, BYREF nuf AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageCallbackARB (GLDEBUGPROCARB callback, const GLvoid *userParam);
' ========================================================================================
DECLARE SUB glDebugMessageCallbackARB(BYVAL dwCallback AS DWORD, BYVAL userParam AS DWORD)

' ========================================================================================
' GLAPI GLuint APIENTRY glGetDebugMessageLogARB (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
' ========================================================================================
DECLARE FUNCTION glGetDebugMessageLogARB(BYVAL dwCount AS DWORD, BYVAL bufsize AS DWORD, BYREF sources AS DWORD, BYREF types AS DWORD, BYREF ids AS DWORD, BYREF severities AS DWORD, BYREF lengths AS DWORD, BYREF messageLog AS ASCIIZ) AS DWORD
'#ENDIF

'#IF NOT %DEF(%GL_ARB_robustness)
'%GL_ARB_robustness = 1
' ========================================================================================
' GLAPI GLenum APIENTRY glGetGraphicsResetStatusARB (void);
' ========================================================================================
DECLARE FUNCTION glGetGraphicsResetStatusARB() AS DWORD

' ========================================================================================
' GLAPI void APIENTRY glGetnMapdvARB (GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
' ========================================================================================
DECLARE SUB glGetnMapdvARB(BYVAL dwTarget AS DWORD, BYVAL dwQuery AS DWORD, BYVAL bufSize AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glGetnMapfvARB (GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
' ========================================================================================
DECLARE SUB glGetnMapfvARB(BYVAL dwTarget AS DWORD, BYVAL dwQuery AS DWORD, BYVAL bufSize AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetnMapivARB (GLenum target, GLenum query, GLsizei bufSize, GLint *v);
' ========================================================================================
DECLARE SUB glGetnMapivARB(BYVAL dwTarget AS DWORD, BYVAL dwQuery AS DWORD, BYVAL bufSize AS DWORD, BYREF v AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetnPixelMapfvARB (GLenum map, GLsizei bufSize, GLfloat *values);
' ========================================================================================
DECLARE SUB glGetnPixelMapfvARB(BYVAL dwMap AS DWORD, BYVAL bufSize AS DWORD, BYREF values AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetnPixelMapuivARB (GLenum map, GLsizei bufSize, GLuint *values);
' ========================================================================================
DECLARE SUB glGetnPixelMapuivARB(BYVAL dwMap AS DWORD, BYVAL bufSize AS DWORD, BYREF values AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnPixelMapusvARB (GLenum map, GLsizei bufSize, GLushort *values);
' ========================================================================================
DECLARE SUB glGetnPixelMapusvARB(BYVAL dwMap AS DWORD, BYVAL bufSize AS DWORD, BYREF values AS WORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnPolygonStippleARB (GLsizei bufSize, GLubyte *pattern);
' ========================================================================================
DECLARE SUB glGetnPolygonStippleARB(BYVAL bufSize AS DWORD, BYREF pattern AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glGetnColorTableARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table);
' ========================================================================================
DECLARE SUB glGetnColorTableARB(BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL bufSize AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnConvolutionFilterARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image);
' ========================================================================================
DECLARE SUB glGetnConvolutionFilterARB(BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL bufSize AS DWORD, BYVAL pImage AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnSeparableFilterARB (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span);
' ========================================================================================
DECLARE SUB glGetnSeparableFilterARB(BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL rowBufSize AS DWORD, BYVAL pRow AS DWORD, BYVAL columnBufSize AS DWORD, BYVAL pColumn AS DWORD, BYVAL pSpan AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnHistogramARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
' ========================================================================================
DECLARE SUB glGetnHistogramARB(BYVAL dwTarget AS DWORD, BYVAL bReset AS LONG, BYVAL dwType AS DWORD, BYVAL bufSize AS DWORD, BYVAL pvalues AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnMinmaxARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
' ========================================================================================
DECLARE SUB glGetnMinmaxARB(BYVAL dwTarget AS DWORD, BYVAL bReset AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL bufSize AS DWORD, BYVAL pvalues AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnTexImageARB (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
' ========================================================================================
DECLARE SUB glGetnTexImageARB(BYVAL dwTarget AS DWORD, BYVAL nlevel AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL bufSize AS DWORD, BYVAL pImg AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glReadnPixelsARB (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
' ========================================================================================
DECLARE SUB glReadnPixelsARB(BYVAL x AS LONG, BYVAL y AS LONG, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL bufSize AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnCompressedTexImageARB (GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
' ========================================================================================
DECLARE SUB glGetnCompressedTexImageARB(BYVAL dwTarget AS DWORD, BYVAL lod AS LONG, BYVAL bufSize AS DWORD, BYVAL pImg AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnUniformfvARB (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetnUniformfvARB(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL bufSize AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetnUniformivARB (GLuint program, GLint location, GLsizei bufSize, GLint *params);
' ========================================================================================
DECLARE SUB glGetnUniformivARB(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL bufSize AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetnUniformuivARB (GLuint program, GLint location, GLsizei bufSize, GLuint *params);
' ========================================================================================
DECLARE SUB glGetnUniformuivARB(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL bufSize AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetnUniformdvARB (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetnUniformdvARB(BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL bufSize AS DWORD, BYREF params AS DOUBLE)
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_stencil_export)
'%GL_ARB_shader_stencil_export = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_base_instance)
'%GL_ARB_base_instance = 1

' ========================================================================================
' GLAPI void APIENTRY glDrawArraysInstancedBaseInstance (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
' ========================================================================================
DECLARE SUB glDrawArraysInstancedBaseInstance(BYVAL dwMode AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS DWORD, BYVAL instancecount AS DWORD, BYVAL baseinstance AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glDrawElementsInstancedBaseInstance (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
' ========================================================================================
DECLARE SUB glDrawElementsInstancedBaseInstance(BYVAL dwMode AS DWORD, BYVAL nCount AS DWORD, BYVAL dwType AS DWORD, BYVAL pindices AS DWORD, BYVAL instancecount AS DWORD, BYVAL baseinstance AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glDrawElementsInstancedBaseVertexBaseInstance (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
' ========================================================================================
DECLARE SUB glDrawElementsInstancedBaseVertexBaseInstance(BYVAL dwMode AS DWORD, BYVAL nCount AS DWORD, BYVAL dwType AS DWORD, BYVAL pindices AS DWORD, BYVAL instancecount AS DWORD, BYVAL basevertex AS LONG, BYVAL baseinstance AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shading_language_420pack)
'%GL_ARB_shading_language_420pack = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_transform_feedback_instanced)
'%GL_ARB_transform_feedback_instanced = 1

' ========================================================================================
' GLAPI void APIENTRY glDrawTransformFeedbackInstanced (GLenum mode, GLuint id, GLsizei primcount);
' ========================================================================================
DECLARE SUB glDrawTransformFeedbackInstanced(BYVAL dwMode AS DWORD, BYVAL dwId AS DWORD, BYVAL primcount AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glDrawTransformFeedbackStreamInstanced (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
' ========================================================================================
DECLARE SUB glDrawTransformFeedbackStreamInstanced(BYVAL dwMode AS DWORD, BYVAL dwId AS DWORD, BYVAL dwStream AS DWORD, BYVAL primcount AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_compressed_texture_pixel_storage)
'%GL_ARB_compressed_texture_pixel_storage = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_conservative_depth)
'%GL_ARB_conservative_depth = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_internalformat_query)
'%GL_ARB_internalformat_query = 1

' ========================================================================================
' GLAPI void APIENTRY glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
' ========================================================================================
DECLARE SUB glGetInternalformativ(BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL pname AS DWORD, BYVAL bufSize AS DWORD, BYREF pParams AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_map_buffer_alignment)
'%GL_ARB_map_buffer_alignment = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_atomic_counters)
'%GL_ARB_shader_atomic_counters = 1

' ========================================================================================
' GLAPI void APIENTRY glGetActiveAtomicCounterBufferiv (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetActiveAtomicCounterBufferiv(BYVAL dwProgram AS DWORD, BYVAL bufferIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_image_load_store)
'%GL_ARB_shader_image_load_store = 1

' ========================================================================================
' GLAPI void APIENTRY glBindImageTexture (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
' ========================================================================================
DECLARE SUB glBindImageTexture(BYVAL dwUnit AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL bLayered AS BYTE, BYVAL nLayer AS LONG, BYVAL dwAccess AS DWORD, BYVAL dwFormat AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glMemoryBarrier (GLbitfield barriers);
' ========================================================================================
DECLARE SUB glMemoryBarrier(BYVAL barriers AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ARB_shading_language_packing)
'%GL_ARB_shading_language_packing = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_storage)
'%GL_ARB_texture_storage = 1

' ========================================================================================
' GLAPI void APIENTRY glTexStorage1D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
' ========================================================================================
DECLARE SUB glTexStorage1D(BYVAL dwTarget AS DWORD, BYVAL dwLevels AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwWidth AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glTexStorage2D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glTexStorage2D(BYVAL dwTarget AS DWORD, BYVAL dwLevels AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glTexStorage3D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
' ========================================================================================
DECLARE SUB glTexStorage3D(BYVAL dwTarget AS DWORD, BYVAL dwLevels AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, BYVAL dwDepth AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glTextureStorage1DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
' ========================================================================================
DECLARE SUB glTextureStorage1DEXT(BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwLevels AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwWidth AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glTextureStorage2DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glTextureStorage2DEXT(BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwLevels AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glTextureStorage3DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
' ========================================================================================
DECLARE SUB glTextureStorage3DEXT(BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwLevels AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, BYVAL dwDepth AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_KHR_texture_compression_astc_ldr)
'%GL_KHR_texture_compression_astc_ldr = 1
'#ENDIF

#IF NOT %DEF(%GL_KHR_debug)
%GL_KHR_debug = 1

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageControl (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
' ========================================================================================
DECLARE SUB glDebugMessageControl(BYVAL dwsource AS DWORD, BYVAL dwtype AS DWORD, BYVAL dwseverity AS DWORD, BYVAL ncount AS LONG, BYREF ids AS DWORD, BYVAL enabled AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageInsert (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
' ========================================================================================
DECLARE SUB glDebugMessageInsert(BYVAL dwsource AS DWORD, BYVAL dwtype AS DWORD, BYVAL dwid AS DWORD, BYVAL dwseverity AS DWORD, BYVAL nlength AS LONG, BYREF buf AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageCallback (GLDEBUGPROC callback, const void *userParam);
' ========================================================================================
DECLARE SUB glDebugMessageCallback(BYVAL pcallback AS DWORD, BYVAL userParam AS DWORD)

' ========================================================================================
' GLAPI GLuint APIENTRY glGetDebugMessageLog (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
' ========================================================================================
DECLARE FUNCTION glGetDebugMessageLog(BYVAL dwcount AS DWORD, BYVAL bufsize AS LONG, BYREF sources AS DWORD, BYREF types AS DWORD, BYREF ids AS DWORD, BYREF severities AS DWORD, BYREF lengths AS LONG, BYREF messageLog AS BYTE) AS DWORD

' ========================================================================================
' GLAPI void APIENTRY glPushDebugGroup (GLenum source, GLuint id, GLsizei length, const GLchar *message);
' ========================================================================================
DECLARE SUB glPushDebugGroup(BYVAL dwsource AS DWORD, BYVAL dwid AS DWORD, BYVAL nlength AS LONG, BYREF szmessage AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glPopDebugGroup (void);
' ========================================================================================
DECLARE SUB glPopDebugGroup()

' ========================================================================================
' GLAPI void APIENTRY glObjectLabel (GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
' ========================================================================================
DECLARE SUB glObjectLabel(BYVAL dwidentifier AS DWORD, BYVAL dwname AS DWORD, BYVAL nlength AS LONG, BYREF szlabel AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glGetObjectLabel (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
' ========================================================================================
DECLARE SUB glGetObjectLabel(BYVAL dwidentifier AS DWORD, BYVAL dwname AS DWORD, BYVAL bufSize AS LONG, BYREF nlength AS LONG, BYREF szlabel AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glObjectPtrLabel (const void *ptr, GLsizei length, const GLchar *label);
' ========================================================================================
DECLARE SUB glObjectPtrLabel(BYVAL ptr_ AS DWORD, BYVAL nlength AS LONG, BYREF szlabel AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glGetObjectPtrLabel (const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
' ========================================================================================
DECLARE SUB glGetObjectPtrLabel(BYVAL ptr_ AS DWORD, BYVAL bufSize AS LONG, BYREF nlength AS LONG, BYREF szlabel AS ASCIIZ)

#ENDIF

'#IF NOT %DEF(%GL_ARB_arrays_of_arrays)
'%GL_ARB_arrays_of_arrays = 1
'#ENDIF

#IF NOT %DEF(%GL_ARB_clear_buffer_object)
%GL_ARB_clear_buffer_object = 1

' ========================================================================================
' GLAPI void APIENTRY glClearBufferData (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
' ========================================================================================
DECLARE SUB glClearBufferData(BYVAL dwtarget AS DWORD, BYVAL dwinternalformat AS DWORD, BYVAL dwformat AS DWORD, BYVAL dwtype AS DWORD, BYVAL pdata AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glClearBufferSubData (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
' ========================================================================================
DECLARE SUB glClearBufferSubData(BYVAL dwtarget AS DWORD, BYVAL dwinternalformat AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG, BYVAL dwformat AS DWORD, BYVAL dwtype AS DWORD, BYVAL pdata AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glClearNamedBufferDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
' ========================================================================================
DECLARE SUB glClearNamedBufferDataEXT(BYVAL dwbuffer AS DWORD, BYVAL dwinternalformat AS DWORD, BYVAL dwformat AS DWORD, BYVAL dwtype AS DWORD, BYVAL pdata AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glClearNamedBufferSubDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
' ========================================================================================
DECLARE SUB glClearNamedBufferSubDataEXT(BYVAL dwbuffer AS DWORD, BYVAL dwinternalformat AS DWORD, BYVAL dwformat AS DWORD, BYVAL dwtype AS DWORD, BYVAL dwoffset AS DWORD, BYVAL dwsize AS DWORD, BYVAL pdata AS DWORD)

#ENDIF

#IF NOT %DEF(%GL_ARB_compute_shader)
%GL_ARB_compute_shader = 1

' ========================================================================================
' GLAPI void APIENTRY glDispatchCompute (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
' ========================================================================================
DECLARE SUB glDispatchCompute(BYVAL num_groups_x AS DWORD, BYVAL num_groups_y AS DWORD, BYVAL num_groups_z AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glDispatchComputeIndirect (GLintptr indirect);
' ========================================================================================
DECLARE SUB glDispatchComputeIndirect(BYVAL pindirect AS LONG)

#ENDIF

#IF NOT %DEF(%GL_ARB_copy_image)
%GL_ARB_copy_image = 1

' ========================================================================================
' GLAPI void APIENTRY glCopyImageSubData (GLuint srcName, GLenum srcTarget, GLint srcLevel, _
' GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
' ========================================================================================
DECLARE SUB glCopyImageSubData(BYVAL dwsrcName AS DWORD, BYVAL dwsrcTarget AS DWORD, BYVAL srcLevel AS LONG, _
   BYVAL srcX AS LONG, BYVAL srcY AS LONG, BYVAL srcZ AS LONG, BYVAL dstName AS DWORD, BYVAL dstTarget AS DWORD, _
   BYVAL dstLevel AS LONG, BYVAL dstX AS LONG, BYVAL dstY AS LONG, BYVAL dstZ AS LONG, BYVAL srcWidth AS LONG, _
   BYVAL srcHeight AS LONG, BYVAL srcDepth AS LONG)

#ENDIF

#IF NOT %DEF(%GL_ARB_texture_view)
%GL_ARB_texture_view = 1

' ========================================================================================
' GLAPI void APIENTRY glTextureView (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
' ========================================================================================
DECLARE SUB glTextureView(BYVAL dwtexture AS DWORD, BYVAL dwtarget AS DWORD, BYVAL dworigtexture AS DWORD, _
   BYVAL dwinternalformat AS DWORD, BYVAL minlevel AS DWORD, BYVAL numlevels AS DWORD, BYVAL minlayer AS DWORD, BYVAL numlayers AS DWORD)

#ENDIF

#IF NOT %DEF(%GL_ARB_vertex_attrib_binding)
%GL_ARB_vertex_attrib_binding = 1

' ========================================================================================
' GLAPI void APIENTRY glBindVertexBuffer (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
' ========================================================================================
DECLARE SUB glBindVertexBuffer(BYVAL dwbindingindex AS DWORD, BYVAL dwbuffer AS DWORD, BYVAL poffset AS LONG, BYVAL nstride AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribFormat (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
' ========================================================================================
DECLARE SUB glVertexAttribFormat(BYVAL dwattribindex AS DWORD, BYVAL nsize AS LONG, BYVAL dwtype AS DWORD, BYVAL bnormalized AS BYTE, BYVAL dwrelativeoffset AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribIFormat (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
' ========================================================================================
DECLARE SUB glVertexAttribIFormat(BYVAL dwattribindex AS DWORD, BYVAL nsize AS LONG, BYVAL dwtype AS DWORD, BYVAL dwrelativeoffset AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribLFormat (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
' ========================================================================================
DECLARE SUB glVertexAttribLFormat(BYVAL dwattribindex AS DWORD, BYVAL nsize AS LONG, BYVAL dwtype AS DWORD, BYVAL dwrelativeoffset AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribBinding (GLuint attribindex, GLuint bindingindex);
' ========================================================================================
DECLARE SUB glVertexAttribBinding(BYVAL dwattribindex AS DWORD, BYVAL bindingindex AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexBindingDivisor (GLuint bindingindex, GLuint divisor);
' ========================================================================================
DECLARE SUB glVertexBindingDivisor(BYVAL bindingindex AS DWORD, BYVAL divisor AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayBindVertexBufferEXT (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
' ========================================================================================
DECLARE SUB glVertexArrayBindVertexBufferEXT(BYVAL vaobj AS DWORD, BYVAL bindingindex AS DWORD, BYVAL dwbuffer AS DWORD, BYVAL poffset AS LONG, BYVAL stride AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayVertexAttribFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
' ========================================================================================
DECLARE SUB glVertexArrayVertexAttribFormatEXT(BYVAL vaobj AS DWORD, BYVAL attribindex AS DWORD, BYVAL nsize AS LONG, BYVAL dwtype AS DWORD, BYVAL normalized AS BYTE, BYVAL relativeoffset AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayVertexAttribIFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
' ========================================================================================
DECLARE SUB glVertexArrayVertexAttribIFormatEXT(BYVAL vaobj AS DWORD, BYVAL attribindex AS DWORD, BYVAL nsize AS LONG, BYVAL dwtype AS DWORD, BYVAL relativeoffset AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayVertexAttribLFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
' ========================================================================================
DECLARE SUB glVertexArrayVertexAttribLFormatEXT(BYVAL vaobj AS DWORD, BYVAL attribindex AS DWORD, BYVAL nsize AS LONG, BYVAL dwtype AS DWORD, BYVAL relativeoffset AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayVertexAttribBindingEXT (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
' ========================================================================================
DECLARE SUB glVertexArrayVertexAttribBindingEXT(BYVAL vaobj AS DWORD, BYVAL attribindex AS DWORD, BYVAL bindingindex AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayVertexBindingDivisorEXT (GLuint vaobj, GLuint bindingindex, GLuint divisor);
' ========================================================================================
DECLARE SUB glVertexArrayVertexBindingDivisorEXT(BYVAL vaobj AS DWORD, BYVAL bindingindex AS DWORD, BYVAL divisor AS DWORD)

#ENDIF

'#IF NOT %DEF(%GL_ARB_robustness_isolation)
'%GL_ARB_robustness_isolation = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_ES3_compatibility)
'%GL_ARB_ES3_compatibility = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_explicit_uniform_location)
'%GL_ARB_explicit_uniform_location = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_fragment_layer_viewport)
'%GL_ARB_fragment_layer_viewport = 1
'#ENDIF

#IF NOT %DEF(%GL_ARB_framebuffer_no_attachments)
%GL_ARB_framebuffer_no_attachments = 1

' ========================================================================================
' GLAPI void APIENTRY glFramebufferParameteri (GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glFramebufferParameteri(BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFramebufferParameteriv(BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glNamedFramebufferParameteriEXT (GLuint framebuffer, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glNamedFramebufferParameteriEXT(BYVAL framebuffer AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetNamedFramebufferParameterivEXT (GLuint framebuffer, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedFramebufferParameterivEXT(BYVAL framebuffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

#ENDIF

#IF NOT %DEF(%GL_ARB_internalformat_query2)
%GL_ARB_internalformat_query2 = 1

' ========================================================================================
' GLAPI void APIENTRY glGetInternalformati64v (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
' ========================================================================================
DECLARE SUB glGetInternalformati64v(BYVAL dwtarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL pname AS DWORD, BYVAL bufSize AS LONG, BYREF params AS QUAD)

#ENDIF

#IF NOT %DEF(%GL_ARB_invalidate_subdata)
%GL_ARB_invalidate_subdata = 1

' ========================================================================================
' GLAPI void APIENTRY glInvalidateTexSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
' ========================================================================================
DECLARE SUB glInvalidateTexSubImage(BYVAL dwtexture AS DWORD, BYVAL nlevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL ndepth AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glInvalidateTexImage (GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glInvalidateTexImage(BYVAL dwtexture AS DWORD, BYVAL nlevel AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glInvalidateBufferSubData (GLuint buffer, GLintptr offset, GLsizeiptr length);
' ========================================================================================
DECLARE SUB glInvalidateBufferSubData(BYVAL dwbuffer AS DWORD, BYVAL poffset AS LONG, BYVAL plength AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glInvalidateBufferData (GLuint buffer);
' ========================================================================================
DECLARE SUB glInvalidateBufferData(BYVAL dwbuffer AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments);
' ========================================================================================
DECLARE SUB glInvalidateFramebuffer(BYVAL dwtarget AS DWORD, BYVAL numAttachments AS LONG, BYREF attachments AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glInvalidateSubFramebuffer(BYVAL dwtarget AS DWORD, BYVAL numAttachments AS LONG, BYREF attachments AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nwidth AS LONG, BYVAL nheight AS LONG)

#ENDIF

#IF NOT %DEF(%GL_ARB_multi_draw_indirect)
%GL_ARB_multi_draw_indirect = 1

' ========================================================================================
' GLAPI void APIENTRY glMultiDrawArraysIndirect (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
' ========================================================================================
DECLARE SUB glMultiDrawArraysIndirect(BYVAL dwmode AS DWORD, BYREF indirect AS DWORD, BYVAL drawcount AS LONG, BYVAL stride AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiDrawElementsIndirect (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
' ========================================================================================
DECLARE SUB glMultiDrawElementsIndirect(BYVAL dwmode AS DWORD, BYVAL dwtype AS DWORD, BYREF indirect AS DWORD, BYVAL drawcount AS LONG, BYVAL stride AS LONG)

#ENDIF

#IF NOT %DEF(%GL_ARB_program_interface_query)
%GL_ARB_program_interface_query = 1

' ========================================================================================
' GLAPI void APIENTRY glGetProgramInterfaceiv (GLuint program, GLenum programInterface, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramInterfaceiv(BYVAL program AS DWORD, BYVAL programInterface AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' GLAPI GLuint APIENTRY glGetProgramResourceIndex (GLuint program, GLenum programInterface, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetProgramResourceIndex(BYVAL program AS DWORD, BYVAL programInterface AS DWORD, BYREF szname AS ASCIIZ) AS DWORD

' ========================================================================================
' GLAPI void APIENTRY glGetProgramResourceName (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
' ========================================================================================
DECLARE SUB glGetProgramResourceName(BYVAL program AS DWORD, BYVAL programInterface AS DWORD, BYVAL dwindex AS DWORD, BYVAL bufSize AS LONG, BYREF nlength AS LONG, BYREF szname AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glGetProgramResourceiv (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramResourceiv(BYVAL program AS DWORD, BYVAL programInterface AS DWORD, BYVAL dwindex AS DWORD, BYVAL propCount AS LONG, BYREF props AS DWORD, BYVAL bufSize AS LONG, BYREF nlength AS LONG, BYREF params AS LONG)

' ========================================================================================
' GLAPI GLint APIENTRY glGetProgramResourceLocation (GLuint program, GLenum programInterface, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetProgramResourceLocation(BYVAL program AS DWORD, BYVAL programInterface AS DWORD, BYREF szname AS ASCIIZ) AS LONG

' ========================================================================================
' GLAPI GLint APIENTRY glGetProgramResourceLocationIndex (GLuint program, GLenum programInterface, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetProgramResourceLocationIndex(BYVAL program AS DWORD, BYVAL programInterface AS DWORD, BYREF szname AS ASCIIZ) AS LONG

#ENDIF

'#IF NOT %DEF(%GL_ARB_robust_buffer_access_behavior)
'%GL_ARB_robust_buffer_access_behavior = 1
'#ENDIF

'#IF NOT %DEF(%GL_ARB_shader_image_size)
'%GL_ARB_shader_image_size = 1
'#ENDIF

#IF NOT %DEF(%GL_ARB_shader_storage_buffer_object)
%GL_ARB_shader_storage_buffer_object = 1

' ========================================================================================
' GLAPI void APIENTRY glShaderStorageBlockBinding (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
' ========================================================================================
DECLARE SUB glShaderStorageBlockBinding(BYVAL program AS DWORD, BYVAL storageBlockIndex AS DWORD, BYVAL storageBlockBinding AS DWORD)

#ENDIF

'#IF NOT %DEF(%GL_ARB_stencil_texturing)
'%GL_ARB_stencil_texturing = 1
'#ENDIF

#IF NOT %DEF(%GL_ARB_texture_buffer_range)
%GL_ARB_texture_buffer_range = 1

' ========================================================================================
' GLAPI void APIENTRY glTexBufferRange (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glTexBufferRange(BYVAL dwtarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwbuffer AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTextureBufferRangeEXT (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glTextureBufferRangeEXT(BYVAL dwtexture AS DWORD, BYVAL dwtarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL dwbuffer AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG)

#ENDIF

'#IF NOT %DEF(%GL_ARB_texture_query_levels)
'%GL_ARB_texture_query_levels = 1
'#ENDIF

#IF NOT %DEF(%GL_ARB_texture_storage_multisample)
%GL_ARB_texture_storage_multisample = 1

' ========================================================================================
' GLAPI void APIENTRY glTexStorage2DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
' ========================================================================================
DECLARE SUB glTexStorage2DMultisample(BYVAL dwtarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS DWORD, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL fixedsamplelocations AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexStorage3DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
' ========================================================================================
DECLARE SUB glTexStorage3DMultisample(BYVAL dwtarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS DWORD, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL ndepth AS LONG, BYVAL fixedsamplelocations AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTextureStorage2DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
' ========================================================================================
DECLARE SUB glTextureStorage2DMultisampleEXT(BYVAL dwtexture AS DWORD, BYVAL dwtarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS DWORD, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL fixedsamplelocations AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTextureStorage3DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
' ========================================================================================
DECLARE SUB glTextureStorage3DMultisampleEXT(BYVAL dwtexture AS DWORD, BYVAL dwtarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS DWORD, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL fixedsamplelocations AS BYTE)

#ENDIF

'#IF NOT %DEF(%GL_EXT_abgr)
'%GL_EXT_abgr = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_color)
'%GL_EXT_blend_color = 1

' ========================================================================================
' void glBlendColorEXT (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
' ========================================================================================
DECLARE SUB glBlendColorEXT (BYVAL fred AS SINGLE, BYVAL fgreen AS SINGLE, BYVAL fblue AS SINGLE, BYVAL falpha AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_polygon_offset)
'%GL_EXT_polygon_offset = 1

' ========================================================================================
' void glPolygonOffsetEXT (GLfloat factor, GLfloat bias);
' ========================================================================================
DECLARE SUB glPolygonOffsetEXT (BYVAL factor AS SINGLE, BYVAL bias AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture)
'%GL_EXT_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture3D)
'%GL_EXT_texture3D = 1

' ========================================================================================
' void glTexImage3DEXT (GLenum target, GLint level, GLenum internalformat,
' GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexImage3DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL nBorder AS LONG, _
   BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTexSubImage3DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexSubImage3DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
   BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture_filter4)
'%GL_SGIS_texture_filter4 = 1

' ========================================================================================
' void glGetTexFilterFuncSGIS (GLenum target, GLenum filter, GLfloat *weights);
' ========================================================================================
DECLARE SUB glGetTexFilterFuncSGIS (BYVAL dwTarget AS DWORD, BYVAL dwFilter AS DWORD, BYREF weights AS SINGLE)

' ========================================================================================
' void glTexFilterFuncSGIS (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
' ========================================================================================
DECLARE SUB glTexFilterFuncSGIS (BYVAL dwTarget AS DWORD, BYVAL dwFilter AS DWORD, BYVAL n AS LONG, BYREF weights AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_subtexture)
'%GL_EXT_subtexture = 1

' ========================================================================================
' void glTexSubImage1DEXT (GLenum target, GLint level, GLint xoffset, GLsizei width,
' GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexSubImage1DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTexSubImage2DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexSubImage2DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, _
   BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_copy_texture)
'%GL_EXT_copy_texture = 1

' ========================================================================================
' void glCopyTexImage1DEXT (GLenum target, GLint level, GLenum internalformat,
' GLint x, GLint y, GLsizei width, GLint border);
' ========================================================================================
DECLARE SUB glCopyTexImage1DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG)

' ========================================================================================
' void glCopyTexImage2DEXT (GLenum target, GLint level, GLenum internalformat,
' GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
' ========================================================================================
DECLARE SUB glCopyTexImage2DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG)

' ========================================================================================
' void glCopyTexSubImage1DEXT (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyTexSubImage1DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' void glCopyTexSubImage2DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyTexSubImage2DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glCopyTexSubImage3DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyTexSubImage3DEXT (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_histogram)
'%GL_EXT_histogram = 1

' ========================================================================================
' void glGetHistogramEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
' ========================================================================================
DECLARE SUB glGetHistogramEXT (BYVAL dwTarget AS DWORD, BYVAL bReset AS BYTE, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL values AS DWORD)

' ========================================================================================
' void glGetHistogramParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetHistogramParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetHistogramParameterivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetHistogramParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMinmaxEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
' ========================================================================================
DECLARE SUB glGetMinmaxEXT (BYVAL dwTarget AS DWORD, BYVAL bReset AS BYTE, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL values AS DWORD)

' ========================================================================================
' void glGetMinmaxParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMinmaxParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMinmaxParameterivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMinmaxParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glHistogramEXT (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
' ========================================================================================
DECLARE SUB glHistogramEXT (BYVAL dwTarget AS DWORD, BYVAL nWidth AS LONG, BYVAL internalformat AS DWORD, BYVAL bSink AS BYTE)

' ========================================================================================
' void glMinmaxEXT (GLenum target, GLenum internalformat, GLboolean sink);
' ========================================================================================
DECLARE SUB glMinmaxEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL bSink AS BYTE)

' ========================================================================================
' void glResetHistogramEXT (GLenum target);
' ========================================================================================
DECLARE SUB glResetHistogramEXT (BYVAL dwTarget AS DWORD)

' ========================================================================================
' void glResetMinmaxEXT (GLenum target);
' ========================================================================================
DECLARE SUB glResetMinmaxEXT (BYVAL dwTarget AS DWORD)

'#ENDIF


'#IF NOT %DEF(%GL_EXT_convolution)
'%GL_EXT_convolution = 1

' ========================================================================================
' void glConvolutionFilter1DEXT (GLenum target, GLenum internalformat, GLsizei width,
' GLenum format, GLenum type, const GLvoid *image);
' ========================================================================================
DECLARE SUB glConvolutionFilter1DEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' void glConvolutionFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width,
' GLsizei height, GLenum format, GLenum type, const GLvoid *image);
' ========================================================================================
DECLARE SUB glConvolutionFilter2DEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pImage AS DWORD)

' ========================================================================================
' void glConvolutionParameterfEXT (GLenum target, GLenum pname, GLfloat params);
' ========================================================================================
DECLARE SUB glConvolutionParameterfEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL params AS SINGLE)

' ========================================================================================
' void glConvolutionParameterfvEXT (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glConvolutionParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glConvolutionParameteriEXT (GLenum target, GLenum pname, GLint params);
' ========================================================================================
DECLARE SUB glConvolutionParameteriEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL params AS LONG)

' ========================================================================================
' void glConvolutionParameterivEXT (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glConvolutionParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glCopyConvolutionFilter1DEXT (GLenum target, GLenum internalformat,
' GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyConvolutionFilter1DEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' void glCopyConvolutionFilter2DEXT (GLenum target, GLenum internalformat,
' GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyConvolutionFilter2DEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glGetConvolutionFilterEXT (GLenum target, GLenum format, GLenum type, GLvoid *image);
' ========================================================================================
DECLARE SUB glGetConvolutionFilterEXT (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' void glGetConvolutionParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetConvolutionParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetConvolutionParameterivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetConvolutionParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetSeparableFilterEXT (GLenum target, GLenum format, GLenum type, GLvoid *row,
' GLvoid *column, GLvoid *span);
' ========================================================================================
DECLARE SUB glGetSeparableFilterEXT (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pRow AS DWORD, BYVAL pColumn AS DWORD, BYVAL pSpan AS DWORD)

' ========================================================================================
' void glSeparableFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width,
' GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
' ========================================================================================
DECLARE SUB glSeparableFilter2DEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pRow AS DWORD, BYVAL pColumn AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGI_color_matrix)
'%GL_SGI_color_matrix = 1
'#ENDIF


'#IF NOT %DEF(%GL_SGI_color_table)
'%GL_SGI_color_table = 1

' ========================================================================================
' void glColorTableSGI (GLenum target, GLenum internalformat, GLsizei width, GLenum format,
' GLenum type, const GLvoid *table);
' ========================================================================================
DECLARE SUB glColorTableSGI (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' void glColorTableParameterfvSGI (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glColorTableParameterfvSGI (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glColorTableParameterivSGI (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glColorTableParameterivSGI (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glCopyColorTableSGI (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyColorTableSGI (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' void glGetColorTableSGI (GLenum target, GLenum format, GLenum type, GLvoid *table);
' ========================================================================================
DECLARE SUB glGetColorTableSGI (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' void glGetColorTableParameterfvSGI (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetColorTableParameterfvSGI (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetColorTableParameterivSGI (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetColorTableParameterivSGI (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_pixel_texture)
'%GL_SGIX_pixel_texture = 1

' ========================================================================================
' void glPixelTexGenSGIX (GLenum mode);
' ========================================================================================
DECLARE SUB glPixelTexGenSGIX (BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGIS_pixel_texture)
'%GL_SGIS_pixel_texture = 1

' ========================================================================================
' void glPixelTexGenParameteriSGIS (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glPixelTexGenParameteriSGIS (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glPixelTexGenParameterivSGIS (GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glPixelTexGenParameterivSGIS (BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glPixelTexGenParameterfSGIS (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPixelTexGenParameterfSGIS (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glPixelTexGenParameterfvSGIS (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glPixelTexGenParameterfvSGIS (BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetPixelTexGenParameterivSGIS (GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetPixelTexGenParameterivSGIS (BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetPixelTexGenParameterfvSGIS (GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetPixelTexGenParameterfvSGIS (BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture4D)
'%GL_SGIS_texture4D = 1

' ========================================================================================
' void glTexImage4DSGIS (GLenum target, GLint level, GLenum internalformat, GLsizei width,
' GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexImage4DSGIS (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, nDepth AS LONG, BYVAL nSize4d AS LONG, BYVAL nBorder AS LONG, _
   BYVAL dwFormat AS LONG, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTexSubImage4DSGIS (GLenum target, GLint level, GLint xoffset, GLint yoffset,
' GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth,
' GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTexSubImage4DSGIS (BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL woffset AS LONG, BYVAL nWidth AS LONG, _
   BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL nSize4d AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGI_texture_color_table)
'%GL_SGI_texture_color_table = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_cmyka)
'%GL_EXT_cmyka = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_object)
'%GL_EXT_texture_object = 1

' ========================================================================================
' GLboolean glAreTexturesResidentEXT (GLsizei n, const GLuint *textures, GLboolean *residences);
' ========================================================================================
DECLARE FUNCTION glAreTexturesResidentEXT (BYVAL n AS LONG, BYREF textures AS DWORD, BYREF residences AS BYTE) AS BYTE

' ========================================================================================
' void glBindTextureEXT (GLenum target, GLuint texture);
' ========================================================================================
DECLARE SUB glBindTextureEXT (BYVAL dwTarget AS DWORD, BYVAL dwTexture AS DWORD)

' ========================================================================================
' void glDeleteTexturesEXT (GLsizei n, const GLuint *textures);
' ========================================================================================
DECLARE SUB glDeleteTexturesEXT (BYVAL n AS LONG, BYREF textures AS DWORD)

' ========================================================================================
' void glGenTexturesEXT (GLsizei n, GLuint *textures);
' ========================================================================================
DECLARE SUB glGenTexturesEXT (BYVAL n AS LONG, BYREF textures AS DWORD)

' ========================================================================================
' GLboolean glIsTextureEXT (GLuint texture);
' ========================================================================================
DECLARE FUNCTION glIsTextureEXT (BYVAL dwTexture AS DWORD) AS BYTE

' ========================================================================================
' void glPrioritizeTexturesEXT (GLsizei n, const GLuint *textures, const GLclampf *priorities);
' ========================================================================================
DECLARE SUB glPrioritizeTexturesEXT (BYVAL n AS LONG, BYREF textures AS DWORD, BYREF priorities AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIS_detail_texture)
'%GL_SGIS_detail_texture = 1

' ========================================================================================
' void glDetailTexFuncSGIS (GLenum target, GLsizei n, const GLfloat *points);
' ========================================================================================
DECLARE SUB glDetailTexFuncSGIS (BYVAL dwTarget AS DWORD, BYVAL n AS LONG, BYREF pPoints AS SINGLE)

' ========================================================================================
' void glGetDetailTexFuncSGIS (GLenum target, GLfloat *points);
' ========================================================================================
DECLARE SUB glGetDetailTexFuncSGIS (BYVAL dwTarget AS DWORD, BYREF pPoints AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIS_sharpen_texture)
'%GL_SGIS_sharpen_texture = 1

' ========================================================================================
' void glSharpenTexFuncSGIS (GLenum target, GLsizei n, const GLfloat *points);
' ========================================================================================
DECLARE SUB glSharpenTexFuncSGIS (BYVAL dwTarget AS DWORD, BYVAL n AS LONG, BYREF pPoints AS SINGLE)

' ========================================================================================
' void glGetSharpenTexFuncSGIS (GLenum target, GLfloat *points);
' ========================================================================================
DECLARE SUB glGetSharpenTexFuncSGIS (BYVAL dwTarget AS DWORD, BYREF pPoints AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_packed_pixels)
'%GL_EXT_packed_pixels = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture_lod)
'%GL_SGIS_texture_lod = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_multisample)
'%GL_SGIS_multisample = 1

' ========================================================================================
' void glSampleMaskSGIS (GLclampf value, GLboolean invert);
' ========================================================================================
DECLARE SUB glSampleMaskSGIS (BYVAL value AS SINGLE, BYVAL invert AS BYTE)

' ========================================================================================
' void glSamplePatternSGIS (GLenum pattern);
' ========================================================================================
DECLARE SUB glSamplePatternSGIS (BYVAL dwpattern AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_rescale_normal)
'%GL_EXT_rescale_normal = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_vertex_array)
'%GL_EXT_vertex_array = 1

' ========================================================================================
' Render a vertex using the specified vertex array element.
' void glArrayElementEXT (GLint i);
' ========================================================================================
DECLARE SUB glArrayElementEXT (BYVAL i AS LONG)

' ========================================================================================
' void glColorPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glColorPointerEXT (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL nCount AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' Define a array of   colors.
' void glDrawArraysEXT (GLenum mode, GLint first, GLsizei count);
' ========================================================================================
DECLARE SUB glDrawArraysEXT (BYVAL dwMode AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS LONG)

' ========================================================================================
' Define   an array of edge flags
' void glEdgeFlagPointerEXT (GLsizei stride, GLsizei count, const GLboolean *pointer);
' ========================================================================================
DECLARE SUB glEdgeFlagPointerEXT (BYVAL nStride AS LONG, BYVAL nCount AS LONG, BYREF pPointer AS BYTE)

' ========================================================================================
' Return the   address   of a vertex data array.
' void glGetPointervEXT (GLenum pname, GLvoid* *params);
' ========================================================================================
DECLARE SUB glGetPointervEXT (BYVAL pname AS DWORD, BYVAL params AS DWORD)

' ========================================================================================
' Define an   array of color indexes.
' void glIndexPointerEXT (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glIndexPointerEXT (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL nCount AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' Define a   array of normals.
' void glNormalPointerEXT (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glNormalPointerEXT (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL nCount AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' Define   an array of texture coordinates.
' void glTexCoordPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glTexCoordPointerEXT (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL nCount AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' Define an array of vertex data.
' void glVertexPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexPointerEXT (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL nCount AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_misc_attribute)
'%GL_EXT_misc_attribute = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_generate_mipmap)
'%GL_SGIS_generate_mipmap = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_clipmap)
'%GL_SGIX_clipmap = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_shadow)
'%GL_SGIX_shadow = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture_edge_clamp)
'%GL_SGIS_texture_edge_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture_border_clamp)
'%GL_SGIS_texture_border_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_minmax)
'%GL_EXT_blend_minmax = 1

' ========================================================================================
' Set the blend equation.
' void glBlendEquationEXT (GLenum mode);
' ========================================================================================
DECLARE SUB glBlendEquationEXT (BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_subtract)
'%GL_EXT_blend_subtract = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_logic_op)
'%GL_EXT_blend_logic_op = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_interlace)
'%GL_SGIX_interlace = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_pixel_tiles)
'%GL_SGIX_pixel_tiles = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture_select)
'%GL_SGIS_texture_select = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_sprite)
'%GL_SGIX_sprite = 1

' ========================================================================================
' void glSpriteParameterfSGIX (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glSpriteParameterfSGIX (BYVAL pname AS DWORD, BYVAL params AS SINGLE)

' ========================================================================================
' void glSpriteParameterfvSGIX (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glSpriteParameterfvSGIX (BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glSpriteParameteriSGIX (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glSpriteParameteriSGIX (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glSpriteParameterivSGIX (GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glSpriteParameterivSGIX (BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_texture_multi_buffer)
'%GL_SGIX_texture_multi_buffer = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_point_parameters)
'%GL_EXT_point_parameters = 1

' ========================================================================================
' void glPointParameterfEXT (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPointParameterfEXT (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glPointParameterfvEXT (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glPointParameterfvEXT (BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIS_point_parameters)
'%GL_SGIS_point_parameters = 1

' ========================================================================================
' void glPointParameterfSGIS (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPointParameterfSGIS (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glPointParameterfvSGIS (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glPointParameterfvSGIS (BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_instruments)
'%GL_SGIX_instruments = 1

' ========================================================================================
' GLint glGetInstrumentsSGIX (void);
' ========================================================================================
DECLARE FUNCTION glGetInstrumentsSGIX () AS LONG

' ========================================================================================
' void glInstrumentsBufferSGIX (GLsizei size, GLint *buffer);
' ========================================================================================
DECLARE SUB glInstrumentsBufferSGIX (BYVAL nSize AS LONG, BYREF buffer AS LONG)

' ========================================================================================
' GLint glPollInstrumentsSGIX (GLint *marker_p);
' ========================================================================================
DECLARE FUNCTION glPollInstrumentsSGIX (BYREF marker_p AS LONG) AS LONG

' ========================================================================================
' void glReadInstrumentsSGIX (GLint marker);
' ========================================================================================
DECLARE SUB glReadInstrumentsSGIX (BYVAL imarker AS LONG)

' ========================================================================================
' void glStartInstrumentsSGIX (void);
' ========================================================================================
DECLARE SUB glStartInstrumentsSGIX

' ========================================================================================
' void glStopInstrumentsSGIX (GLint marker);
' ========================================================================================
DECLARE SUB glStopInstrumentsSGIX (BYVAL marker AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_texture_scale_bias)
'%GL_SGIX_texture_scale_bias = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_framezoom)
'%GL_SGIX_framezoom = 1

' ========================================================================================
' void glFrameZoomSGIX (GLint factor);
' ========================================================================================
DECLARE SUB glFrameZoomSGIX (BYVAL factor AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_tag_sample_buffer)
'%GL_SGIX_tag_sample_buffer = 1

' ========================================================================================
' void glTagSampleBufferSGIX (void);
' ========================================================================================
DECLARE SUB glTagSampleBufferSGIX

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_polynomial_ffd)
'%GL_SGIX_polynomial_ffd = 1

' ========================================================================================
' void glDeformationMap3dSGIX (GLenum target, GLdouble u1, GLdouble u2, GLint ustride,
' GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1,
' GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
' ========================================================================================
DECLARE SUB glDeformationMap3dSGIX (BYVAL dwTarget AS DWORD, BYVAL u1 AS DOUBLE, BYVAL u2 AS DOUBLE, BYVAL ustride AS LONG, BYVAL uorder AS LONG, BYVAL v1 AS DOUBLE, BYVAL v2 AS DOUBLE, _
   BYVAL vstride AS LONG, BYVAL vorder AS LONG, BYVAL w1 AS DOUBLE, BYVAL w2 AS DOUBLE, BYVAL wstride AS LONG, BYVAL worder AS LONG, BYREF pPoints AS DOUBLE)

' ========================================================================================
' void glDeformationMap3fSGIX (GLenum target, GLfloat u1, GLfloat u2, GLint ustride,
' GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1,
' GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
' ========================================================================================
DECLARE SUB glDeformationMap3fSGIX (BYVAL dwTarget AS DWORD, BYVAL u1 AS SINGLE, BYVAL u2 AS SINGLE, BYVAL ustride AS LONG, BYVAL uorder AS LONG, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, _
   BYVAL vstride AS LONG, BYVAL vorder AS LONG, BYVAL w1 AS SINGLE, BYVAL w2 AS SINGLE, BYVAL wstride AS LONG, BYVAL worder AS LONG, BYREF fpoints AS SINGLE)

' ========================================================================================
' void glDeformSGIX (GLbitfield mask);
' ========================================================================================
DECLARE SUB glDeformSGIX (BYVAL dwMask AS DWORD)

' ========================================================================================
' void glLoadIdentityDeformationMapSGIX (GLbitfield mask);
' ========================================================================================
DECLARE SUB glLoadIdentityDeformationMapSGIX (BYVAL dwMask AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_reference_plane)
'%GL_SGIX_reference_plane = 1

' ========================================================================================
' void glReferencePlaneSGIX (const GLdouble *equation);
' ========================================================================================
DECLARE SUB glReferencePlaneSGIX (BYREF equation AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_flush_raster)
'%GL_SGIX_flush_raster = 1

' ========================================================================================
' void glFlushRasterSGIX (void);
' ========================================================================================
DECLARE SUB glFlushRasterSGIX

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_depth_texture)
'%GL_SGIX_depth_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_fog_function)
'%GL_SGIS_fog_DECLARE FUNCTION = 1

' ========================================================================================
' void glFogFuncSGIS (GLsizei n, const GLfloat *points);
' ========================================================================================
DECLARE SUB glFogFuncSGIS (BYVAL n AS LONG, BYREF fpoints AS SINGLE)

' ========================================================================================
' void glGetFogFuncSGIS (GLfloat *points);
' ========================================================================================
DECLARE SUB glGetFogFuncSGIS (BYREF fpoints AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_fog_offset)
'%GL_SGIX_fog_offset = 1
'#ENDIF

'#IF NOT %DEF(%GL_HP_image_transform)
'%GL_HP_image_transform = 1

' ========================================================================================
' void glImageTransformParameteriHP (GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glImageTransformParameteriHP (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glImageTransformParameterfHP (GLenum target, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glImageTransformParameterfHP (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glImageTransformParameterivHP (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glImageTransformParameterivHP (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glImageTransformParameterfvHP (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glImageTransformParameterfvHP (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetImageTransformParameterivHP (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetImageTransformParameterivHP (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetImageTransformParameterfvHP (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetImageTransformParameterfvHP (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_HP_convolution_border_modes)
'%GL_HP_convolution_border_modes = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_texture_add_env)
'%GL_SGIX_texture_add_env = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_color_subtable)
'%GL_EXT_color_subtable = 1

' ========================================================================================
' void glColorSubTableEXT (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
' ========================================================================================
DECLARE SUB glColorSubTableEXT (BYVAL dwTarget AS DWORD, BYVAL nStart AS LONG, BYVAL nCount AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' void glCopyColorSubTableEXT (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyColorSubTableEXT (BYVAL dwTarget AS DWORD, BYVAL nStart AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_PGI_vertex_hints)
'%GL_PGI_vertex_hints = 1
'#ENDIF

'#IF NOT %DEF(%GL_PGI_misc_hints)
'%GL_PGI_misc_hints = 1

' ========================================================================================
' void glHintPGI (GLenum target, GLint mode);
' ========================================================================================
DECLARE SUB glHintPGI (BYVAL dwTarget AS DWORD, BYVAL nMode AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_paletted_texture)
'%GL_EXT_paletted_texture = 1

' ========================================================================================
' Define a color lookup table.
' void glColorTableEXT (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
' GLenum type, const GLvoid *table);
' ========================================================================================
DECLARE SUB glColorTableEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' Get color table contents.
' void glGetColorTableEXT (GLenum target, GLenum format, GLenum type, GLvoid *data);
' ========================================================================================
DECLARE SUB glGetColorTableEXT (BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pTable AS DWORD)

' ========================================================================================
' Get palette parameters from color tables.
' void glGetColorTableParameterivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetColorTableParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetColorTableParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetColorTableParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_clip_volume_hint)
'%GL_EXT_clip_volume_hint = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_list_priority)
'%GL_SGIX_list_priority = 1

' ========================================================================================
' void glGetListParameterfvSGIX (GLuint list, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetListParameterfvSGIX (BYVAL dwList AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetListParameterivSGIX (GLuint list, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetListParameterivSGIX (BYVAL dwList AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glListParameterfSGIX (GLuint list, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glListParameterfSGIX (BYVAL dwList AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glListParameterfvSGIX (GLuint list, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glListParameterfvSGIX (BYVAL dwList AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glListParameteriSGIX (GLuint list, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glListParameteriSGIX (BYVAL dwList AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glListParameterivSGIX (GLuint list, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glListParameterivSGIX (BYVAL dwList AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_ir_instrument1)
'%GL_SGIX_ir_instrument1 = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_calligraphic_fragment)
'%GL_SGIX_calligraphic_fragment = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_texture_lod_bias)
'%GL_SGIX_texture_lod_bias = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_shadow_ambient)
'%GL_SGIX_shadow_ambient = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_index_texture)
'%GL_EXT_index_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_index_material)
'%GL_EXT_index_material = 1

' ========================================================================================
' void glIndexMaterialEXT (GLenum face, GLenum mode);
' ========================================================================================
DECLARE SUB glIndexMaterialEXT (BYVAL dwFace AS DWORD, BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_index_func)
'%GL_EXT_index_func = 1

' ========================================================================================
' void glIndexFuncEXT (GLenum func, GLclampf ref);
' ========================================================================================
DECLARE SUB glIndexFuncEXT (BYVAL dwFunc AS DWORD, BYVAL ref AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_index_array_formats)
'%GL_EXT_index_array_formats = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_compiled_vertex_array)
'%GL_EXT_compiled_vertex_array = 1

' ========================================================================================
' void glLockArraysEXT (GLint first, GLsizei count);
' ========================================================================================
DECLARE SUB glLockArraysEXT (BYVAL nFirst AS LONG, BYVAL nCount AS LONG)

' ========================================================================================
' void glUnlockArraysEXT (void);
' ========================================================================================
DECLARE SUB glUnlockArraysEXT

'#ENDIF

'#IF NOT %DEF(%GL_EXT_cull_vertex)
'%GL_EXT_cull_vertex = 1

' ========================================================================================
' void glCullParameterdvEXT (GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glCullParameterdvEXT (BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glCullParameterfvEXT (GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glCullParameterfvEXT (BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_ycrcb)
'%GL_SGIX_ycrcb = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_fragment_lighting)
'%GL_SGIX_fragment_lighting = 1

' ========================================================================================
' void glFragmentColorMaterialSGIX (GLenum face, GLenum mode);
' ========================================================================================
DECLARE SUB glFragmentColorMaterialSGIX (BYVAL dwFace AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' void glFragmentLightfSGIX (GLenum light, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glFragmentLightfSGIX (BYVAL dwLight AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glFragmentLightfvSGIX (GLenum light, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glFragmentLightfvSGIX (BYVAL dwLight AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glFragmentLightiSGIX (GLenum light, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glFragmentLightiSGIX (BYVAL dwLight AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glFragmentLightivSGIX (GLenum light, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glFragmentLightivSGIX (BYVAL dwLight AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glFragmentLightModelfSGIX (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glFragmentLightModelfSGIX (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glFragmentLightModelfvSGIX (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glFragmentLightModelfvSGIX (BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glFragmentLightModeliSGIX (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glFragmentLightModeliSGIX (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glFragmentLightModelivSGIX (GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glFragmentLightModelivSGIX (BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glFragmentMaterialfSGIX (GLenum face, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glFragmentMaterialfSGIX (BYVAL dwFace AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glFragmentMaterialfvSGIX (GLenum face, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glFragmentMaterialfvSGIX (BYVAL dwFace AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glFragmentMaterialiSGIX (GLenum face, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glFragmentMaterialiSGIX (BYVAL dwFace AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glFragmentMaterialivSGIX (GLenum face, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glFragmentMaterialivSGIX (BYVAL dwFace AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetFragmentLightfvSGIX (GLenum light, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetFragmentLightfvSGIX (BYVAL dwLight AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetFragmentLightivSGIX (GLenum light, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFragmentLightivSGIX (BYVAL dwLight AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetFragmentMaterialfvSGIX (GLenum face, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetFragmentMaterialfvSGIX (BYVAL dwFace AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetFragmentMaterialivSGIX (GLenum face, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFragmentMaterialivSGIX (BYVAL dwFace AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glLightEnviSGIX (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glLightEnviSGIX (BYVAL pname AS DWORD, BYVAL param AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_IBM_rasterpos_clip)
'%GL_IBM_rasterpos_clip = 1
'#ENDIF

'#IF NOT %DEF(%GL_HP_texture_lighting)
'%GL_HP_texture_lighting = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_draw_range_elements)
'%GL_EXT_draw_range_elements = 1

' ========================================================================================
' void glDrawRangeElementsEXT (GLenum mode, GLuint start, GLuint end, GLsizei count,
' GLenum type, const GLvoid *indices);
' ========================================================================================
DECLARE SUB glDrawRangeElementsEXT (BYVAL dwMode AS DWORD, BYVAL dwStart AS DWORD, BYVAL dwEnd AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_WIN_phong_shading)
'%GL_WIN_phong_shading = 1
'#ENDIF

'#IF NOT %DEF(%GL_WIN_specular_fog)
'%GL_WIN_specular_fog = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_light_texture)
'%GL_EXT_light_texture = 1

' ========================================================================================
' void glApplyTextureEXT (GLenum mode);
' ========================================================================================
DECLARE SUB glApplyTextureEXT (BYVAL dwMode AS DWORD)

' ========================================================================================
' void glTextureLightEXT (GLenum pname);
' ========================================================================================
DECLARE SUB glTextureLightEXT (BYVAL pname AS DWORD)

' ========================================================================================
' void glTextureMaterialEXT (GLenum face, GLenum mode);
' ========================================================================================
DECLARE SUB glTextureMaterialEXT (BYVAL dwFace AS DWORD, BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_blend_alpha_minmax)
'%GL_SGIX_blend_alpha_minmax = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_bgra)
'%GL_EXT_bgra = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_async)
'%GL_SGIX_async = 1

' ========================================================================================
' void glAsyncMarkerSGIX (GLuint marker);
' ========================================================================================
DECLARE SUB glAsyncMarkerSGIX (BYVAL marker AS DWORD)

' ========================================================================================
' GLint glFinishAsyncSGIX (GLuint *markerp);
' ========================================================================================
DECLARE FUNCTION glFinishAsyncSGIX (BYREF markerp AS DWORD) AS LONG

' ========================================================================================
' GLint glPollAsyncSGIX (GLuint *markerp);
' ========================================================================================
DECLARE FUNCTION glPollAsyncSGIX (BYREF markerp AS DWORD) AS LONG

' ========================================================================================
' GLuint glGenAsyncMarkersSGIX (GLsizei range);
' ========================================================================================
DECLARE FUNCTION glGenAsyncMarkersSGIX (BYVAL nRange AS LONG) AS DWORD

' ========================================================================================
' void glDeleteAsyncMarkersSGIX (GLuint marker, GLsizei range);
' ========================================================================================
DECLARE SUB glDeleteAsyncMarkersSGIX (BYVAL marker AS DWORD, BYVAL nRange AS LONG)

' ========================================================================================
' GLboolean glIsAsyncMarkerSGIX (GLuint marker);
' ========================================================================================
DECLARE FUNCTION glIsAsyncMarkerSGIX (BYVAL marker AS DWORD) AS BYTE

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_async_pixel)
'%GL_SGIX_async_pixel = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_async_histogram)
'%GL_SGIX_async_histogram = 1
'#ENDIF

'#IF NOT %DEF(%GL_INTEL_parallel_arrays)
'%GL_INTEL_parallel_arrays = 1

' ========================================================================================
' void glVertexPointervINTEL (GLint size, GLenum type, const GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glVertexPointervINTEL (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glNormalPointervINTEL (GLenum type, const GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glNormalPointervINTEL (BYVAL dwType AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glColorPointervINTEL (GLint size, GLenum type, const GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glColorPointervINTEL (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glTexCoordPointervINTEL (GLint size, GLenum type, const GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glTexCoordPointervINTEL (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL pPointer AS DWORD)

'#ENDIF ' %GL_GLEXT_PROTOTYPES
'#ENDIF

'#IF NOT %DEF(%GL_HP_occlusion_test)
'%GL_HP_occlusion_test = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_pixel_transform)
'%GL_EXT_pixel_transform = 1

' ========================================================================================
' void glPixelTransformParameteriEXT (GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glPixelTransformParameteriEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glPixelTransformParameterfEXT (GLenum target, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPixelTransformParameterfEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glPixelTransformParameterivEXT (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glPixelTransformParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glPixelTransformParameterfvEXT (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glPixelTransformParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPixelTransformParameterivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetPixelTransformParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetPixelTransformParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetPixelTransformParameterfvEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF ' %GL_GLEXT_PROTOTYPES
'#ENDIF

'#IF NOT %DEF(%GL_EXT_pixel_transform_color_table)
'%GL_EXT_pixel_transform_color_table = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_shared_texture_palette)
'%GL_EXT_shared_texture_palette = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_separate_specular_color)
'%GL_EXT_separate_specular_color = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_secondary_color)
'%GL_EXT_secondary_color = 1

' ========================================================================================
' void glSecondaryColor3bEXT (GLbyte red, GLbyte green, GLbyte blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3bEXT (BYVAL red AS BYTE, BYVAL green AS BYTE, BYVAL blue AS BYTE)

' ========================================================================================
' void glSecondaryColor3bvEXT (const GLbyte *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3bvEXT (BYREF v AS BYTE)

' ========================================================================================
' void glSecondaryColor3dEXT (GLdouble red, GLdouble green, GLdouble blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3dEXT (BYVAL red AS DOUBLE, BYVAL green AS DOUBLE, BYVAL blue AS DOUBLE)

' ========================================================================================
' void glSecondaryColor3dvEXT (const GLdouble *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3dvEXT (BYREF v AS DOUBLE)

' ========================================================================================
' void glSecondaryColor3fEXT (GLfloat red, GLfloat green, GLfloat blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3fEXT (BYVAL red AS SINGLE, BYVAL green AS SINGLE, BYVAL blue AS SINGLE)

' ========================================================================================
' void glSecondaryColor3fvEXT (const GLfloat *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3fvEXT (BYREF v AS SINGLE)

' ========================================================================================
' void glSecondaryColor3iEXT (GLint red, GLint green, GLint blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3iEXT (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG)

' ========================================================================================
' void glSecondaryColor3ivEXT (const GLint *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3ivEXT (BYREF v AS LONG)

' ========================================================================================
' void glSecondaryColor3sEXT (GLshort red, GLshort green, GLshort blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3sEXT (BYVAL red AS INTEGER, BYVAL green AS INTEGER, BYVAL blue AS INTEGER)

' ========================================================================================
' void glSecondaryColor3svEXT (const GLshort *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3svEXT (BYREF v AS INTEGER)

' ========================================================================================
' void glSecondaryColor3ubEXT (GLubyte red, GLubyte green, GLubyte blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3ubEXT (BYVAL red AS BYTE, BYVAL green AS BYTE, BYVAL blue AS BYTE)

' ========================================================================================
' void glSecondaryColor3ubvEXT (const GLubyte *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3ubvEXT (BYREF v AS BYTE)

' ========================================================================================
' void glSecondaryColor3uiEXT (GLuint red, GLuint green, GLuint blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3uiEXT (BYVAL red AS DWORD, BYVAL green AS DWORD, BYVAL blue AS DWORD)

' ========================================================================================
' void glSecondaryColor3uivEXT (const GLuint *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3uivEXT (BYREF v AS DWORD)

' ========================================================================================
' void glSecondaryColor3usEXT (GLushort red, GLushort green, GLushort blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3usEXT (BYVAL red AS WORD, BYVAL green AS WORD, BYVAL blue AS WORD)

' ========================================================================================
' void glSecondaryColor3usvEXT (const GLushort *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3usvEXT (BYREF v AS WORD)

' ========================================================================================
' void glSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glSecondaryColorPointerEXT (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_perturb_normal)
'%GL_EXT_texture_perturb_normal = 1

' ========================================================================================
' void glTextureNormalEXT (GLenum mode);
' ========================================================================================
DECLARE SUB glTextureNormalEXT (BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_multi_draw_arrays)
'%GL_EXT_multi_draw_arrays = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' GLAPI void APIENTRY glMultiDrawArraysEXT (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
' ========================================================================================
DECLARE SUB glMultiDrawArraysEXT (BYVAL dwMode AS DWORD, BYREF nFirst AS LONG, BYREF nCount AS LONG, BYVAL primcount AS DWORD)

' ========================================================================================
' void glMultiDrawElementsEXT (GLenum mode, const GLsizei *count, GLenum type,
' const GLvoid* *indices, GLsizei primcount);
' ========================================================================================
DECLARE SUB glMultiDrawElementsEXT (BYVAL dwMode AS DWORD, BYREF nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL primcount AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_fog_coord)
'%GL_EXT_fog_coord = 1

' ========================================================================================
' void glFogCoordfEXT (GLfloat coord);
' ========================================================================================
DECLARE SUB glFogCoordfEXT (BYVAL fCoord AS SINGLE)

' ========================================================================================
' void glFogCoordfvEXT (const GLfloat *coord);
' ========================================================================================
DECLARE SUB glFogCoordfvEXT (BYREF fCoord AS SINGLE)

' ========================================================================================
' void glFogCoorddEXT (GLdouble coord);
' ========================================================================================
DECLARE SUB glFogCoorddEXT (BYVAL dCoord AS DOUBLE)

' ========================================================================================
' void glFogCoorddvEXT (const GLdouble *coord);
' ========================================================================================
DECLARE SUB glFogCoorddvEXT (BYREF dCoord AS DOUBLE)

' ========================================================================================
' void glFogCoordPointerEXT (GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glFogCoordPointerEXT (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_REND_screen_coordinates)
'%GL_REND_screen_coordinates = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_coordinate_frame)
'%GL_EXT_coordinate_frame = 1

' ========================================================================================
' void glTangent3bEXT (GLbyte tx, GLbyte ty, GLbyte tz);
' ========================================================================================
DECLARE SUB glTangent3bEXT (BYVAL tx AS BYTE, BYVAL ty AS BYTE, BYVAL tz AS BYTE)

' ========================================================================================
' void glTangent3bvEXT (const GLbyte *v);
' ========================================================================================
DECLARE SUB glTangent3bvEXT (BYREF v AS BYTE)

' ========================================================================================
' void glTangent3dEXT (GLdouble tx, GLdouble ty, GLdouble tz);
' ========================================================================================
DECLARE SUB glTangent3dEXT (BYVAL tx AS DOUBLE, BYVAL ty AS DOUBLE, BYVAL tz AS DOUBLE)

' ========================================================================================
' void glTangent3dvEXT (const GLdouble *v);
' ========================================================================================
DECLARE SUB glTangent3dvEXT (BYREF v AS DOUBLE)

' ========================================================================================
' void glTangent3fEXT (GLfloat tx, GLfloat ty, GLfloat tz);
' ========================================================================================
DECLARE SUB glTangent3fEXT (BYVAL tx AS SINGLE, BYVAL ty AS SINGLE, BYVAL tz AS SINGLE)

' ========================================================================================
' void glTangent3fvEXT (const GLfloat *v);
' ========================================================================================
DECLARE SUB glTangent3fvEXT (BYREF v AS SINGLE)

' ========================================================================================
' void glTangent3iEXT (GLint tx, GLint ty, GLint tz);
' ========================================================================================
DECLARE SUB glTangent3iEXT (BYVAL tx AS LONG, BYVAL ty AS LONG, BYVAL tz AS LONG)

' ========================================================================================
' void glTangent3ivEXT (const GLint *v);
' ========================================================================================
DECLARE SUB glTangent3ivEXT (BYREF v AS LONG)

' ========================================================================================
' void glTangent3sEXT (GLshort tx, GLshort ty, GLshort tz);
' ========================================================================================
DECLARE SUB glTangent3sEXT (BYVAL tx AS INTEGER, BYVAL ty AS INTEGER, BYVAL tz AS INTEGER)

' ========================================================================================
' void glTangent3svEXT (const GLshort *v);
' ========================================================================================
DECLARE SUB glTangent3svEXT (BYREF v AS INTEGER)

' ========================================================================================
' void glBinormal3bEXT (GLbyte bx, GLbyte by, GLbyte bz);
' ========================================================================================
DECLARE SUB glBinormal3bEXT (BYVAL bx AS BYTE, BYVAL by AS BYTE, BYVAL bz AS BYTE)

' ========================================================================================
' void glBinormal3bvEXT (const GLbyte *v);
' ========================================================================================
DECLARE SUB glBinormal3bvEXT (BYREF v AS BYTE)

' ========================================================================================
' void glBinormal3dEXT (GLdouble bx, GLdouble by, GLdouble bz);
' ========================================================================================
DECLARE SUB glBinormal3dEXT (BYVAL bx AS DOUBLE, BYVAL by AS DOUBLE, BYVAL bz AS DOUBLE)

' ========================================================================================
' void glBinormal3dvEXT (const GLdouble *v);
' ========================================================================================
DECLARE SUB glBinormal3dvEXT (BYREF v AS DOUBLE)

' ========================================================================================
' void glBinormal3fEXT (GLfloat bx, GLfloat by, GLfloat bz);
' ========================================================================================
DECLARE SUB glBinormal3fEXT (BYVAL bx AS SINGLE, BYVAL by AS SINGLE, BYVAL bz AS SINGLE)

' ========================================================================================
' void glBinormal3fvEXT (const GLfloat *v);
' ========================================================================================
DECLARE SUB glBinormal3fvEXT (BYREF v AS SINGLE)

' ========================================================================================
' void glBinormal3iEXT (GLint bx, GLint by, GLint bz);
' ========================================================================================
DECLARE SUB glBinormal3iEXT (BYVAL bx AS LONG, BYVAL by AS LONG, BYVAL bz AS LONG)

' ========================================================================================
' void glBinormal3ivEXT (const GLint *v);
' ========================================================================================
DECLARE SUB glBinormal3ivEXT (BYREF v AS LONG)

' ========================================================================================
' void glBinormal3sEXT (GLshort bx, GLshort by, GLshort bz);
' ========================================================================================
DECLARE SUB glBinormal3sEXT (BYVAL bx AS INTEGER, BYVAL by AS INTEGER, BYVAL bz AS INTEGER)

' ========================================================================================
' void glBinormal3svEXT (const GLshort *v);
' ========================================================================================
DECLARE SUB glBinormal3svEXT (BYREF v AS INTEGER)

' ========================================================================================
' void glTangentPointerEXT (GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glTangentPointerEXT (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glBinormalPointerEXT (GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glBinormalPointerEXT (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_env_combine)
'%GL_EXT_texture_env_combine = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_specular_vector)
'%GL_APPLE_specular_vector = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_transform_hint)
'%GL_APPLE_transform_hint = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_fog_scale)
'%GL_SGIX_fog_scale = 1
'#ENDIF

'#IF NOT %DEF(%GL_SUNX_constant_data)
'%GL_SUNX_constant_data = 1

' ========================================================================================
' void glFinishTextureSUNX (void);
' ========================================================================================
DECLARE SUB glFinishTextureSUNX

'#ENDIF

'#IF NOT %DEF(%GL_SUN_global_alpha)
'%GL_SUN_global_alpha = 1

' ========================================================================================
' void glGlobalAlphaFactorbSUN (GLbyte factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactorbSUN (BYVAL factor AS BYTE)

' ========================================================================================
' void glGlobalAlphaFactorsSUN (GLshort factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactorsSUN (BYVAL factor AS INTEGER)

' ========================================================================================
' void glGlobalAlphaFactoriSUN (GLint factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactoriSUN (BYVAL factor AS LONG)

' ========================================================================================
' void glGlobalAlphaFactorfSUN (GLfloat factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactorfSUN (BYVAL factor AS SINGLE)

' ========================================================================================
' void glGlobalAlphaFactordSUN (GLdouble factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactordSUN (BYVAL factor AS DOUBLE)

' ========================================================================================
' void glGlobalAlphaFactorubSUN (GLubyte factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactorubSUN (BYVAL factor AS BYTE)

' ========================================================================================
' void glGlobalAlphaFactorusSUN (GLushort factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactorusSUN (BYVAL factor AS WORD)

' ========================================================================================
' void glGlobalAlphaFactoruiSUN (GLuint factor);
' ========================================================================================
DECLARE SUB glGlobalAlphaFactoruiSUN (BYVAL factor AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SUN_triangle_list)
'%GL_SUN_triangle_list = 1

' ========================================================================================
' void glReplacementCodeuiSUN (GLuint code);
' ========================================================================================
DECLARE SUB glReplacementCodeuiSUN (BYVAL dwCode AS DWORD)

' ========================================================================================
' void glReplacementCodeusSUN (GLushort code);
' ========================================================================================
DECLARE SUB glReplacementCodeusSUN (BYVAL wCode AS WORD)

' ========================================================================================
' void glReplacementCodeubSUN (GLubyte code);
' ========================================================================================
DECLARE SUB glReplacementCodeubSUN (BYVAL bCode AS BYTE)

' ========================================================================================
' void glReplacementCodeuivSUN (const GLuint *code);
' ========================================================================================
DECLARE SUB glReplacementCodeuivSUN (BYREF dwCode AS DWORD)

' ========================================================================================
' void glReplacementCodeusvSUN (const GLushort *code);
' ========================================================================================
DECLARE SUB glReplacementCodeusvSUN (BYREF wCode AS WORD)

' ========================================================================================
' void glReplacementCodeubvSUN (const GLubyte *code);
' ========================================================================================
DECLARE SUB glReplacementCodeubvSUN (BYREF bCode AS BYTE)

' ========================================================================================
' void glReplacementCodePointerSUN (GLenum type, GLsizei stride, const GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glReplacementCodePointerSUN (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SUN_vertex)
'%GL_SUN_vertex = 1

' ========================================================================================
' void glColor4ubVertex2fSUN (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glColor4ubVertex2fSUN (BYVAL r AS BYTE, BYVAL g AS BYTE, BYVAL b AS BYTE, BYVAL a AS BYTE, BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' void glColor4ubVertex2fvSUN (const GLubyte *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glColor4ubVertex2fvSUN (BYREF c AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glColor4ubVertex3fSUN (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glColor4ubVertex3fSUN (BYVAL r AS BYTE, BYVAL g AS BYTE, BYVAL b AS BYTE, BYVAL a AS BYTE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glColor4ubVertex3fvSUN (const GLubyte *, const GLfloat *);
' typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glColor4ubVertex3fvSUN (BYREF c AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glColor3fVertex3fSUN (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glColor3fVertex3fSUN (BYVAL r AS SINGLE, BYVAL g AS SINGLE, BYVAL b AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glColor3fVertex3fvSUN (const GLfloat *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glColor3fVertex3fvSUN (BYREF c AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glNormal3fVertex3fSUN (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glNormal3fVertex3fSUN (BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glNormal3fVertex3fvSUN (const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glNormal3fVertex3fvSUN (BYREF c AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glColor4fNormal3fVertex3fSUN (GLfloat r, GLfloat g, GLfloat b, GLfloat a,
' GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glColor4fNormal3fVertex3fSUN (BYVAL r AS SINGLE, BYVAL g AS  SINGLE, BYVAL b AS SINGLE, BYVAL a AS SINGLE, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glColor4fNormal3fVertex3fvSUN (const GLfloat *c, const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glColor4fNormal3fVertex3fvSUN (BYREF c AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord2fVertex3fSUN (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glTexCoord2fVertex3fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glTexCoord2fVertex3fvSUN (const GLfloat *tc, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord2fVertex3fvSUN (BYREF tc AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord4fVertex4fSUN (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x,
' GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glTexCoord4fVertex4fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL p AS SINGLE, BYVAL q AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glTexCoord4fVertex4fvSUN (const GLfloat *tc, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord4fVertex4fvSUN (BYREF tc AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord2fColor4ubVertex3fSUN (GLfloat s, GLfloat t, GLubyte r, GLubyte g,
' GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glTexCoord2fColor4ubVertex3fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL r AS BYTE, BYVAL g AS BYTE, BYVAL b AS BYTE, BYVAL a AS BYTE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glTexCoord2fColor4ubVertex3fvSUN (const GLfloat *tc, const GLubyte *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord2fColor4ubVertex3fvSUN (BYREF tc AS SINGLE, BYREF c AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord2fColor3fVertex3fSUN (GLfloat s, GLfloat t, GLfloat r, GLfloat g,
' GLfloat b, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glTexCoord2fColor3fVertex3fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL p AS SINGLE, BYVAL q AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glTexCoord2fColor3fVertex3fvSUN (const GLfloat *tc, const GLfloat *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord2fColor3fVertex3fvSUN (BYREF tc AS SINGLE, BYREF c AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord2fNormal3fVertex3fSUN (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny,
' GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glTexCoord2fNormal3fVertex3fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glTexCoord2fNormal3fVertex3fvSUN (const GLfloat *tc, const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord2fNormal3fVertex3fvSUN (BYREF tc AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord2fColor4fNormal3fVertex3fSUN (GLfloat s, GLfloat t, GLfloat r, GLfloat g,
' GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glTexCoord2fColor4fNormal3fVertex3fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL r AS SINGLE, BYVAL g AS SINGLE, BYVAL b AS SINGLE, BYVAL a AS SINGLE, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, _
   BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glTexCoord2fColor4fNormal3fVertex3fvSUN (const GLfloat *tc, const GLfloat *c,
' const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord2fColor4fNormal3fVertex3fvSUN (BYREF tc AS SINGLE, BYREF c AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glTexCoord4fColor4fNormal3fVertex4fSUN (GLfloat s, GLfloat t, GLfloat p, GLfloat q,
' GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz,
' GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glTexCoord4fColor4fNormal3fVertex4fSUN (BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL p AS SINGLE, BYVAL q AS SINGLE, BYVAL r AS SINGLE, BYVAL g AS SINGLE, BYVAL b AS SINGLE, BYVAL a AS SINGLE, _
   BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glTexCoord4fColor4fNormal3fVertex4fvSUN (const GLfloat *tc, const GLfloat *c,
' const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glTexCoord4fColor4fNormal3fVertex4fvSUN (BYREF tc AS SINGLE, BYREF c AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiVertex3fSUN (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiVertex3fSUN (BYVAL rc AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiVertex3fvSUN (const GLuint *rc, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiVertex3fvSUN (BYREF rc AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiColor4ubVertex3fSUN (GLuint rc, GLubyte r, GLubyte g, GLubyte b,
' GLubyte a, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiColor4ubVertex3fSUN (BYVAL rc AS DWORD, BYVAL r AS BYTE, BYVAL g AS BYTE, BYVAL b AS BYTE, BYVAL a AS BYTE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiColor4ubVertex3fvSUN (const GLuint *rc, const GLubyte *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiColor4ubVertex3fvSUN (BYREF rc AS DWORD, BYREF c AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiColor3fVertex3fSUN (GLuint rc, GLfloat r, GLfloat g, GLfloat b,
' GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiColor3fVertex3fSUN (BYVAL rc AS DWORD, BYVAL r AS SINGLE, BYVAL g AS SINGLE, BYVAL b AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiColor3fVertex3fvSUN (const GLuint *rc, const GLfloat *c, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiColor3fVertex3fvSUN (BYREF rc AS DWORD, BYREF c AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiNormal3fVertex3fSUN (GLuint rc, GLfloat nx, GLfloat ny,
' GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiNormal3fVertex3fSUN (BYVAL rc AS DWORD, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiNormal3fVertex3fvSUN (const GLuint *rc, const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiNormal3fVertex3fvSUN (BYREF rc AS DWORD, BYREF c AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiColor4fNormal3fVertex3fSUN (GLuint rc, GLfloat r, GLfloat g,
' GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiColor4fNormal3fVertex3fSUN (BYVAL rc AS DWORD, BYVAL r AS SINGLE, BYVAL g AS SINGLE, BYVAL b AS SINGLE, BYVAL a AS SINGLE, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, _
   BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiColor4fNormal3fVertex3fvSUN (const GLuint *rc, const GLfloat *c,
' const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiColor4fNormal3fVertex3fvSUN (BYREF rc AS DWORD, BYREF c AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiTexCoord2fVertex3fSUN (GLuint rc, GLfloat s, GLfloat t,
' GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiTexCoord2fVertex3fSUN (BYVAL rc AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiTexCoord2fVertex3fvSUN (const GLuint *rc, const GLfloat *tc, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiTexCoord2fVertex3fvSUN (BYREF rc AS DWORD, BYREF c AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN (GLuint rc, GLfloat s, GLfloat t,
' GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN (BYVAL rc AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, _
   BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN (const GLuint *rc,
' const GLfloat *tc, const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN (BYREF rc AS DWORD, BYREF c AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN (GLuint rc, GLfloat s,
' GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny,
' GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN (BYVAL rc AS DWORD, BYVAL s AS SINGLE, BYVAL t AS SINGLE, BYVAL r AS SINGLE, BYVAL g AS SINGLE, BYVAL b AS SINGLE, BYVAL a AS SINGLE, _
   BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN (const GLuint *rc,
' const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
' ========================================================================================
DECLARE SUB glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN (BYREF rc AS DWORD, BYREF tc AS SINGLE, BYREF c AS SINGLE, BYREF n AS SINGLE, BYREF v AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_func_separate)
'%GL_EXT_blend_func_separate = 1

' ========================================================================================
' void glBlendFuncSeparateEXT (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
' ========================================================================================
DECLARE SUB glBlendFuncSeparateEXT (BYVAL sfactorRGB AS DWORD, BYVAL dfactorRGB AS DWORD, BYVAL sfactorAlpha AS DWORD, BYVAL dfactorAlpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_INGR_blend_func_separate)
'%GL_INGR_blend_func_separate = 1

' ========================================================================================
' void glBlendFuncSeparateINGR (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
' ========================================================================================
DECLARE SUB glBlendFuncSeparateINGR (BYVAL sfactorRGB AS DWORD, BYVAL dfactorRGB AS DWORD, BYVAL sfactorAlpha AS DWORD, BYVAL dfactorAlpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_INGR_color_clamp)
'%GL_INGR_color_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_INGR_interlace_read)
'%GL_INGR_interlace_read = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_stencil_wrap)
'%GL_EXT_stencil_wrap = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_422_pixels)
'%GL_EXT_422_pixels = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texgen_reflection)
'%GL_NV_texgen_reflection = 1
'#ENDIF

'#IF NOT %DEF(%GL_SUN_convolution_border_modes)
'%GL_SUN_convolution_border_modes = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_env_add)
'%GL_EXT_texture_env_add = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_lod_bias)
'%GL_EXT_texture_lod_bias = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_filter_anisotropic)
'%GL_EXT_texture_filter_anisotropic = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_vertex_weighting)
'%GL_EXT_vertex_weighting = 1

' ========================================================================================
' void glVertexWeightfEXT (GLfloat weight);
' ========================================================================================
DECLARE SUB glVertexWeightfEXT (BYVAL weight AS SINGLE)

' ========================================================================================
' void glVertexWeightfvEXT (const GLfloat *weight);
' ========================================================================================
DECLARE SUB glVertexWeightfvEXT (BYREF weight AS SINGLE)

' ========================================================================================
' void glVertexWeightPointerEXT (GLsizei size, GLenum type, GLint stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexWeightPointerEXT (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_light_max_exponent)
'%GL_NV_light_max_exponent = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_array_range)
'%GL_NV_vertex_array_range = 1

' ========================================================================================
' void glFlushVertexArrayRangeNV (void);
' ========================================================================================
DECLARE SUB glFlushVertexArrayRangeNV

' ========================================================================================
' void glVertexArrayRangeNV (GLsizei length, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexArrayRangeNV (BYVAL nLength AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_register_combiners)
'%GL_NV_register_combiners = 1

' ========================================================================================
' void glCombinerParameterfvNV (GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glCombinerParameterfvNV (BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glCombinerParameterfNV (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glCombinerParameterfNV (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glCombinerParameterivNV (GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glCombinerParameterivNV (BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glCombinerParameteriNV (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glCombinerParameteriNV (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glCombinerInputNV (GLenum stage, GLenum portion, GLenum variable, GLenum input,
' GLenum mapping, GLenum componentUsage);
' ========================================================================================
DECLARE SUB glCombinerInputNV (BYVAL dwStage AS DWORD, BYVAL dwPortion AS DWORD, BYVAL dwVariable AS DWORD, BYVAL dwInput AS DWORD, BYVAL dwMapping AS DWORD, BYVAL dwComponentUsage AS DWORD)

' ========================================================================================
' void glCombinerOutputNV (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput,
' GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct,
' GLboolean cdDotProduct, GLboolean muxSum);
' ========================================================================================
DECLARE SUB glCombinerOutputNV (BYVAL dwStage AS DWORD, BYVAL dwPortion AS DWORD, BYVAL abOutput AS DWORD, BYVAL cdOutput AS DWORD, BYVAL sumOutput AS DWORD, BYVAL dwScale AS DWORD, BYVAL dwBias AS DWORD, _
   BYVAL abDotProduct AS BYTE, BYVAL cdDotProduct AS BYTE, BYVAL muxSum AS BYTE)

' ========================================================================================
' void glFinalCombinerInputNV (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
' ========================================================================================
DECLARE SUB glFinalCombinerInputNV (BYVAL dwVariable AS DWORD, BYVAL dwInput AS DWORD, BYVAL dwMapping AS DWORD, BYVAL dwComponentUsage AS DWORD)

' ========================================================================================
' void glGetCombinerInputParameterfvNV (GLenum stage, GLenum portion, GLenum variable,
' GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetCombinerInputParameterfvNV (BYVAL dwStage AS DWORD, BYVAL dwPortion AS DWORD, BYVAL dwVariable AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetCombinerInputParameterivNV (GLenum stage, GLenum portion, GLenum variable,
' GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetCombinerInputParameterivNV (BYVAL dwStage AS DWORD, BYVAL dwPortion AS DWORD, BYVAL dwVariable AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetCombinerOutputParameterfvNV (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetCombinerOutputParameterfvNV (BYVAL dwStage AS DWORD, BYVAL dwPortion AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetCombinerOutputParameterivNV (GLenum stage, GLenum portion, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetCombinerOutputParameterivNV (BYVAL dwStage AS DWORD, BYVAL dwPortion AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetFinalCombinerInputParameterfvNV (GLenum variable, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetFinalCombinerInputParameterfvNV (BYVAL dwStage AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetFinalCombinerInputParameterivNV (GLenum variable, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFinalCombinerInputParameterivNV (BYVAL dwStage AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_NV_fog_distance)
'%GL_NV_fog_distance = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texgen_emboss)
'%GL_NV_texgen_emboss = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_blend_square)
'%GL_NV_blend_square = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_env_combine4)
'%GL_NV_texture_env_combine4 = 1
'#ENDIF

'#IF NOT %DEF(%GL_MESA_resize_buffers)
'%GL_MESA_resize_buffers = 1

' ========================================================================================
' GLAPI void APIENTRY glResizeBuffersMESA (void);
' typedef void (APIENTRYP PFNGLRESIZEBUFFERSMESAPROC) (void);
' ========================================================================================
DECLARE SUB glResizeBuffersMESA

'#ENDIF

'#IF NOT %DEF(%GL_MESA_window_pos)
'%GL_MESA_window_pos = 1

' ========================================================================================
' void glWindowPos2dMESA (GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glWindowPos2dMESA (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void glWindowPos2dvMESA (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos2dvMESA (BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glWindowPos2fMESA (GLfloat, GLfloat);
' typedef void (APIENTRYP PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glWindowPos2fMESA (BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glWindowPos2fvMESA (const GLfloat *);
' typedef void (APIENTRYP PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos2fvMESA (BYREF v AS SINGLE)

' ========================================================================================
' void glWindowPos2iMESA (GLint x, GLint y);
' ========================================================================================
DECLARE SUB glWindowPos2iMESA (BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' void glWindowPos2ivMESA (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos2ivMESA (BYREF v AS LONG)

' ========================================================================================
' void glWindowPos2sMESA (GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glWindowPos2sMESA (BYVAL x AS INTEGER, BYVAL y AS INTEGER)

' ========================================================================================
' void glWindowPos2svMESA (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos2svMESA (BYREF v AS INTEGER)

' ========================================================================================
' void glWindowPos3dMESA (GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glWindowPos3dMESA (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glWindowPos3dvMESA (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos3dvMESA (BYREF v AS DOUBLE)

' ========================================================================================
' void glWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glWindowPos3fMESA (BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glWindowPos3fvMESA (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos3fvMESA (BYREF v AS SINGLE)

' ========================================================================================
' void glWindowPos3iMESA (GLint x, GLint y, GLint z);
' ========================================================================================
DECLARE SUB glWindowPos3iMESA (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' void glWindowPos3ivMESA (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos3ivMESA (BYREF v AS LONG)

' ========================================================================================
' void glWindowPos3sMESA (GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glWindowPos3sMESA (BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER)

' ========================================================================================
' void glWindowPos3svMESA (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos3svMESA (BYREF v AS INTEGER)

' ========================================================================================
' void glWindowPos4dMESA (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glWindowPos4dMESA (BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glWindowPos4dvMESA (const GLdouble *v);
' ========================================================================================
DECLARE SUB glWindowPos4dvMESA (BYREF v AS DOUBLE)

' ========================================================================================
' void glWindowPos4fMESA (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glWindowPos4fMESA (BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glWindowPos4fvMESA (const GLfloat *v);
' ========================================================================================
DECLARE SUB glWindowPos4fvMESA (BYREF v AS SINGLE)

' ========================================================================================
' void glWindowPos4iMESA (GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glWindowPos4iMESA (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glWindowPos4ivMESA (const GLint *v);
' ========================================================================================
DECLARE SUB glWindowPos4ivMESA (BYREF v AS LONG)

' ========================================================================================
' void glWindowPos4sMESA (GLshort x, GLshort y, GLshort z, GLshort w);
' ========================================================================================
DECLARE SUB glWindowPos4sMESA (BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER, BYVAL w AS INTEGER)

' ========================================================================================
' void glWindowPos4svMESA (const GLshort *v);
' ========================================================================================
DECLARE SUB glWindowPos4svMESA (BYREF v AS INTEGER)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_compression_s3tc)
'%GL_EXT_texture_compression_s3tc = 1
'#ENDIF

'#IF NOT %DEF(%GL_IBM_cull_vertex)
'%GL_IBM_cull_vertex = 1
'#ENDIF

'#IF NOT %DEF(%GL_IBM_multimode_draw_arrays)
'%GL_IBM_multimode_draw_arrays = 1

' ========================================================================================
' void glMultiModeDrawArraysIBM (const GLenum *mode, const GLint *first,
' const GLsizei *count, GLsizei primcount, GLint modestride);
' ========================================================================================
DECLARE SUB glMultiModeDrawArraysIBM (BYREF dwMode AS DWORD, BYREF nFirst AS LONG, BYREF nCount AS LONG, BYVAL primcount AS LONG, BYVAL modestride AS LONG)

' ========================================================================================
' void glMultiModeDrawElementsIBM (const GLenum *mode, const GLsizei *count, GLenum type,
' const GLvoid* const *indices, GLsizei primcount, GLint modestride);
' ========================================================================================
DECLARE SUB glMultiModeDrawElementsIBM (BYREF dwMode AS DWORD, BYREF nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL primcount AS LONG, BYVAL modestride AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_IBM_vertex_array_lists)
'%GL_IBM_vertex_array_lists = 1

' ========================================================================================
' void glColorPointerListIBM (GLint size, GLenum type, GLint stride,
' const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glColorPointerListIBM (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glSecondaryColorPointerListIBM (GLint size, GLenum type, GLint stride,
' const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glSecondaryColorPointerListIBM (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glEdgeFlagPointerListIBM (GLint stride, const GLboolean* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glEdgeFlagPointerListIBM (BYVAL nStride AS LONG, BYREF pPointer AS BYTE, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glFogCoordPointerListIBM (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glFogCoordPointerListIBM (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glIndexPointerListIBM (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glIndexPointerListIBM (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glNormalPointerListIBM (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glNormalPointerListIBM (BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glTexCoordPointerListIBM (GLint size, GLenum type, GLint stride,
' const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glTexCoordPointerListIBM (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

' ========================================================================================
' void glVertexPointerListIBM (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
' ========================================================================================
DECLARE SUB glVertexPointerListIBM (BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD, BYVAL ptrstride AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_subsample)
'%GL_SGIX_subsample = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_ycrcba)
'%GL_SGIX_ycrcba = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_ycrcb_subsample)
'%GL_SGIX_ycrcb_subsample = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_depth_pass_instrument)
'%GL_SGIX_depth_pass_instrument = 1
'#ENDIF

'#IF NOT %DEF(%GL_3DFX_texture_compression_FXT1)
'%GL_3DFX_texture_compression_FXT1 = 1
'#ENDIF

'#IF NOT %DEF(%GL_3DFX_multisample)
'%GL_3DFX_multisample = 1
'#ENDIF

'#IF NOT %DEF(%GL_3DFX_tbuffer)
'%GL_3DFX_tbuffer = 1

' ========================================================================================
' void glTbufferMask3DFX (GLuint mask);
' ========================================================================================
DECLARE SUB glTbufferMask3DFX (BYVAL dwMask AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_multisample)
'%GL_EXT_multisample = 1

' ========================================================================================
' void glSampleMaskEXT (GLclampf value, GLboolean invert);
' ========================================================================================
DECLARE SUB glSampleMaskEXT (BYVAL value AS SINGLE, BYVAL invert AS BYTE)

' ========================================================================================
' void glSamplePatternEXT (GLenum pattern);
' ========================================================================================
DECLARE SUB glSamplePatternEXT (BYVAL pattern AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_vertex_preclip)
'%GL_SGIX_vertex_preclip = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_convolution_accuracy)
'%GL_SGIX_convolution_accuracy = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_resample)
'%GL_SGIX_resample = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_point_line_texgen)
'%GL_SGIS_point_line_texgen = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIS_texture_color_mask)
'%GL_SGIS_texture_color_mask = 1

' ========================================================================================
' void glTextureColorMaskSGIS (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
' ========================================================================================
DECLARE SUB glTextureColorMaskSGIS (BYVAL red AS BYTE, BYVAL green AS BYTE, BYVAL blue AS BYTE, BYVAL alpha AS BYTE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_igloo_interface)
'%GL_SGIX_igloo_interface = 1

' ========================================================================================
' void glIglooInterfaceSGIX (GLenum pname, const GLvoid *params);
' ========================================================================================
DECLARE SUB glIglooInterfaceSGIX (BYVAL pname AS DWORD, BYVAL params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_env_dot3)
'%GL_EXT_texture_env_dot3 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ATI_texture_mirror_once)
'%GL_ATI_texture_mirror_once = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_fence)
'%GL_NV_fence = 1

' ========================================================================================
' void glDeleteFencesNV (GLsizei n, const GLuint *fences);
' ========================================================================================
DECLARE SUB glDeleteFencesNV (BYVAL n AS LONG, BYREF fences AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGenFencesNV (GLsizei, GLuint *);
' typedef void (APIENTRYP PFNGLGENFENCESNVPROC) (GLsizei n, GLuint *fences);
' ========================================================================================
DECLARE SUB glGenFencesNV (BYVAL n AS LONG, BYREF fences AS DWORD)

' ========================================================================================
' GLboolean glIsFenceNV (GLuint fence);
' ========================================================================================
DECLARE FUNCTION glIsFenceNV (BYVAL fence AS DWORD) AS BYTE

' ========================================================================================
' GLboolean glTestFenceNV (GLuint fence);
' ========================================================================================
DECLARE FUNCTION glTestFenceNV (BYVAL fence AS DWORD) AS BYTE

' ========================================================================================
' void glGetFenceivNV (GLuint fence, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFenceivNV (BYVAL fence AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glFinishFenceNV (GLuint fence);
' ========================================================================================
DECLARE SUB glFinishFenceNV (BYVAL fence AS DWORD)

' ========================================================================================
' void glSetFenceNV (GLuint fence, GLenum condition);
' ========================================================================================
DECLARE SUB glSetFenceNV (BYVAL fence AS DWORD, BYVAL dwcondition AS DWORD)

'#ENDIF

#IF NOT %DEF(%GL_IBM_static_data)
%GL_IBM_static_data = 1

' ========================================================================================
' GLAPI void APIENTRY glFlushStaticDataIBM (GLenum target);
' ========================================================================================
DECLARE SUB glFlushStaticDataIBM (BYVAL dwtarget AS DWORD)

#ENDIF

'#IF NOT %DEF(%GL_IBM_texture_mirrored_repeat)
'%GL_IBM_texture_mirrored_repeat = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_evaluators)
'%GL_NV_evaluators = 1

' ========================================================================================
' void glMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride,
' GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
' ========================================================================================
DECLARE SUB glMapControlPointsNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL ustride AS LONG, BYVAL vstride AS LONG, BYVAL uorder AS LONG, BYVAL vorder AS LONG, _
   BYVAL bPacked AS BYTE, BYVAL pPoints AS DWORD)

' ========================================================================================
' void glMapParameterivNV (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glMapParameterivNV (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glMapParameterfvNV (GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glMapParameterfvNV (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride,
' GLsizei vstride, GLboolean packed, GLvoid *points);
' ========================================================================================
DECLARE SUB glGetMapControlPointsNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL dwType AS DWORD, BYVAL ustride AS LONG, BYVAL vstride AS LONG, BYVAL bPacked AS BYTE, BYVAL pPoints AS DWORD)

' ========================================================================================
' void glGetMapParameterivNV (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMapParameterivNV (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMapParameterfvNV (GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMapParameterfvNV (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMapAttribParameterivNV (GLenum target, GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMapAttribParameterivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMapAttribParameterfvNV (GLenum target, GLuint index, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMapAttribParameterfvNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glEvalMapsNV (GLenum, GLenum);
' typedef void (APIENTRYP PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
' ========================================================================================
DECLARE SUB glEvalMapsNV (BYVAL dwTarget AS DWORD, BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_packed_depth_stencil)
'%GL_NV_packed_depth_stencil = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_register_combiners2)
'%GL_NV_register_combiners2 = 1

' ========================================================================================
' void glCombinerStageParameterfvNV (GLenum stage, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glCombinerStageParameterfvNV (BYVAL dwStage AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetCombinerStageParameterfvNV (GLenum stage, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetCombinerStageParameterfvNV (BYVAL dwStage AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_compression_vtc)
'%GL_NV_texture_compression_vtc = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_rectangle)
'%GL_NV_texture_rectangle = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_shader)
'%GL_NV_texture_shader = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_shader2)
'%GL_NV_texture_shader2 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_array_range2)
'%GL_NV_vertex_array_range2 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program)
'%GL_NV_vertex_program = 1

' ========================================================================================
' GLboolean glAreProgramsResidentNV (GLsizei n, const GLuint *programs, GLboolean *residences);
' ========================================================================================
DECLARE FUNCTION glAreProgramsResidentNV (BYVAL n AS LONG, BYREF programs AS DWORD, BYREF residences AS BYTE) AS BYTE

' ========================================================================================
' void glBindProgramNV (GLenum target, GLuint id);
' ========================================================================================
DECLARE SUB glBindProgramNV (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD)

' ========================================================================================
' void glDeleteProgramsNV (GLsizei n, const GLuint *programs);
' ========================================================================================
DECLARE SUB glDeleteProgramsNV (BYVAL n AS LONG, BYREF programs AS DWORD)

' ========================================================================================
' void glExecuteProgramNV (GLenum target, GLuint id, const GLfloat *params);
' ========================================================================================
DECLARE SUB glExecuteProgramNV (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGenProgramsNV (GLsizei n, GLuint *programs);
' ========================================================================================
DECLARE SUB glGenProgramsNV (BYVAL n AS LONG, BYREF programs AS DWORD)

' ========================================================================================
' void glGetProgramParameterdvNV (GLenum target, GLuint index, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetProgramParameterdvNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetProgramParameterfvNV (GLenum target, GLuint index, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetProgramParameterfvNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetProgramivNV (GLuint id, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramivNV (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetProgramStringNV (GLuint id, GLenum pname, GLubyte *program);
' ========================================================================================
DECLARE SUB glGetProgramStringNV (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF program AS BYTE)

' ========================================================================================
' void glGetTrackMatrixivNV (GLenum target, GLuint address, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetTrackMatrixivNV (BYVAL dwTarget AS DWORD, BYVAL dwAddress AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetVertexAttribdvNV (GLuint index, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribdvNV (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetVertexAttribfvNV (GLuint index, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribfvNV (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetVertexAttribivNV (GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribivNV (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetVertexAttribPointervNV (GLuint index, GLenum pname, GLvoid* *pointer);
' ========================================================================================
DECLARE SUB glGetVertexAttribPointervNV (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' GLboolean glIsProgramNV (GLuint id);
' ========================================================================================
DECLARE FUNCTION glIsProgramNV (BYVAL dwId AS DWORD) AS BYTE

' ========================================================================================
' void glLoadProgramNV (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
' ========================================================================================
DECLARE SUB glLoadProgramNV (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF program AS BYTE)

' ========================================================================================
' void glProgramParameter4dNV (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glProgramParameter4dNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glProgramParameter4fNV (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glProgramParameter4fNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glProgramParameter4fvNV (GLenum target, GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glProgramParameter4fvNV (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glProgramParameter4dvNV (GLenum target, GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glProgramParameter4dvNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glProgramParameters4dvNV (GLenum target, GLuint index, GLuint count, const GLdouble *v);
' ========================================================================================
DECLARE SUB glProgramParameters4dvNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL dwCount AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glProgramParameters4fvNV (GLenum target, GLuint index, GLuint count, const GLfloat *v);
' ========================================================================================
DECLARE SUB glProgramParameters4fvNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL dwCount AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glRequestResidentProgramsNV (GLsizei n, const GLuint *programs);
' ========================================================================================
DECLARE SUB glRequestResidentProgramsNV (BYVAL n AS LONG, BYREF programs AS DWORD)

' ========================================================================================
' void glTrackMatrixNV (GLenum target, GLuint address, GLenum matrix, GLenum transform);
' ========================================================================================
DECLARE SUB glTrackMatrixNV (BYVAL dwTarget AS DWORD, BYVAL dwAddress AS DWORD, BYVAL dwMatrix AS DWORD, BYVAL dwTransform AS DWORD)

' ========================================================================================
' void glVertexAttribPointerNV (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribPointerNV (BYVAL dwIndex AS DWORD, BYVAL fsize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glVertexAttrib1dNV (GLuint index, GLdouble x);
' ========================================================================================
DECLARE SUB glVertexAttrib1dNV (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE)

' ========================================================================================
' void glVertexAttrib1dvNV (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1dvNV (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib1fNV (GLuint index, GLfloat x);
' ========================================================================================
DECLARE SUB glVertexAttrib1fNV (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE)

' ========================================================================================
' void glVertexAttrib1fvNV (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1fvNV (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib1sNV (GLuint index, GLshort x);
' ========================================================================================
DECLARE SUB glVertexAttrib1sNV (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER)

' ========================================================================================
' void glVertexAttrib1svNV (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1svNV (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib2dNV (GLuint index, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glVertexAttrib2dNV (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void glVertexAttrib2dvNV (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2dvNV (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib2fNV (GLuint index, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glVertexAttrib2fNV (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' void glVertexAttrib2fvNV (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2fvNV (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib2sNV (GLuint index, GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glVertexAttrib2sNV (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER)

' ========================================================================================
' void glVertexAttrib2svNV (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2svNV (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib3dNV (GLuint index, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glVertexAttrib3dNV (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glVertexAttrib3dvNV (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3dvNV (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib3fNV (GLuint index, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glVertexAttrib3fNV (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glVertexAttrib3fvNV (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3fvNV (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib3sNV (GLuint index, GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glVertexAttrib3sNV (BYVAL dwIndex AS  DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER)

' ========================================================================================
' void glVertexAttrib3svNV (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3svNV (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib4dNV (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glVertexAttrib4dNV (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glVertexAttrib4dvNV (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4dvNV (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttrib4fNV (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glVertexAttrib4fNV (BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glVertexAttrib4fvNV (GLuint index, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4fvNV (BYVAL dwIndex AS DWORD, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttrib4sNV (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
' ========================================================================================
DECLARE SUB glVertexAttrib4sNV (BYVAL dwIndex AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER, BYVAL w AS INTEGER)

' ========================================================================================
' void glVertexAttrib4svNV (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4svNV (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttrib4ubNV (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
' ========================================================================================
DECLARE SUB glVertexAttrib4ubNV (BYVAL dwIndex AS DWORD, BYVAL x AS BYTE, BYVAL y AS BYTE, BYVAL z AS BYTE, BYVAL w AS BYTE)

' ========================================================================================
' void glVertexAttrib4ubvNV (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4ubvNV (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttribs1dvNV (GLuint index, GLsizei count, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribs1dvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttribs1fvNV (GLuint index, GLsizei count, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttribs1fvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttribs1svNV (GLuint index, GLsizei count, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttribs1svNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttribs2dvNV (GLuint index, GLsizei count, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribs2dvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttribs2fvNV (GLuint index, GLsizei count, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttribs2fvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttribs2svNV (GLuint index, GLsizei count, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttribs2svNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttribs3dvNV (GLuint index, GLsizei count, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribs3dvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttribs3fvNV (GLuint index, GLsizei count, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttribs3fvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttribs3svNV (GLuint index, GLsizei count, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttribs3svNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttribs4dvNV (GLuint index, GLsizei count, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribs4dvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS DOUBLE)

' ========================================================================================
' void glVertexAttribs4fvNV (GLuint index, GLsizei count, const GLfloat *v);
' ========================================================================================
DECLARE SUB glVertexAttribs4fvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS SINGLE)

' ========================================================================================
' void glVertexAttribs4svNV (GLuint index, GLsizei count, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttribs4svNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttribs4ubvNV (GLuint index, GLsizei count, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttribs4ubvNV (BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF v AS BYTE)

'#ENDIF

'#IF NOT %DEF(%GL_SGIX_texture_coordinate_clamp)
'%GL_SGIX_texture_coordinate_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_SGIX_scalebias_hint)
'%GL_SGIX_scalebias_hint = 1
'#ENDIF

'#IF NOT %DEF(%GL_OML_interlace)
'%GL_OML_interlace = 1
'#ENDIF

'#IF NOT %DEF(%GL_OML_subsample)
'%GL_OML_subsample = 1
'#ENDIF

'#IF NOT %DEF(%GL_OML_resample)
'%GL_OML_resample = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_copy_depth_to_color)
'%GL_NV_copy_depth_to_color = 1
'#ENDIF

'#IF NOT %DEF(%GL_ATI_envmap_bumpmap)
'%GL_ATI_envmap_bumpmap       = 1

' ========================================================================================
' void glTexBumpParameterivATI (GLenum pname, const GLint *param);
' ========================================================================================
DECLARE SUB glTexBumpParameterivATI (BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' void glTexBumpParameterfvATI (GLenum pname, const GLfloat *param);
' ========================================================================================
DECLARE SUB glTexBumpParameterfvATI (BYVAL pname AS DWORD, BYREF param AS SINGLE)

' ========================================================================================
' void glGetTexBumpParameterivATI (GLenum pname, GLint *param);
' ========================================================================================
DECLARE SUB glGetTexBumpParameterivATI (BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' void glGetTexBumpParameterfvATI (GLenum pname, GLfloat *param);
' ========================================================================================
DECLARE SUB glGetTexBumpParameterfvATI (BYVAL pname AS DWORD, BYREF param AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_fragment_shader)
'%GL_ATI_fragment_shader       = 1

' ========================================================================================
' GLuint glGenFragmentShadersATI (GLuint range);
' ========================================================================================
DECLARE FUNCTION glGenFragmentShadersATI (BYVAL dwRange AS DWORD) AS DWORD

' ========================================================================================
' void glBindFragmentShaderATI (GLuint id);
' ========================================================================================
DECLARE SUB glBindFragmentShaderATI (BYVAL dwId AS DWORD)

' ========================================================================================
' void glDeleteFragmentShaderATI (GLuint id);
' ========================================================================================
DECLARE SUB glDeleteFragmentShaderATI (BYVAL dwId AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glBeginFragmentShaderATI (void);
' typedef void (APIENTRYP PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
' ========================================================================================
DECLARE SUB glBeginFragmentShaderATI

' ========================================================================================
' void glEndFragmentShaderATI (void);
' ========================================================================================
DECLARE SUB glEndFragmentShaderATI

' ========================================================================================
' void glPassTexCoordATI (GLuint dst, GLuint coord, GLenum swizzle);
' ========================================================================================
DECLARE SUB glPassTexCoordATI (BYVAL dst AS DWORD, BYVAL dwCoord AS DWORD, BYVAL swizzle AS DWORD)

' ========================================================================================
' void glSampleMapATI (GLuint dst, GLuint interp, GLenum swizzle);
' ========================================================================================
DECLARE SUB glSampleMapATI (BYVAL dst AS DWORD, BYVAL interp AS DWORD, BYVAL swizzle AS DWORD)

' ========================================================================================
' void glColorFragmentOp1ATI (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod,
' GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
' ========================================================================================
DECLARE SUB glColorFragmentOp1ATI (BYVAL op AS DWORD, BYVAL dst AS DWORD, BYVAL dstMask AS DWORD, BYVAL dstMod AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg1Rep AS DWORD, BYVAL arg1Mod AS DWORD)

' ========================================================================================
' void glColorFragmentOp2ATI (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod,
' GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
' ========================================================================================
DECLARE SUB glColorFragmentOp2ATI (BYVAL op AS DWORD, BYVAL dst AS DWORD, BYVAL dstMask AS DWORD, BYVAL dstMod AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg1Rep AS DWORD, BYVAL arg1Mod AS DWORD, _
   BYVAL arg2 AS DWORD, BYVAL arg2Rep AS DWORD, BYVAL arg2Mod AS DWORD)

' ========================================================================================
' void glColorFragmentOp3ATI (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod,
' GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep,
' GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
' ========================================================================================
DECLARE SUB glColorFragmentOp3ATI (BYVAL op AS DWORD, BYVAL dst AS DWORD, BYVAL dstMask AS DWORD, BYVAL dstMod AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg1Rep AS DWORD, BYVAL arg1Mod AS DWORD, _
   BYVAL arg2 AS DWORD, BYVAL arg2Rep AS DWORD, BYVAL arg2Mod AS DWORD, BYVAL arg3 AS DWORD, BYVAL arg3Rep AS DWORD, BYVAL arg3Mod AS DWORD)

' ========================================================================================
' void glAlphaFragmentOp1ATI (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1,
' GLuint arg1Rep, GLuint arg1Mod);
' ========================================================================================
DECLARE SUB glAlphaFragmentOp1ATI (BYVAL op AS DWORD, BYVAL dst AS DWORD, BYVAL dstMod AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg1Rep AS DWORD, BYVAL arg1Mod AS DWORD)

' ========================================================================================
' void glAlphaFragmentOp2ATI (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1,
' GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
' ========================================================================================
DECLARE SUB glAlphaFragmentOp2ATI (BYVAL op AS DWORD, BYVAL dst AS DWORD, BYVAL dstMod AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg1Rep AS DWORD, BYVAL arg1Mod AS DWORD, BYVAL arg2 AS DWORD, _
   BYVAL arg2Rep AS DWORD, BYVAL arg2Mod AS DWORD)

' ========================================================================================
' void glAlphaFragmentOp3ATI (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1,
' GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod,
' GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
' ========================================================================================
DECLARE SUB glAlphaFragmentOp3ATI (BYVAL op AS DWORD, BYVAL dst AS DWORD, BYVAL dstMod AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg1Rep AS DWORD, BYVAL arg1Mod AS DWORD, BYVAL arg2 AS DWORD, _
   BYVAL arg2Rep AS DWORD, BYVAL arg2Mod AS DWORD, BYVAL arg3 AS DWORD, BYVAL arg3Rep AS DWORD, BYVAL arg3Mod AS DWORD)

' ========================================================================================
' void glSetFragmentShaderConstantATI (GLuint dst, const GLfloat *value);
' ========================================================================================
DECLARE SUB glSetFragmentShaderConstantATI (BYVAL dst AS DWORD, BYREF value AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_pn_triangles)
'%GL_ATI_pn_triangles = 1

' ========================================================================================
' void glPNTrianglesiATI (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glPNTrianglesiATI (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glPNTrianglesfATI (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glPNTrianglesfATI (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_vertex_array_object)
'%GL_ATI_vertex_array_object = 1

' ========================================================================================
' GLuint glNewObjectBufferATI (GLsizei size, const GLvoid *pointer, GLenum usage);
' ========================================================================================
DECLARE FUNCTION glNewObjectBufferATI (BYVAL nSize AS LONG, BYVAL pPointer AS DWORD, BYVAL dwUsage AS DWORD) AS DWORD

' ========================================================================================
' GLboolean glIsObjectBufferATI (GLuint buffer);
' ========================================================================================
DECLARE FUNCTION glIsObjectBufferATI (BYVAL buffer AS DWORD) AS BYTE

' ========================================================================================
' void glUpdateObjectBufferATI (GLuint buffer, GLuint offset, GLsizei size,
' const GLvoid *pointer, GLenum preserve);
' ========================================================================================
DECLARE SUB glUpdateObjectBufferATI (BYVAL dwBuffer AS DWORD, BYVAL dwOffset AS DWORD, BYVAL nSize AS LONG, BYVAL pPointer AS DWORD, BYVAL dwPreserve AS DWORD)

' ========================================================================================
' void glGetObjectBufferfvATI (GLuint buffer, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetObjectBufferfvATI (BYVAL dwBuffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetObjectBufferivATI (GLuint buffer, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetObjectBufferivATI (BYVAL dwBuffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glFreeObjectBufferATI (GLuint buffer);
' ========================================================================================
DECLARE SUB glFreeObjectBufferATI (BYVAL dwBuffer AS DWORD)

' ========================================================================================
' void glArrayObjectATI (GLenum array, GLint size, GLenum type, GLsizei stride,
' GLuint buffer, GLuint offset);
' ========================================================================================
DECLARE SUB glArrayObjectATI (BYVAL dwArray AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL dwBuffer AS DWORD, BYVAL dwOffset AS DWORD)

' ========================================================================================
' void glGetArrayObjectfvATI (GLenum array, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetArrayObjectfvATI (BYVAL dwArray AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetArrayObjectivATI (GLenum array, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetArrayObjectivATI (BYVAL dwArray AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glVariantArrayObjectATI (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
' ========================================================================================
DECLARE SUB glVariantArrayObjectATI (BYVAL dwId AS DWORD, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL dwBuffer AS DWORD, BYVAL dwOffset AS DWORD)

' ========================================================================================
' void glGetVariantArrayObjectfvATI (GLuint id, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetVariantArrayObjectfvATI (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetVariantArrayObjectivATI (GLuint id, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVariantArrayObjectivATI (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_vertex_shader)
'%GL_EXT_vertex_shader = 1

' ========================================================================================
' void glBeginVertexShaderEXT (void);
' ========================================================================================
DECLARE SUB glBeginVertexShaderEXT

' ========================================================================================
' void glEndVertexShaderEXT (void);
' ========================================================================================
DECLARE SUB glEndVertexShaderEXT

' ========================================================================================
' void glBindVertexShaderEXT (GLuint id);
' ========================================================================================
DECLARE SUB glBindVertexShaderEXT (BYVAL dwId AS DWORD)

' ========================================================================================
' GLuint glGenVertexShadersEXT (GLuint range);
' ========================================================================================
DECLARE FUNCTION glGenVertexShadersEXT (BYVAL dwRange AS DWORD) AS DWORD

' ========================================================================================
' void glDeleteVertexShaderEXT (GLuint id);
' ========================================================================================
DECLARE SUB glDeleteVertexShaderEXT (BYVAL dwId AS DWORD)

' ========================================================================================
' void glShaderOp1EXT (GLenum op, GLuint res, GLuint arg1);
' ========================================================================================
DECLARE SUB glShaderOp1EXT (BYVAL op AS DWORD, BYVAL dwRes AS DWORD, BYVAL arg1 AS DWORD)

' ========================================================================================
' void glShaderOp2EXT (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
' ========================================================================================
DECLARE SUB glShaderOp2EXT (BYVAL op AS DWORD, BYVAL dwRes AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg2 AS DWORD)

' ========================================================================================
' void glShaderOp3EXT (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
' ========================================================================================
DECLARE SUB glShaderOp3EXT (BYVAL op AS DWORD, BYVAL dwRes AS DWORD, BYVAL arg1 AS DWORD, BYVAL arg2 AS DWORD, BYVAL arg3 AS DWORD)

' ========================================================================================
' void glSwizzleEXT (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
' ========================================================================================
DECLARE SUB glSwizzleEXT (BYVAL dwRes AS DWORD, BYVAL dwIn AS DWORD, BYVAL outX AS DWORD, BYVAL outY AS DWORD, BYVAL outZ AS DWORD, BYVAL outW AS DWORD)

' ========================================================================================
' void glWriteMaskEXT (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
' ========================================================================================
DECLARE SUB glWriteMaskEXT (BYVAL dwRes AS DWORD, BYVAL dwIn AS DWORD, BYVAL outX AS DWORD, BYVAL outY AS DWORD, BYVAL outZ AS DWORD, BYVAL outW AS DWORD)

' ========================================================================================
' void glInsertComponentEXT (GLuint res, GLuint src, GLuint num);
' ========================================================================================
DECLARE SUB glInsertComponentEXT (BYVAL dwRes AS DWORD, BYVAL dwSrc AS DWORD, BYVAL dwNum AS DWORD)

' ========================================================================================
' void glExtractComponentEXT (GLuint res, GLuint src, GLuint num);
' ========================================================================================
DECLARE SUB glExtractComponentEXT (BYVAL dwRes AS DWORD, BYVAL dwSrc AS DWORD, BYVAL dwNum AS DWORD)

' ========================================================================================
' GLuint glGenSymbolsEXT (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
' ========================================================================================
DECLARE FUNCTION glGenSymbolsEXT (BYVAL dwDatatype AS DWORD, BYVAL dwStoragetype AS DWORD, BYVAL dwRange AS DWORD, BYVAL dwComponents AS DWORD) AS DWORD

' ========================================================================================
' void glSetInvariantEXT (GLuint id, GLenum type, const GLvoid *addr);
' ========================================================================================
DECLARE SUB glSetInvariantEXT (BYVAL dwId AS DWORD, BYVAL dwType AS DWORD, BYVAL paddr AS DWORD)

' ========================================================================================
' void glSetLocalConstantEXT (GLuint id, GLenum type, const GLvoid *addr);
' ========================================================================================
DECLARE SUB glSetLocalConstantEXT (BYVAL dwId AS DWORD, BYVAL dwType AS DWORD, BYVAL paddr AS DWORD)

' ========================================================================================
' void glVariantbvEXT (GLuint id, const GLbyte *addr);
' ========================================================================================
DECLARE SUB glVariantbvEXT (BYVAL dwIndex AS DWORD, BYREF paddr AS BYTE)

' ========================================================================================
' void glVariantsvEXT (GLuint id, const GLshort *addr);
' ========================================================================================
DECLARE SUB glVariantsvEXT (BYVAL dwId AS DWORD, BYREF paddr AS INTEGER)

' ========================================================================================
' void glVariantivEXT (GLuint id, const GLint *addr);
' ========================================================================================
DECLARE SUB glVariantivEXT (BYVAL dwId AS DWORD, BYREF paddr AS LONG)

' ========================================================================================
' void glVariantfvEXT (GLuint id, const GLfloat *addr);
' ========================================================================================
DECLARE SUB glVariantfvEXT (BYVAL dwId AS DWORD, BYREF paddr AS SINGLE)

' ========================================================================================
' void glVariantdvEXT (GLuint id, const GLdouble *addr);
' ========================================================================================
DECLARE SUB glVariantdvEXT (BYVAL dwId AS DWORD, BYREF paddr AS DOUBLE)

' ========================================================================================
' void glVariantubvEXT (GLuint id, const GLubyte *addr);
' ========================================================================================
DECLARE SUB glVariantubvEXT (BYVAL dwId AS DWORD, BYREF paddr AS BYTE)

' ========================================================================================
' void glVariantusvEXT (GLuint id, const GLushort *addr);
' ========================================================================================
DECLARE SUB glVariantusvEXT (BYVAL dwId AS DWORD, BYREF paddr AS WORD)

' ========================================================================================
' void glVariantuivEXT (GLuint id, const GLuint *addr);
' ========================================================================================
DECLARE SUB glVariantuivEXT (BYVAL dwId AS DWORD, BYREF paddr AS DWORD)

' ========================================================================================
' void glVariantPointerEXT (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
' ========================================================================================
DECLARE SUB glVariantPointerEXT (BYVAL dwId AS DWORD, BYVAL dwType AS DWORD, BYVAL nStride AS DWORD, BYVAL paddr AS DWORD)

' ========================================================================================
' void glEnableVariantClientStateEXT (GLuint id);
' ========================================================================================
DECLARE SUB glEnableVariantClientStateEXT (BYVAL dwId AS DWORD)

' ========================================================================================
' void glDisableVariantClientStateEXT (GLuint id);
' ========================================================================================
DECLARE SUB glDisableVariantClientStateEXT (BYVAL dwId AS DWORD)

' ========================================================================================
' GLuint glBindLightParameterEXT (GLenum light, GLenum value);
' ========================================================================================
DECLARE FUNCTION glBindLightParameterEXT (BYVAL dwLight AS DWORD, BYVAL dwValue AS DWORD) AS DWORD

' ========================================================================================
' GLuint glBindMaterialParameterEXT (GLenum face, GLenum value);
' ========================================================================================
DECLARE FUNCTION glBindMaterialParameterEXT (BYVAL dwFace AS DWORD, BYVAL dwValue AS DWORD) AS DWORD

' ========================================================================================
' GLuint glBindTexGenParameterEXT (GLenum unit, GLenum coord, GLenum value);
' ========================================================================================
DECLARE FUNCTION glBindTexGenParameterEXT (BYVAL dwUnit AS DWORD, BYVAL dwCoord AS DWORD, BYVAL dwValue AS DWORD) AS DWORD

' ========================================================================================
' GLuint glBindTextureUnitParameterEXT (GLenum unit, GLenum value);
' ========================================================================================
DECLARE FUNCTION glBindTextureUnitParameterEXT (BYVAL dwUnit AS DWORD, BYVAL dwValue AS DWORD) AS DWORD

' ========================================================================================
' GLuint glBindParameterEXT (GLenum value);
' ========================================================================================
DECLARE FUNCTION glBindParameterEXT (BYVAL dwValue AS DWORD) AS DWORD

' ========================================================================================
' GLboolean glIsVariantEnabledEXT (GLuint id, GLenum cap);
' ========================================================================================
DECLARE FUNCTION glIsVariantEnabledEXT (BYVAL dwId AS DWORD, BYVAL dwCap AS DWORD) AS BYTE

' ========================================================================================
' void glGetVariantBooleanvEXT (GLuint id, GLenum value, GLboolean *data);
' ========================================================================================
DECLARE SUB glGetVariantBooleanvEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS BYTE)

' ========================================================================================
' void glGetVariantIntegervEXT (GLuint id, GLenum value, GLint *data);
' ========================================================================================
DECLARE SUB glGetVariantIntegervEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS LONG)

' ========================================================================================
' void glGetVariantFloatvEXT (GLuint id, GLenum value, GLfloat *data);
' ========================================================================================
DECLARE SUB glGetVariantFloatvEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS SINGLE)

' ========================================================================================
' void glGetVariantPointervEXT (GLuint id, GLenum value, GLvoid* *data);
' ========================================================================================
DECLARE SUB glGetVariantPointervEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' void glGetInvariantBooleanvEXT (GLuint id, GLenum value, GLboolean *data);
' ========================================================================================
DECLARE SUB glGetInvariantBooleanvEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS BYTE)

' ========================================================================================
' void glGetInvariantIntegervEXT (GLuint id, GLenum value, GLint *data);
' ========================================================================================
DECLARE SUB glGetInvariantIntegervEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS LONG)

' ========================================================================================
' void glGetInvariantFloatvEXT (GLuint id, GLenum value, GLfloat *data);
' ========================================================================================
DECLARE SUB glGetInvariantFloatvEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS SINGLE)

' ========================================================================================
' void glGetLocalConstantBooleanvEXT (GLuint id, GLenum value, GLboolean *data);
' ========================================================================================
DECLARE SUB glGetLocalConstantBooleanvEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS BYTE)

' ========================================================================================
' void glGetLocalConstantIntegervEXT (GLuint id, GLenum value, GLint *data);
' ========================================================================================
DECLARE SUB glGetLocalConstantIntegervEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS LONG)

' ========================================================================================
' void glGetLocalConstantFloatvEXT (GLuint id, GLenum value, GLfloat *data);
' ========================================================================================
DECLARE SUB glGetLocalConstantFloatvEXT (BYVAL dwId AS DWORD, BYVAL dwValue AS DWORD, BYREF pData AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_vertex_streams)
'%GL_ATI_vertex_streams = 1

' ========================================================================================
' void glVertexStream1sATI (GLenum stream, GLshort x);
' ========================================================================================
DECLARE SUB glVertexStream1sATI (BYVAL dwStream AS DWORD, BYVAL x AS INTEGER)

' ========================================================================================
' void glVertexStream1svATI (GLenum stream, const GLshort *coords);
' ========================================================================================
DECLARE SUB glVertexStream1svATI (BYVAL dwStream AS DWORD, BYREF coords AS INTEGER)

' ========================================================================================
' void glVertexStream1iATI (GLenum stream, GLint x);
' ========================================================================================
DECLARE SUB glVertexStream1iATI (BYVAL dwStream AS DWORD, BYVAL x AS LONG)

' ========================================================================================
' void glVertexStream1ivATI (GLenum stream, const GLint *coords);
' ========================================================================================
DECLARE SUB glVertexStream1ivATI (BYVAL dwStream AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' void glVertexStream1fATI (GLenum stream, GLfloat x);
' ========================================================================================
DECLARE SUB glVertexStream1fATI (BYVAL dwStream AS DWORD, BYVAL x AS SINGLE)

' ========================================================================================
' void glVertexStream1fvATI (GLenum stream, const GLfloat *coords);
' ========================================================================================
DECLARE SUB glVertexStream1fvATI (BYVAL dwStream AS DWORD, BYREF coords AS SINGLE)

' ========================================================================================
' void glVertexStream1dATI (GLenum stream, GLdouble x);
' ========================================================================================
DECLARE SUB glVertexStream1dATI (BYVAL dwStream AS DWORD, BYVAL x AS DOUBLE)

' ========================================================================================
' void glVertexStream1dvATI (GLenum stream, const GLdouble *coords);
' ========================================================================================
DECLARE SUB glVertexStream1dvATI (BYVAL dwStream AS DWORD, BYREF coords AS DOUBLE)

' ========================================================================================
' void glVertexStream2sATI (GLenum stream, GLshort x, GLshort y);
' ========================================================================================
DECLARE SUB glVertexStream2sATI (BYVAL dwStream AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER)

' ========================================================================================
' void glVertexStream2svATI (GLenum stream, const GLshort *coords);
' ========================================================================================
DECLARE SUB glVertexStream2svATI (BYVAL dwStream AS DWORD, BYREF coords AS INTEGER)

' ========================================================================================
' void glVertexStream2iATI (GLenum stream, GLint x, GLint y);
' ========================================================================================
DECLARE SUB glVertexStream2iATI (BYVAL dwStream AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' void glVertexStream2ivATI (GLenum stream, const GLint *coords);
' ========================================================================================
DECLARE SUB glVertexStream2ivATI (BYVAL dwStream AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' void glVertexStream2fATI (GLenum stream, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE SUB glVertexStream2fATI (BYVAL dwStream AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE)

' ========================================================================================
' void glVertexStream2fvATI (GLenum stream, const GLfloat *coords);
' ========================================================================================
DECLARE SUB glVertexStream2fvATI (BYVAL dwStream AS DWORD, BYREF coords AS SINGLE)

' ========================================================================================
' void glVertexStream2dATI (GLenum stream, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glVertexStream2dATI (BYVAL dwStream AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void glVertexStream2dvATI (GLenum stream, const GLdouble *coords);
' ========================================================================================
DECLARE SUB glVertexStream2dvATI (BYVAL dwStream AS DWORD, BYREF coords AS DOUBLE)

' ========================================================================================
' void glVertexStream3sATI (GLenum stream, GLshort x, GLshort y, GLshort z);
' ========================================================================================
DECLARE SUB glVertexStream3sATI (BYVAL dwStream AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER)

' ========================================================================================
' void glVertexStream3svATI (GLenum stream, const GLshort *coords);
' ========================================================================================
DECLARE SUB glVertexStream3svATI (BYVAL dwStream AS DWORD, BYREF coords AS INTEGER)

' ========================================================================================
' void glVertexStream3iATI (GLenum stream, GLint x, GLint y, GLint z);
' ========================================================================================
DECLARE SUB glVertexStream3iATI (BYVAL dwStream AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' void glVertexStream3ivATI (GLenum stream, const GLint *coords);
' ========================================================================================
DECLARE SUB glVertexStream3ivATI (BYVAL dwStream AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' void glVertexStream3fATI (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glVertexStream3fATI (BYVAL dwStream AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glVertexStream3fvATI (GLenum stream, const GLfloat *coords);
' ========================================================================================
DECLARE SUB glVertexStream3fvATI (BYVAL dwStream AS DWORD, BYREF coords AS SINGLE)

' ========================================================================================
' void glVertexStream3dATI (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glVertexStream3dATI (BYVAL dwStream AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glVertexStream3dvATI (GLenum stream, const GLdouble *coords);
' ========================================================================================
DECLARE SUB glVertexStream3dvATI (BYVAL dwStream AS DWORD, BYREF coords AS DOUBLE)

' ========================================================================================
' void glVertexStream4sATI (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
' ========================================================================================
DECLARE SUB glVertexStream4sATI (BYVAL dwStream AS DWORD, BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL z AS INTEGER, BYVAL w AS INTEGER)

' ========================================================================================
' void glVertexStream4svATI (GLenum stream, const GLshort *coords);
' ========================================================================================
DECLARE SUB glVertexStream4svATI (BYVAL dwStream AS DWORD, BYREF coords AS INTEGER)

' ========================================================================================
' void glVertexStream4iATI (GLenum stream, GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glVertexStream4iATI (BYVAL dwStream AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glVertexStream4ivATI (GLenum stream, const GLint *coords);
' ========================================================================================
DECLARE SUB glVertexStream4ivATI (BYVAL dwStream AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' void glVertexStream4fATI (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glVertexStream4fATI (BYVAL dwStream AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glVertexStream4fvATI (GLenum stream, const GLfloat *coords);
' ========================================================================================
DECLARE SUB glVertexStream4fvATI (BYVAL dwStream AS DWORD, BYREF coords AS SINGLE)

' ========================================================================================
' void glVertexStream4dATI (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glVertexStream4dATI (BYVAL dwStream AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glVertexStream4dvATI (GLenum stream, const GLdouble *coords);
' ========================================================================================
DECLARE SUB glVertexStream4dvATI (BYVAL dwStream AS DWORD, BYREF coords AS DOUBLE)

' ========================================================================================
' void glNormalStream3bATI (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
' ========================================================================================
DECLARE SUB glNormalStream3bATI (BYVAL dwStream AS DWORD, BYVAL nx AS BYTE, BYVAL ny AS BYTE, BYVAL nz AS BYTE)

' ========================================================================================
' void glNormalStream3bvATI (GLenum stream, const GLbyte *coords);
' ========================================================================================
DECLARE SUB glNormalStream3bvATI (BYVAL dwStream AS DWORD, BYREF coords AS BYTE)

' ========================================================================================
' void glNormalStream3sATI (GLenum stream, GLshort nx, GLshort ny, GLshort nz);
' ========================================================================================
DECLARE SUB glNormalStream3sATI (BYVAL dwStream AS DWORD, BYVAL nx AS INTEGER, BYVAL ny AS INTEGER, BYVAL nz AS INTEGER)

' ========================================================================================
' void glNormalStream3svATI (GLenum stream, const GLshort *coords);
' ========================================================================================
DECLARE SUB glNormalStream3svATI (BYVAL dwStream AS DWORD, BYREF coords AS INTEGER)

' ========================================================================================
' void glNormalStream3iATI (GLenum stream, GLint nx, GLint ny, GLint nz);
' ========================================================================================
DECLARE SUB glNormalStream3iATI (BYVAL dwStream AS DWORD, BYVAL nx AS LONG, BYVAL ny AS LONG, BYVAL nz AS LONG)

' ========================================================================================
' void glNormalStream3ivATI (GLenum stream, const GLint *coords);
' ========================================================================================
DECLARE SUB glNormalStream3ivATI (BYVAL dwStream AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' void glNormalStream3fATI (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
' ========================================================================================
DECLARE SUB glNormalStream3fATI (BYVAL dwStream AS DWORD, BYVAL nx AS SINGLE, BYVAL ny AS SINGLE, BYVAL nz AS SINGLE)

' ========================================================================================
' void glNormalStream3fvATI (GLenum stream, const GLfloat *coords);
' ========================================================================================
DECLARE SUB glNormalStream3fvATI (BYVAL dwStream AS DWORD, BYREF coords AS SINGLE)

' ========================================================================================
' void glNormalStream3dATI (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
' ========================================================================================
DECLARE SUB glNormalStream3dATI (BYVAL dwStream AS DWORD, BYVAL nx AS DOUBLE, BYVAL ny AS DOUBLE, BYVAL nz AS DOUBLE)

' ========================================================================================
' void glNormalStream3dvATI (GLenum stream, const GLdouble *coords);
' ========================================================================================
DECLARE SUB glNormalStream3dvATI (BYVAL dwStream AS DWORD, BYREF coords AS DOUBLE)

' ========================================================================================
' void glClientActiveVertexStreamATI (GLenum stream);
' ========================================================================================
DECLARE SUB glClientActiveVertexStreamATI (BYVAL dwStream AS DWORD)

' ========================================================================================
' void glVertexBlendEnviATI (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glVertexBlendEnviATI (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glVertexBlendEnvfATI (GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glVertexBlendEnvfATI (BYVAL pname AS DWORD, BYVAL param AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_element_array)
'%GL_ATI_element_array = 1

' ========================================================================================
' void glElementPointerATI (GLenum type, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glElementPointerATI (BYVAL dwType AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glDrawElementArrayATI (GLenum mode, GLsizei count);
' ========================================================================================
DECLARE SUB glDrawElementArrayATI (BYVAL dwMode AS DWORD, BYVAL nCount AS LONG)

' ========================================================================================
' void glDrawRangeElementArrayATI (GLenum mode, GLuint start, GLuint end, GLsizei count);
' ========================================================================================
DECLARE SUB glDrawRangeElementArrayATI (BYVAL dwMode AS DWORD, BYVAL dwStart AS DWORD, BYVAL dwEnd AS DWORD, BYVAL nCount AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SUN_mesh_array)
'%GL_SUN_mesh_array = 1

' ========================================================================================
' void glDrawMeshArraysSUN (GLenum mode, GLint first, GLsizei count, GLsizei width);
' ========================================================================================
DECLARE SUB glDrawMeshArraysSUN (BYVAL dwMode AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS LONG, BYVAL nWidth AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_SUN_slice_accum)
'%GL_SUN_slice_accum = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_multisample_filter_hint)
'%GL_NV_multisample_filter_hint = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_depth_clamp)
'%GL_NV_depth_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_occlusion_query)
'%GL_NV_occlusion_query = 1

' ========================================================================================
' void glGenOcclusionQueriesNV (GLsizei n, GLuint *ids);
' ========================================================================================
DECLARE SUB glGenOcclusionQueriesNV (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' void glDeleteOcclusionQueriesNV (GLsizei n, const GLuint *ids);
' ========================================================================================
DECLARE SUB glDeleteOcclusionQueriesNV (BYVAL n AS LONG, BYREF ids AS DWORD)

' ========================================================================================
' GLboolean glIsOcclusionQueryNV (GLuint id);
' ========================================================================================
DECLARE FUNCTION glIsOcclusionQueryNV (BYVAL dwId AS DWORD) AS BYTE

' ========================================================================================
' void glBeginOcclusionQueryNV (GLuint id)
' ========================================================================================
DECLARE SUB glBeginOcclusionQueryNV (BYVAL dwId AS DWORD)

' ========================================================================================
' void glEndOcclusionQueryNV (void);
' ========================================================================================
DECLARE SUB glEndOcclusionQueryNV

' ========================================================================================
' void glGetOcclusionQueryivNV (GLuint id, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetOcclusionQueryivNV (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetOcclusionQueryuivNV (GLuint id, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetOcclusionQueryuivNV (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_point_sprite)
'%GL_NV_point_sprite = 1

' ========================================================================================
' void glPointParameteriNV (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glPointParameteriNV (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glPointParameterivNV (GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glPointParameterivNV (BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_shader3)
'%GL_NV_texture_shader3 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program1_1)
'%GL_NV_vertex_program1_1 = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_shadow_funcs)
'%GL_EXT_shadow_funcs = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_stencil_two_side)
'%GL_EXT_stencil_two_side = 1

' ========================================================================================
' GLAPI void APIENTRY glActiveStencilFaceEXT (GLenum);
' typedef void (APIENTRYP PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
' ========================================================================================
DECLARE SUB glActiveStencilFaceEXT (BYVAL dwFace AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_text_fragment_shader)
'%GL_ATI_text_fragment_shader = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_client_storage)
'%GL_APPLE_client_storage = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_element_array)
'%GL_APPLE_element_array = 1

' ========================================================================================
' void glElementPointerAPPLE (GLenum type, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glElementPointerAPPLE (BYVAL dwType AS DWORD, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glDrawElementArrayAPPLE (GLenum mode, GLint first, GLsizei count);
' ========================================================================================
DECLARE SUB glDrawElementArrayAPPLE (BYVAL dwMode AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS LONG)

' ========================================================================================
' void glDrawRangeElementArrayAPPLE (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
' ========================================================================================
DECLARE SUB glDrawRangeElementArrayAPPLE (BYVAL dwMode AS DWORD, BYVAL dwStart AS DWORD, BYVAL dwEnd AS DWORD, BYVAL nFirst AS LONG, BYVAL nCount AS LONG)

' ========================================================================================
' void glMultiDrawElementArrayAPPLE (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
' ========================================================================================
DECLARE SUB glMultiDrawElementArrayAPPLE (BYVAL dwMode AS DWORD, BYREF nFirst AS LONG, BYREF nCount AS LONG, BYVAL primcount AS LONG)

' ========================================================================================
' void glMultiDrawRangeElementArrayAPPLE (GLenum mode, GLuint start, GLuint end,
' const GLint *first, const GLsizei *count, GLsizei primcount);
' ========================================================================================
DECLARE SUB glMultiDrawRangeElementArrayAPPLE (BYVAL dwMode AS DWORD, BYVAL dwStart AS DWORD, BYVAL dwEnd AS DWORD, BYREF nFirst AS LONG, BYREF nCount AS LONG, BYVAL primcount AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_fence)
'%GL_APPLE_fence = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glGenFencesAPPLE (GLsizei n, GLuint *fences);
' ========================================================================================
DECLARE SUB glGenFencesAPPLE (BYVAL n AS LONG, BYREF fences AS DWORD)

' ========================================================================================
' void glDeleteFencesAPPLE (GLsizei n, const GLuint *fences);
' ========================================================================================
DECLARE SUB glDeleteFencesAPPLE (BYVAL n AS LONG, BYREF fences AS DWORD)

' ========================================================================================
' void glSetFenceAPPLE (GLuint fence);
' ========================================================================================
DECLARE SUB glSetFenceAPPLE (BYVAL fence AS DWORD)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsFenceAPPLE (GLuint);
' typedef GLboolean (APIENTRYP PFNGLISFENCEAPPLEPROC) (GLuint fence);
' ========================================================================================
DECLARE FUNCTION glIsFenceAPPLE (BYVAL fence AS DWORD) AS BYTE

' ========================================================================================
' GLboolean glTestFenceAPPLE (GLuint fence);
' ========================================================================================
DECLARE FUNCTION glTestFenceAPPLE (BYVAL fence AS DWORD) AS BYTE

' ========================================================================================
' void glFinishFenceAPPLE (GLuint fence);
' ========================================================================================
DECLARE SUB glFinishFenceAPPLE (BYVAL fence AS DWORD)

' ========================================================================================
' GLboolean glTestObjectAPPLE (GLenum object, GLuint name);
' ========================================================================================
DECLARE FUNCTION glTestObjectAPPLE (BYVAL dwObject AS DWORD, BYVAL dwName AS DWORD) AS BYTE

' ========================================================================================
' void glFinishObjectAPPLE (GLenum object, GLint name);
' ========================================================================================
DECLARE SUB glFinishObjectAPPLE (BYVAL dwObject AS DWORD, BYVAL nName AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_vertex_array_object)
'%GL_APPLE_vertex_array_object = 1

' ========================================================================================
' void glBindVertexArrayAPPLE (GLuint array);
' ========================================================================================
DECLARE SUB glBindVertexArrayAPPLE (BYVAL dwArray AS DWORD)

' ========================================================================================
' void glDeleteVertexArraysAPPLE (GLsizei n, const GLuint *arrays);
' ========================================================================================
DECLARE SUB glDeleteVertexArraysAPPLE (BYVAL n AS LONG, BYREF arrays AS DWORD)

' ========================================================================================
' void glGenVertexArraysAPPLE (GLsizei n, GLuint *arrays);
' ========================================================================================
DECLARE SUB glGenVertexArraysAPPLE (BYVAL n AS LONG, BYREF arrays AS DWORD)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsVertexArrayAPPLE (GLuint);
' typedef GLboolean (APIENTRYP PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
' ========================================================================================
DECLARE FUNCTION glIsVertexArrayAPPLE (BYVAL dwArray AS DWORD) AS BYTE

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_vertex_array_range)
'%GL_APPLE_vertex_array_range = 1

' ========================================================================================
' void glVertexArrayRangeAPPLE (GLsizei length, GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexArrayRangeAPPLE (BYVAL nLength AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glFlushVertexArrayRangeAPPLE (GLsizei length, GLvoid *pointer);
' ========================================================================================
DECLARE SUB glFlushVertexArrayRangeAPPLE (BYVAL nLength AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glVertexArrayParameteriAPPLE (GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glVertexArrayParameteriAPPLE (BYVAL pname AS DWORD, BYVAL param AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_ycbcr_422)
'%GL_APPLE_ycbcr_422 = 1
'#ENDIF

'#IF NOT %DEF(%GL_S3_s3tc)
'%GL_S3_s3tc = 1
'#ENDIF

'#IF NOT %DEF(%GL_ATI_draw_buffers)
'%GL_ATI_draw_buffers = 1

' ========================================================================================
' void glDrawBuffersATI (GLsizei n, const GLenum *bufs);
' ========================================================================================
DECLARE SUB glDrawBuffersATI (BYVAL n AS LONG, BYREF bufs AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_pixel_format_float)
'%GL_ATI_pixel_format_float = 1
'/* This is really a WGL extension, but defines some associated GL enums.
' * ATI does not export "GL_ATI_pixel_format_float" in the GL_EXTENSIONS string.
' */
'#ENDIF

'#IF NOT %DEF(%GL_ATI_texture_env_combine3)
'%GL_ATI_texture_env_combine3 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ATI_texture_float)
'%GL_ATI_texture_float = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_float_buffer)
'%GL_NV_float_buffer = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_fragment_program)
'%GL_NV_fragment_program = 1
'/* Some NV_fragment_program entry points are shared with ARB_vertex_program. */

' ========================================================================================
' void glProgramNamedParameter4fNV (GLuint id, GLsizei len, const GLubyte *name,
' GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glProgramNamedParameter4fNV (BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF pname AS BYTE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glProgramNamedParameter4dNV (GLuint id, GLsizei len, const GLubyte *name,
' GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glProgramNamedParameter4dNV (BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF pname AS BYTE, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glProgramNamedParameter4fvNV (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
' ========================================================================================
DECLARE SUB glProgramNamedParameter4fvNV (BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF pname AS BYTE, BYREF v AS SINGLE)

' ========================================================================================
' void glProgramNamedParameter4dvNV (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
' ========================================================================================
DECLARE SUB glProgramNamedParameter4dvNV (BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF pname AS BYTE, BYREF v AS DOUBLE)

' ========================================================================================
' void glGetProgramNamedParameterfvNV (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetProgramNamedParameterfvNV (BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF pname AS BYTE, BYREF params AS SINGLE)

' ========================================================================================
' void glGetProgramNamedParameterdvNV (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetProgramNamedParameterdvNV (BYVAL dwId AS DWORD, BYVAL nLen AS LONG, BYREF pname AS BYTE, BYREF params AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_NV_half_float)
'%GL_NV_half_float = 1

' ========================================================================================
' void glVertex2hNV (GLhalfNV x, GLhalfNV y);
' ========================================================================================
DECLARE SUB glVertex2hNV (BYVAL x AS WORD, BYVAL y AS WORD)

' ========================================================================================
' void glVertex2hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertex2hvNV (BYREF v AS WORD)

' ========================================================================================
' void glVertex3hNV (GLhalfNV x, GLhalfNV y, GLhalfNV z);
' ========================================================================================
DECLARE SUB glVertex3hNV (BYVAL x AS WORD, BYVAL y AS WORD, BYVAL z AS WORD)

' ========================================================================================
' void glVertex3hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertex3hvNV (BYREF v AS WORD)

' ========================================================================================
' void glVertex4hNV (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
' ========================================================================================
DECLARE SUB glVertex4hNV (BYVAL x AS WORD, BYVAL y AS WORD, BYVAL z AS WORD, BYVAL w AS WORD)

' ========================================================================================
' void glVertex4hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertex4hvNV (BYREF v AS WORD)

' ========================================================================================
' void glNormal3hNV (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
' ========================================================================================
DECLARE SUB glNormal3hNV (BYVAL nx AS WORD, BYVAL ny AS WORD, BYVAL nz AS WORD)

' ========================================================================================
' void glNormal3hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glNormal3hvNV (BYREF v AS WORD)

' ========================================================================================
' void glColor3hNV (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
' ========================================================================================
DECLARE SUB glColor3hNV (BYVAL red AS WORD, BYVAL green AS WORD, BYVAL blue AS WORD)

' ========================================================================================
' void glColor3hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glColor3hvNV (BYREF v AS INTEGER)

' ========================================================================================
' void glColor4hNV (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
' ========================================================================================
DECLARE SUB glColor4hNV (BYVAL red AS WORD, BYVAL green AS WORD, BYVAL blue AS WORD, BYVAL alpha AS WORD)

' ========================================================================================
' void glColor4hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glColor4hvNV (BYREF v AS WORD)

' ========================================================================================
' void glTexCoord1hNV (GLhalfNV s);
' ========================================================================================
DECLARE SUB glTexCoord1hNV (BYVAL s AS WORD)

' ========================================================================================
' void glTexCoord1hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glTexCoord1hvNV (BYREF v AS WORD)

' ========================================================================================
' void glTexCoord2hNV (GLhalfNV s, GLhalfNV t);
' ========================================================================================
DECLARE SUB glTexCoord2hNV (BYVAL s AS WORD, BYVAL t AS WORD)

' ========================================================================================
' void glTexCoord2hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glTexCoord2hvNV (BYREF v AS WORD)

' ========================================================================================
' void glTexCoord3hNV (GLhalfNV s, GLhalfNV t, GLhalfNV r);
' ========================================================================================
DECLARE SUB glTexCoord3hNV (BYVAL s AS WORD, BYVAL t AS WORD, BYVAL r AS WORD)

' ========================================================================================
' void glTexCoord3hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glTexCoord3hvNV (BYREF v AS WORD)

' ========================================================================================
' void glTexCoord4hNV (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
' ========================================================================================
DECLARE SUB glTexCoord4hNV (BYVAL s AS WORD, BYVAL t AS WORD, BYVAL r AS WORD, BYVAL q AS WORD)

' ========================================================================================
' void glTexCoord4hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glTexCoord4hvNV (BYREF v AS WORD)

' ========================================================================================
' void glMultiTexCoord1hNV (GLenum target, GLhalfNV s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1hNV (BYVAL dwTarget AS DWORD, BYVAL s AS WORD)

' ========================================================================================
' void glMultiTexCoord1hvNV (GLenum target, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord1hvNV (BYVAL dwTarget AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glMultiTexCoord2hNV (GLenum target, GLhalfNV s, GLhalfNV t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2hNV (BYVAL dwTarget AS DWORD, BYVAL s AS WORD, BYVAL t AS WORD)

' ========================================================================================
' void glMultiTexCoord2hvNV (GLenum target, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord2hvNV (BYVAL dwTarget AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glMultiTexCoord3hNV (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3hNV (BYVAL dwTarget AS DWORD, BYVAL s AS WORD, BYVAL t AS WORD, BYVAL r AS WORD)

' ========================================================================================
' void glMultiTexCoord3hvNV (GLenum target, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord3hvNV (BYVAL dwTarget AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glMultiTexCoord4hNV (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4hNV (BYVAL dwTarget AS DWORD, BYVAL s AS WORD, BYVAL t AS  WORD, BYVAL r AS WORD, BYVAL q AS WORD)

' ========================================================================================
' void glMultiTexCoord4hvNV (GLenum target, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glMultiTexCoord4hvNV (BYVAL dwTarget AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glFogCoordhNV (GLhalfNV fog);
' ========================================================================================
DECLARE SUB glFogCoordhNV (BYVAL fog AS WORD)

' ========================================================================================
' void glFogCoordhvNV (const GLhalfNV *fog);
' ========================================================================================
DECLARE SUB glFogCoordhvNV (BYREF fog AS WORD)

' ========================================================================================
' void glSecondaryColor3hNV (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
' ========================================================================================
DECLARE SUB glSecondaryColor3hNV (BYVAL red AS WORD, BYVAL green AS WORD, BYVAL blue AS WORD)

' ========================================================================================
' void glSecondaryColor3hvNV (const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glSecondaryColor3hvNV (BYREF v AS WORD)

' ========================================================================================
' void glVertexWeighthNV (GLhalfNV weight);
' ========================================================================================
DECLARE SUB glVertexWeighthNV (BYVAL weight AS WORD)

' ========================================================================================
' void glVertexWeighthvNV (const GLhalfNV *weight);
' ========================================================================================
DECLARE SUB glVertexWeighthvNV (BYREF weight AS WORD)

' ========================================================================================
' void glVertexAttrib1hNV (GLuint index, GLhalfNV x);
' ========================================================================================
DECLARE SUB glVertexAttrib1hNV (BYVAL dwIndex AS DWORD, BYVAL x AS WORD)

' ========================================================================================
' void glVertexAttrib1hvNV (GLuint index, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttrib1hvNV (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttrib2hNV (GLuint index, GLhalfNV x, GLhalfNV y);
' ========================================================================================
DECLARE SUB glVertexAttrib2hNV (BYVAL dwIndex AS DWORD, BYVAL x AS WORD, BYVAL y AS WORD)

' ========================================================================================
' void glVertexAttrib2hvNV (GLuint index, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttrib2hvNV (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttrib3hNV (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
' ========================================================================================
DECLARE SUB glVertexAttrib3hNV (BYVAL dwIndex AS DWORD, BYVAL x AS WORD, BYVAL y AS WORD, BYVAL z AS WORD)

' ========================================================================================
' void glVertexAttrib3hvNV (GLuint index, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttrib3hvNV (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttrib4hNV (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
' ========================================================================================
DECLARE SUB glVertexAttrib4hNV (BYVAL dwIndex AS DWORD, BYVAL x AS WORD, BYVAL y AS WORD, BYVAL z AS WORD, BYVAL w AS WORD)

' ========================================================================================
' void glVertexAttrib4hvNV (GLuint index, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttrib4hvNV (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttribs1hvNV (GLuint index, GLsizei n, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttribs1hvNV (BYVAL dwIndex AS DWORD, BYVAL n AS LONG, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttribs2hvNV (GLuint index, GLsizei n, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttribs2hvNV (BYVAL dwIndex AS DWORD, BYVAL n AS LONG, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttribs3hvNV (GLuint index, GLsizei n, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttribs3hvNV (BYVAL dwIndex AS DWORD, BYVAL n AS LONG, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttribs4hvNV (GLuint index, GLsizei n, const GLhalfNV *v);
' ========================================================================================
DECLARE SUB glVertexAttribs4hvNV (BYVAL dwIndex AS DWORD, BYVAL n AS LONG, BYREF v AS WORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_pixel_data_range)
'%GL_NV_pixel_data_range = 1

' ========================================================================================
' void glPixelDataRangeNV (GLenum target, GLsizei length, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glPixelDataRangeNV (BYVAL dwTarget AS DWORD, BYVAL nLength AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glFlushPixelDataRangeNV (GLenum target);
' ========================================================================================
DECLARE SUB glFlushPixelDataRangeNV (BYVAL dwTarget AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_primitive_restart)
'%GL_NV_primitive_restart = 1

' ========================================================================================
' void glPrimitiveRestartNV (void);
' ========================================================================================
DECLARE SUB glPrimitiveRestartNV

' ========================================================================================
' void glPrimitiveRestartIndexNV (GLuint index);
' ========================================================================================
DECLARE SUB glPrimitiveRestartIndexNV (BYVAL dwIndex AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_expand_normal)
'%GL_NV_texture_expand_normal = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program2)
'%GL_NV_vertex_program2 = 1
'#ENDIF

'#IF NOT %DEF(%GL_ATI_map_object_buffer)
'%GL_ATI_map_object_buffer = 1

' ========================================================================================
' GLvoid* glMapObjectBufferATI (GLuint buffer);
' ========================================================================================
DECLARE FUNCTION glMapObjectBufferATI (BYVAL buffer AS DWORD) AS DWORD

' ========================================================================================
' void glUnmapObjectBufferATI (GLuint buffer);
' ========================================================================================
DECLARE SUB glUnmapObjectBufferATI (BYVAL buffer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_separate_stencil)
'%GL_ATI_separate_stencil = 1

' ========================================================================================
' void glStencilOpSeparateATI (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
' ========================================================================================
DECLARE SUB glStencilOpSeparateATI (BYVAL dwFace AS DWORD, BYVAL sfail AS DWORD, BYVAL dpfail AS DWORD, BYVAL dppass AS DWORD)

' ========================================================================================
' void glStencilFuncSeparateATI (GLenum , GLenum , GLint ref, GLuint mask);
' ========================================================================================
DECLARE SUB glStencilFuncSeparateATI (BYVAL frontfunc AS DWORD, BYVAL backfunc AS DWORD, BYVAL nRef AS LONG, BYVAL dwMask AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_vertex_attrib_array_object)
'%GL_ATI_vertex_attrib_array_object = 1

' ========================================================================================
' void glVertexAttribArrayObjectATI (GLuint index, GLint size, GLenum type,
' GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
' ========================================================================================
DECLARE SUB glVertexAttribArrayObjectATI (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYVAL nStride AS LONG, BYVAL buffer AS DWORD, BYVAL dwOffset AS DWORD)

' ========================================================================================
' void glGetVertexAttribArrayObjectfvATI (GLuint index, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribArrayObjectfvATI (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetVertexAttribArrayObjectivATI (GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribArrayObjectivATI (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

#IF NOT %DEF(%GL_OES_byte_coordinates)
%GL_OES_byte_coordinates = 1

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord1bOES (GLenum texture, GLbyte s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1bOES (BYVAL dwtexture AS DWORD, BYVAL s AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord1bvOES (GLenum texture, const GLbyte *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord1bvOES (BYVAL dwtexture AS DWORD, BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord2bOES (GLenum texture, GLbyte s, GLbyte t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2bOES (BYVAL dwtexture AS DWORD, BYVAL s AS BYTE, BYVAL t AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord2bvOES (GLenum texture, const GLbyte *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord2bvOES (BYVAL dwtexture AS DWORD, BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord3bOES (GLenum texture, GLbyte s, GLbyte t, GLbyte r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3bOES (BYVAL dwtexture AS DWORD, BYVAL s AS BYTE, BYVAL t AS BYTE, BYVAL r AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord3bvOES (GLenum texture, const GLbyte *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord3bvOES (BYVAL dwtexture AS DWORD, BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord4bOES (GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4bOES (BYVAL dwtexture AS DWORD, BYVAL s AS BYTE, BYVAL t AS BYTE, BYVAL r AS BYTE, BYVAL q AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord4bvOES (GLenum texture, const GLbyte *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord4bvOES (BYVAL dwtexture AS DWORD, BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord1bOES (GLbyte s);
' ========================================================================================
DECLARE SUB glTexCoord1bOES (BYVAL s AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord1bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glTexCoord1bvOES (BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord2bOES (GLbyte s, GLbyte t);
' ========================================================================================
DECLARE SUB glTexCoord2bOES (BYVAL s AS BYTE, BYVAL t AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord2bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glTexCoord2bvOES (BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord3bOES (GLbyte s, GLbyte t, GLbyte r);
' ========================================================================================
DECLARE SUB glTexCoord3bOES (BYVAL s AS BYTE, BYVAL t AS BYTE, BYVAL r AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord3bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glTexCoord3bvOES (BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord4bOES (GLbyte s, GLbyte t, GLbyte r, GLbyte q);
' ========================================================================================
DECLARE SUB glTexCoord4bOES (BYVAL s AS BYTE, BYVAL t AS BYTE, BYVAL r AS BYTE, BYVAL q AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord4bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glTexCoord4bvOES (BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glVertex2bOES (GLbyte x);
' ========================================================================================
DECLARE SUB glVertex2bOES (BYVAL s AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glVertex2bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glVertex2bvOES (BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glVertex3bOES (GLbyte x, GLbyte y);
' ========================================================================================
DECLARE SUB glVertex3bOES (BYVAL x AS BYTE, BYVAL y AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glVertex3bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glVertex3bvOES (BYREF coords AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glVertex4bOES (GLbyte x, GLbyte y, GLbyte z);
' ========================================================================================
DECLARE SUB glVertex4bOES (BYVAL x AS BYTE, BYVAL y AS BYTE, BYVAL z AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glVertex4bvOES (const GLbyte *coords);
' ========================================================================================
DECLARE SUB glVertex4bvOES (BYREF coords AS BYTE)

#ENDIF

#IF NOT %DEF(%GL_OES_fixed_point)
%GL_OES_fixed_point = 1

' ========================================================================================
' GLAPI void APIENTRY glAccumxOES (GLenum op, GLfixed value);
' ========================================================================================
DECLARE SUB glAccumxOES (BYVAL op AS DWORD, BYVAL value AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glAlphaFuncxOES (GLenum func, GLfixed ref);
' ========================================================================================
DECLARE SUB glAlphaFuncxOES (BYVAL func AS DWORD, BYVAL ref AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glBitmapxOES (GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap);
' ========================================================================================
DECLARE SUB glBitmapxOES (BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL xorig AS LONG, BYVAL yorig AS LONG, BYVAL xmove AS LONG, BYVAL ymove AS LONG, BYREF bitmap_ AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glBlendColorxOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
' ========================================================================================
DECLARE SUB glBlendColorxOES (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG, BYVAL alpha AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glClearAccumxOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
' ========================================================================================
DECLARE SUB glClearAccumxOES (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG, BYVAL alpha AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glClearColorxOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
' ========================================================================================
DECLARE SUB glClearColorxOES (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG, BYVAL alpha AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glClearDepthxOES (GLfixed depth);
' ========================================================================================
DECLARE SUB glClearDepthxOES (BYVAL depth AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glClipPlanexOES (GLenum plane, const GLfixed *equation);
' ========================================================================================
DECLARE SUB glClipPlanexOES (BYVAL plane AS DWORD, BYREF equation AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glColor3xOES (GLfixed red, GLfixed green, GLfixed blue);
' ========================================================================================
DECLARE SUB glColor3xOES (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glColor4xOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
' ========================================================================================
DECLARE SUB glColor4xOES (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG, BYVAL alpha AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glColor3xvOES (const GLfixed *components);
' ========================================================================================
DECLARE SUB glColor3xvOES (BYREF components AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glColor4xvOES (const GLfixed *components);
' ========================================================================================
DECLARE SUB glColor4xvOES (BYREF components AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glConvolutionParameterxOES (GLenum target, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glConvolutionParameterxOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glConvolutionParameterxvOES (GLenum target, GLenum pname, const GLfixed *params);
' ========================================================================================
DECLARE SUB glConvolutionParameterxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glDepthRangexOES (GLfixed n, GLfixed f);
' ========================================================================================
DECLARE SUB glDepthRangexOES (BYVAL n AS LONG, BYVAL f AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glEvalCoord1xOES (GLfixed u);
' ========================================================================================
DECLARE SUB glEvalCoord1xOES (BYVAL u AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glEvalCoord2xOES (GLfixed u, GLfixed v);
' ========================================================================================
DECLARE SUB glEvalCoord2xOES (BYVAL u AS LONG, BYVAL v AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glEvalCoord1xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glEvalCoord1xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glEvalCoord2xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glEvalCoord2xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glFeedbackBufferxOES (GLsizei n, GLenum type, const GLfixed *buffer);
' ========================================================================================
DECLARE SUB glFeedbackBufferxOES (BYVAL n AS LONG, BYVAL dwtype AS DWORD, BYREF buffer AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glFogxOES (GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glFogxOES (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glFogxvOES (GLenum pname, const GLfixed *param);
' ========================================================================================
DECLARE SUB glFogxvOES (BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glFrustumxOES (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);
' ========================================================================================
DECLARE SUB glFrustumxOES (BYVAL l AS LONG, BYVAL r AS LONG, BYVAL b AS LONG, BYVAL t AS LONG, BYVAL n AS LONG, BYVAL f AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetClipPlanexOES (GLenum plane, GLfixed *equation);
' ========================================================================================
DECLARE SUB glGetClipPlanexOES (BYVAL plane AS DWORD, BYREF equation AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetConvolutionParameterxvOES (GLenum target, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetConvolutionParameterxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetFixedvOES (GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetFixedvOES (BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetHistogramParameterxvOES (GLenum target, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetHistogramParameterxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetLightxOES (GLenum light, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetLightxOES (BYVAL light AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetMapxvOES (GLenum target, GLenum query, GLfixed *v);
' ========================================================================================
DECLARE SUB glGetMapxvOES (BYVAL dwtarget AS DWORD, BYVAL query AS DWORD, BYREF v AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetMaterialxOES (GLenum face, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glGetMaterialxOES (BYVAL face AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetPixelMapxv (GLenum map, GLint size, GLfixed *values);
' ========================================================================================
DECLARE SUB glGetPixelMapxv (BYVAL map AS DWORD, BYVAL nsize AS LONG, BYREF values AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetTexEnvxvOES (GLenum target, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetTexEnvxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetTexGenxvOES (GLenum coord, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetTexGenxvOES (BYVAL dwcoord AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetTexLevelParameterxvOES (GLenum target, GLint level, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetTexLevelParameterxvOES (BYVAL dwtarget AS DWORD, BYVAL nlevel AS LONG, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetTexParameterxvOES (GLenum target, GLenum pname, GLfixed *params);
' ========================================================================================
DECLARE SUB glGetTexParameterxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glIndexxOES (GLfixed component);
' ========================================================================================
DECLARE SUB glIndexxOES (BYVAL component AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glIndexxvOES (const GLfixed *component);
' ========================================================================================
DECLARE SUB glIndexxvOES (BYREF component AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLightModelxOES (GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glLightModelxOES (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLightModelxvOES (GLenum pname, const GLfixed *param);
' ========================================================================================
DECLARE SUB glLightModelxvOES (BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLightxOES (GLenum light, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glLightxOES (BYVAL light AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLightxvOES (GLenum light, GLenum pname, const GLfixed *params);
' ========================================================================================
DECLARE SUB glLightxvOES (BYVAL light AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLineWidthxOES (GLfixed width);
' ========================================================================================
DECLARE SUB glLineWidthxOES (BYVAL nwidth AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLoadMatrixxOES (const GLfixed *m);
' ========================================================================================
DECLARE SUB glLoadMatrixxOES (BYREF m AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glLoadTransposeMatrixxOES (const GLfixed *m);
' ========================================================================================
DECLARE SUB glLoadTransposeMatrixxOES (BYREF m AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMap1xOES (GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points);
' ========================================================================================
DECLARE SUB glMap1xOES (BYVAL dwtarget AS DWORD, BYVAL u1 AS LONG, BYVAL u2 AS LONG, BYVAL stride AS LONG, BYVAL order AS LONG, BYVAL pts AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMap2xOES (GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points);
' ========================================================================================
DECLARE SUB glMap2xOES (BYVAL dwtarget AS DWORD, BYVAL u1 AS LONG, BYVAL u2 AS LONG, BYVAL ustride AS LONG, BYVAL uorder AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG, BYVAL vstride AS LONG, BYVAL vorder AS LONG, BYVAL pts AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMapGrid1xOES (GLint n, GLfixed u1, GLfixed u2);
' ========================================================================================
DECLARE SUB glMapGrid1xOES (BYVAL n AS LONG, BYVAL u1 AS LONG, BYVAL u2 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMapGrid2xOES (GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2);
' ========================================================================================
DECLARE SUB glMapGrid2xOES (BYVAL n AS LONG, BYVAL u1 AS LONG, BYVAL u2 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMaterialxOES (GLenum face, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glMaterialxOES (BYVAL face AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMaterialxvOES (GLenum face, GLenum pname, const GLfixed *param);
' ========================================================================================
DECLARE SUB glMaterialxvOES (BYVAL face AS DWORD, BYVAL pname AS DWORD, BYREF param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultMatrixxOES (const GLfixed *m);
' ========================================================================================
DECLARE SUB glMultMatrixxOES (BYREF m AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultTransposeMatrixxOES (const GLfixed *m);
' ========================================================================================
DECLARE SUB glMultTransposeMatrixxOES (BYREF m AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord1xOES (GLenum texture, GLfixed s);
' ========================================================================================
DECLARE SUB glMultiTexCoord1xOES (BYVAL dwtexture AS DWORD, BYVAL s AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord2xOES (GLenum texture, GLfixed s, GLfixed t);
' ========================================================================================
DECLARE SUB glMultiTexCoord2xOES (BYVAL dwtexture AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord3xOES (GLenum texture, GLfixed s, GLfixed t, GLfixed r);
' ========================================================================================
DECLARE SUB glMultiTexCoord3xOES (BYVAL dwtexture AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG, BYVAL r AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord4xOES (GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
' ========================================================================================
DECLARE SUB glMultiTexCoord4xOES (BYVAL dwtexture AS DWORD, BYVAL s AS LONG, BYVAL t AS LONG, BYVAL r AS LONG, BYVAL q AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord1xvOES (GLenum texture, const GLfixed *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord1xvOES (BYVAL dwtexture AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord2xvOES (GLenum texture, const GLfixed *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord2xvOES (BYVAL dwtexture AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord3xvOES (GLenum texture, const GLfixed *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord3xvOES (BYVAL dwtexture AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexCoord4xvOES (GLenum texture, const GLfixed *coords);
' ========================================================================================
DECLARE SUB glMultiTexCoord4xvOES (BYVAL dwtexture AS DWORD, BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glNormal3xOES (GLfixed nx, GLfixed ny, GLfixed nz);
' ========================================================================================
DECLARE SUB glNormal3xOES (BYVAL nx AS LONG, BYVAL ny AS LONG, BYVAL nz AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glNormal3xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glNormal3xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glOrthoxOES (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);
' ========================================================================================
DECLARE SUB glOrthoxOES (BYVAL l AS LONG, BYVAL r AS LONG, BYVAL b AS LONG, BYVAL t AS LONG, BYVAL n AS LONG, BYVAL f AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPassThroughxOES (GLfixed token);
' ========================================================================================
DECLARE SUB glPassThroughxOES (BYVAL token AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPixelMapx (GLenum map, GLint size, const GLfixed *values);
' ========================================================================================
DECLARE SUB glPixelMapx (BYVAL map AS DWORD, BYVAL nsize AS LONG, BYREF values AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPixelStorex (GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glPixelStorex (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPixelTransferxOES (GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glPixelTransferxOES (BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPixelZoomxOES (GLfixed xfactor, GLfixed yfactor);
' ========================================================================================
DECLARE SUB glPixelZoomxOES (BYVAL xfactor AS LONG, BYVAL yfactor AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPointParameterxvOES (GLenum pname, const GLfixed *params);
' ========================================================================================
DECLARE SUB glPointParameterxvOES (BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPointSizexOES (GLfixed size);
' ========================================================================================
DECLARE SUB glPointSizexOES (BYVAL nsize AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPolygonOffsetxOES (GLfixed factor, GLfixed units);
' ========================================================================================
DECLARE SUB glPolygonOffsetxOES (BYVAL factor AS LONG, BYVAL nunits AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPrioritizeTexturesxOES (GLsizei n, const GLuint *textures, const GLfixed *priorities);
' ========================================================================================
DECLARE SUB glPrioritizeTexturesxOES (BYVAL n AS LONG, BYREF textures AS DWORD, BYREF priorities AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRasterPos2xOES (GLfixed x, GLfixed y);
' ========================================================================================
DECLARE SUB glRasterPos2xOES (BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRasterPos3xOES (GLfixed x, GLfixed y, GLfixed z);
' ========================================================================================
DECLARE SUB glRasterPos3xOES (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRasterPos4xOES (GLfixed x, GLfixed y, GLfixed z, GLfixed w);
' ========================================================================================
DECLARE SUB glRasterPos4xOES (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRasterPos2xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glRasterPos2xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRasterPos3xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glRasterPos3xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRasterPos4xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glRasterPos4xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRectxOES (GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2);
' ========================================================================================
DECLARE SUB glRectxOES (BYVAL x1 AS LONG, BYVAL y1 AS LONG, BYVAL x2 AS LONG, BYVAL y2 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRectxvOES (const GLfixed *v1, const GLfixed *v2);
' ========================================================================================
DECLARE SUB glRectxvOES (BYREF v1 AS LONG, BYREF v2 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glRotatexOES (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
' ========================================================================================
DECLARE SUB glRotatexOES (BYVAL angle AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glSampleCoverageOES (GLfixed value, GLboolean invert);
' ========================================================================================
DECLARE SUB glSampleCoverageOES (BYVAL value AS LONG, BYVAL invert AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glScalexOES (GLfixed x, GLfixed y, GLfixed z);
' ========================================================================================
DECLARE SUB glScalexOES (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord1xOES (GLfixed s);
' ========================================================================================
DECLARE SUB glTexCoord1xOES (BYVAL s AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord2xOES (GLfixed s, GLfixed t);
' ========================================================================================
DECLARE SUB glTexCoord2xOES (BYVAL s AS LONG, BYVAL t AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord3xOES (GLfixed s, GLfixed t, GLfixed r);
' ========================================================================================
DECLARE SUB glTexCoord3xOES (BYVAL s AS LONG, BYVAL t AS LONG, BYVAL r AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord4xOES (GLfixed s, GLfixed t, GLfixed r, GLfixed q);
' ========================================================================================
DECLARE SUB glTexCoord4xOES (BYVAL s AS LONG, BYVAL t AS LONG, BYVAL r AS LONG, BYVAL q AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord1xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glTexCoord1xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord2xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glTexCoord2xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord3xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glTexCoord3xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexCoord4xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glTexCoord4xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexEnvxOES (GLenum target, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glTexEnvxOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexEnvxvOES (GLenum target, GLenum pname, const GLfixed *params);
' ========================================================================================
DECLARE SUB glTexEnvxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexGenxOES (GLenum coord, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glTexGenxOES (BYVAL dwcoord AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexGenxvOES (GLenum coord, GLenum pname, const GLfixed *params);
' ========================================================================================
DECLARE SUB glTexGenxvOES (BYVAL dwcoord AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexParameterxOES (GLenum target, GLenum pname, GLfixed param);
' ========================================================================================
DECLARE SUB glTexParameterxOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexParameterxvOES (GLenum target, GLenum pname, const GLfixed *params);
' ========================================================================================
DECLARE SUB glTexParameterxvOES (BYVAL dwtarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTranslatexOES (GLfixed x, GLfixed y, GLfixed z);
' ========================================================================================
DECLARE SUB glTranslatexOES (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertex2xOES (GLfixed x);
' ========================================================================================
DECLARE SUB glVertex2xOES (BYVAL x AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertex3xOES (GLfixed x, GLfixed y);
' ========================================================================================
DECLARE SUB glVertex3xOES (BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertex4xOES (GLfixed x, GLfixed y, GLfixed z);
' ========================================================================================
DECLARE SUB glVertex4xOES (BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertex2xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glVertex2xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertex3xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glVertex3xvOES (BYREF coords AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVertex4xvOES (const GLfixed *coords);
' ========================================================================================
DECLARE SUB glVertex4xvOES (BYREF coords AS LONG)

#ENDIF

#IF NOT %DEF(%GL_OES_single_precision)
%GL_OES_single_precision = 1

' ========================================================================================
' GLAPI void APIENTRY glDepthRangefOES (GLclampf n, GLclampf f);
' ========================================================================================
DECLARE SUB glDepthRangefOES (BYVAL n AS SINGLE, BYVAL f AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glFrustumfOES (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
' ========================================================================================
DECLARE SUB glFrustumfOES (BYVAL l AS SINGLE, BYVAL r AS SINGLE, BYVAL b AS SINGLE, BYVAL t AS SINGLE, BYVAL n AS SINGLE, BYVAL f AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glOrthofOES (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
' ========================================================================================
DECLARE SUB glOrthofOES (BYVAL l AS SINGLE, BYVAL r AS SINGLE, BYVAL b AS SINGLE, BYVAL t AS SINGLE, BYVAL n AS SINGLE, BYVAL f AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glClipPlanefOES (GLenum plane, const GLfloat *equation);
' ========================================================================================
DECLARE SUB glClipPlanefOES (BYVAL plane AS DWORD, BYREF equation AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glClearDepthfOES (GLclampf depth);
' ========================================================================================
DECLARE SUB glClearDepthfOES (BYVAL depth AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetClipPlanefOES (GLenum plane, GLfloat *equation);
' ========================================================================================
DECLARE SUB glGetClipPlanefOES (BYVAL plane AS DWORD, BYREF equation AS SINGLE)

#ENDIF

'#IF NOT %DEF(%GL_OES_compressed_paletted_texture)
'%GL_OES_compressed_paletted_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_OES_read_format)
'%GL_OES_read_format = 1
'#ENDIF

#IF NOT %DEF(%GL_OES_query_matrix)
%GL_OES_query_matrix = 1

' ========================================================================================
' GLAPI GLbitfield APIENTRY glQueryMatrixxOES (GLfixed *mantissa, GLint *exponent);
' ========================================================================================
DECLARE FUNCTION glQueryMatrixxOES (BYREF mantissa AS LONG, BYREF exponent AS LONG) AS DWORD

#ENDIF

'#IF NOT %DEF(%GL_EXT_depth_bounds_test)
'%GL_EXT_depth_bounds_test = 1

' ========================================================================================
' void glDepthBoundsEXT (GLclampd zmin, GLclampd zmax);
' ========================================================================================
DECLARE SUB glDepthBoundsEXT (BYVAL zmin AS DOUBLE, BYVAL zmax AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_mirror_clamp)
'%GL_EXT_texture_mirror_clamp = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_blend_equation_separate)
'%GL_EXT_blend_equation_separate = 1

' ========================================================================================
' void glBlendEquationSeparateEXT (GLenum modeRGB, GLenum modeAlpha);
' ========================================================================================
DECLARE SUB glBlendEquationSeparateEXT (BYVAL modeRGB AS DWORD, BYVAL modeAlpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_MESA_pack_invert)
'%GL_MESA_pack_invert = 1
'#ENDIF

'#IF NOT %DEF(%GL_MESA_ycbcr_texture)
'%GL_MESA_ycbcr_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_pixel_buffer_object)
'%GL_EXT_pixel_buffer_object = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_fragment_program_option)
'%GL_NV_fragment_program_option = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_fragment_program2)
'%GL_NV_fragment_program2 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program2_option)
'%GL_NV_vertex_program2_option = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program3)
'%GL_NV_vertex_program3 = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_framebuffer_object)
'%GL_EXT_framebuffer_object = 1

' ========================================================================================
' GLboolean glIsRenderbufferEXT (GLuint );
' ========================================================================================
DECLARE FUNCTION glIsRenderbufferEXT (BYVAL renderbuffer AS DWORD) AS BYTE

' ========================================================================================
' void glBindRenderbufferEXT (GLenum target, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glBindRenderbufferEXT (BYVAL dwTarget AS DWORD, BYVAL renderbuffer AS DWORD)

' ========================================================================================
' void glDeleteRenderbuffersEXT (GLsizei n, const GLuint *renderbuffers);
' ========================================================================================
DECLARE SUB glDeleteRenderbuffersEXT (BYVAL n AS LONG, BYREF renderbuffers AS DWORD)

' ========================================================================================
' void glGenRenderbuffersEXT (GLsizei n, GLuint *renderbuffers);
' ========================================================================================
DECLARE SUB glGenRenderbuffersEXT (BYVAL n AS LONG, BYREF renderbuffers AS DWORD)

' ========================================================================================
' void glRenderbufferStorageEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glRenderbufferStorageEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glGetRenderbufferParameterivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetRenderbufferParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsFramebufferEXT (GLuint);
' typedef GLboolean (APIENTRYP PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
' ========================================================================================
DECLARE FUNCTION glIsFramebufferEXT (BYVAL framebuffer AS DWORD) AS BYTE

' ========================================================================================
' void glBindFramebufferEXT (GLenum target, GLuint framebuffer);
' ========================================================================================
DECLARE SUB glBindFramebufferEXT (BYVAL dwTarget AS DWORD, BYVAL framebuffer AS DWORD)

' ========================================================================================
' void glDeleteFramebuffersEXT (GLsizei n, const GLuint *framebuffers);
' ========================================================================================
DECLARE SUB glDeleteFramebuffersEXT (BYVAL n AS LONG, BYREF framebuffers AS DWORD)

' ========================================================================================
' void glGenFramebuffersEXT (GLsizei n, GLuint *framebuffers);
' ========================================================================================
DECLARE SUB glGenFramebuffersEXT (BYVAL n AS LONG, BYREF framebuffers AS DWORD)

' ========================================================================================
' GLenum glCheckFramebufferStatusEXT (GLenum target);
' ========================================================================================
DECLARE FUNCTION glCheckFramebufferStatusEXT (BYVAL dwTarget AS DWORD) AS DWORD

' ========================================================================================
' void glFramebufferTexture1DEXT (GLenum target, GLenum attachment, GLenum textarget,
' GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTexture1DEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexttarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glFramebufferTexture2DEXT (GLenum target, GLenum attachment, GLenum textarget,
' GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTexture2DEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexttarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glFramebufferTexture3DEXT (GLenum target, GLenum attachment, GLenum textarget,
' GLuint texture, GLint level, GLint zoffset);
' ========================================================================================
DECLARE SUB glFramebufferTexture3DEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexttarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL zoffset AS LONG)

' ========================================================================================
' void glFramebufferRenderbufferEXT (GLenum target, GLenum attachment,
' GLenum renderbuffertarget, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glFramebufferRenderbufferEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL renderbuffertarget AS DWORD, BYVAL renderbuffer AS DWORD)

' ========================================================================================
' void glGetFramebufferAttachmentParameterivEXT (GLenum target, GLenum attachment,
' GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFramebufferAttachmentParameterivEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGenerateMipmapEXT (GLenum target);
' ========================================================================================
DECLARE SUB glGenerateMipmapEXT (BYVAL dwTarget AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_GREMEDY_string_marker)
'%GL_GREMEDY_string_marker = 1

' ========================================================================================
' void glStringMarkerGREMEDY (GLsizei len, const GLvoid *string);
' ========================================================================================
DECLARE SUB glStringMarkerGREMEDY (BYVAL nLength AS LONG, BYVAL pPointer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_packed_depth_stencil)
'%GL_EXT_packed_depth_stencil = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_stencil_clear_tag)
'%GL_EXT_stencil_clear_tag = 1

' ========================================================================================
' void glStencilClearTagEXT (GLsizei stencilTagBits, GLuint stencilClearTag);
' ========================================================================================
DECLARE SUB glStencilClearTagEXT (BYVAL stencilTagBits AS LONG, BYVAL stencilClearTag AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_sRGB)
'%GL_EXT_texture_sRGB = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_framebuffer_blit)
'%GL_EXT_framebuffer_blit = 1

' ========================================================================================
' void glBlitFramebufferEXT (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
' GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
' ========================================================================================
DECLARE SUB glBlitFramebufferEXT (BYVAL srcX0 AS LONG, BYVAL srcY0 AS LONG, BYVAL srcX1 AS LONG, BYVAL srcY1 AS LONG, BYVAL dstX0 AS LONG, BYVAL dstY0 AS LONG, BYVAL dstX1 AS LONG, _
   BYVAL dstY1 AS LONG, BYVAL dwMask AS DWORD, BYVAL dwFilter AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_framebuffer_multisample)
'%GL_EXT_framebuffer_multisample = 1

' ========================================================================================
' void glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples,
' GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glRenderbufferStorageMultisampleEXT (BYVAL dwTarget AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_MESAX_texture_stack)
'%GL_MESAX_texture_stack = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_timer_query)
'%GL_EXT_timer_query = 1

' ========================================================================================
' void glGetQueryObjecti64vEXT (GLuint id, GLenum pname, GLint64EXT *params);
' ========================================================================================
DECLARE SUB glGetQueryObjecti64vEXT (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' void glGetQueryObjectui64vEXT (GLuint id, GLenum pname, GLuint64EXT *params);
' ========================================================================================
DECLARE SUB glGetQueryObjectui64vEXT (BYVAL dwId AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_gpu_program_parameters)
'%GL_EXT_gpu_program_parameters = 1

' ========================================================================================
' void glProgramEnvParameters4fvEXT (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
' ========================================================================================
DECLARE SUB glProgramEnvParameters4fvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS SINGLE)

' ========================================================================================
' void glProgramLocalParameters4fvEXT (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
' ========================================================================================
DECLARE SUB glProgramLocalParameters4fvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_flush_buffer_range)
'%GL_APPLE_flush_buffer_range = 1

' ========================================================================================
' void glBufferParameteriAPPLE (GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glBufferParameteriAPPLE (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glFlushMappedBufferRangeAPPLE (GLenum target, GLintptr offset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glFlushMappedBufferRangeAPPLE (BYVAL dwTarget AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_NV_gpu_program4)
'%GL_NV_gpu_program4 = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glProgramLocalParameterI4iNV (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glProgramLocalParameterI4iNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glProgramLocalParameterI4ivNV (GLenum target, GLuint index, const GLint *params);
' ========================================================================================
DECLARE SUB glProgramLocalParameterI4ivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glProgramLocalParametersI4ivNV (GLenum target, GLuint index, GLsizei count, const GLint *params);
' ========================================================================================
DECLARE SUB glProgramLocalParametersI4ivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS LONG)

' ========================================================================================
' void glProgramLocalParameterI4uiNV (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
' ========================================================================================
DECLARE SUB glProgramLocalParameterI4uiNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD, BYVAL w AS DWORD)

' ========================================================================================
' void glProgramLocalParameterI4uivNV (GLenum target, GLuint index, const GLuint *params);
' ========================================================================================
DECLARE SUB glProgramLocalParameterI4uivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glProgramLocalParametersI4uivNV (GLenum target, GLuint index, GLsizei count, const GLuint *params);
' ========================================================================================
DECLARE SUB glProgramLocalParametersI4uivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS DWORD)

' ========================================================================================
' void glProgramEnvParameterI4iNV (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glProgramEnvParameterI4iNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glProgramEnvParameterI4ivNV (GLenum target, GLuint index, const GLint *params);
' ========================================================================================
DECLARE SUB glProgramEnvParameterI4ivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glProgramEnvParametersI4ivNV (GLenum target, GLuint index, GLsizei count, const GLint *params);
' ========================================================================================
DECLARE SUB glProgramEnvParametersI4ivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS LONG)

' ========================================================================================
' void glProgramEnvParameterI4uiNV (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
' ========================================================================================
DECLARE SUB glProgramEnvParameterI4uiNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD, BYVAL w AS DWORD)

' ========================================================================================
' void glProgramEnvParameterI4uivNV (GLenum target, GLuint index, const GLuint *params);
' ========================================================================================
DECLARE SUB glProgramEnvParameterI4uivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glProgramEnvParametersI4uivNV (GLenum target, GLuint index, GLsizei count, const GLuint *params);
' ========================================================================================
DECLARE SUB glProgramEnvParametersI4uivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS DWORD)

' ========================================================================================
' void glGetProgramLocalParameterIivNV (GLenum target, GLuint index, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramLocalParameterIivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetProgramLocalParameterIuivNV (GLenum target, GLuint index, GLuint *params);
' ========================================================================================
DECLARE SUB glGetProgramLocalParameterIuivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glGetProgramEnvParameterIivNV (GLenum target, GLuint index, GLint *params);
' ========================================================================================
DECLARE SUB glGetProgramEnvParameterIivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetProgramEnvParameterIuivNV (GLenum target, GLuint index, GLuint *params);
' ========================================================================================
DECLARE SUB glGetProgramEnvParameterIuivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_geometry_program4)
'%GL_NV_geometry_program4 = 1

' ========================================================================================
' void glProgramVertexLimitNV (GLenum target, GLint limit);
' ========================================================================================
DECLARE SUB glProgramVertexLimitNV (BYVAL dwTarget AS DWORD, BYVAL nLimit AS LONG)

' ========================================================================================
' void glFramebufferTextureEXT (GLenum target, GLenum attachment, GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glFramebufferTextureEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glFramebufferTextureLayerEXT (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
' ========================================================================================
DECLARE SUB glFramebufferTextureLayerEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL nLayer AS LONG)

' ========================================================================================
' void glFramebufferTextureFaceEXT (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
' ========================================================================================
DECLARE SUB glFramebufferTextureFaceEXT (BYVAL dwTarget AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL dwFace AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_geometry_shader4)
'%GL_EXT_geometry_shader4 = 1

' ========================================================================================
' void glProgramParameteriEXT (GLuint program, GLenum pname, GLint value);
' ========================================================================================
DECLARE SUB glProgramParameteriEXT (BYVAL dwProgram AS DWORD, BYVAL pname AS DWORD, BYVAL value AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_program4)
'%GL_NV_vertex_program4 = 1

' ========================================================================================
' void glVertexAttribI1iEXT (GLuint index, GLint x);
' ========================================================================================
DECLARE SUB glVertexAttribI1iEXT (BYVAL dwIndex AS DWORD, BYVAL x AS LONG)

' ========================================================================================
' void glVertexAttribI2iEXT (GLuint index, GLint x, GLint y);
' ========================================================================================
DECLARE SUB glVertexAttribI2iEXT (BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG)

' ========================================================================================
' void glVertexAttribI3iEXT (GLuint index, GLint x, GLint y, GLint z);
' ========================================================================================
DECLARE SUB glVertexAttribI3iEXT (BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG)

' ========================================================================================
' void glVertexAttribI4iEXT (GLuint index, GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glVertexAttribI4iEXT (BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glVertexAttribI1uiEXT (GLuint index, GLuint x);
' ========================================================================================
DECLARE SUB glVertexAttribI1uiEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD)

' ========================================================================================
' void glVertexAttribI2uiEXT (GLuint index, GLuint x, GLuint y);
' ========================================================================================
DECLARE SUB glVertexAttribI2uiEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD)

' ========================================================================================
' void glVertexAttribI3uiEXT (GLuint index, GLuint x, GLuint y, GLuint z);
' ========================================================================================
DECLARE SUB glVertexAttribI3uiEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD)

' ========================================================================================
' void glVertexAttribI4uiEXT (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
' ========================================================================================
DECLARE SUB glVertexAttribI4uiEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD, BYVAL w AS DWORD)

' ========================================================================================
' void glVertexAttribI1ivEXT (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI1ivEXT (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI2ivEXT (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI2ivEXT (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI3ivEXT (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI3ivEXT (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI4ivEXT (GLuint index, const GLint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4ivEXT (BYVAL dwIndex AS DWORD, BYREF v AS LONG)

' ========================================================================================
' void glVertexAttribI1uivEXT (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI1uivEXT (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI2uivEXT (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI2uivEXT (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI3uivEXT (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI3uivEXT (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' void glVertexAttribI4uivEXT (GLuint index, const GLuint *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4uivEXT (BYVAL dwIndex AS DWORD, BYREF v AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribI4bvEXT (GLuint, const GLbyte *);
' typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4bvEXT (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttribI4svEXT (GLuint index, const GLshort *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4svEXT (BYVAL dwIndex AS DWORD, BYREF v AS INTEGER)

' ========================================================================================
' void glVertexAttribI4ubvEXT (GLuint index, const GLubyte *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4ubvEXT (BYVAL dwIndex AS DWORD, BYREF v AS BYTE)

' ========================================================================================
' void glVertexAttribI4usvEXT (GLuint index, const GLushort *v);
' ========================================================================================
DECLARE SUB glVertexAttribI4usvEXT (BYVAL dwIndex AS DWORD, BYREF v AS WORD)

' ========================================================================================
' void glVertexAttribIPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribIPointerEXT (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glGetVertexAttribIivEXT (GLuint index, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribIivEXT (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetVertexAttribIuivEXT (GLuint index, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribIuivEXT (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_gpu_shader4)
'%GL_EXT_gpu_shader4 = 1

' ========================================================================================
' void glGetUniformuivEXT (GLuint program, GLint location, GLuint *params);
' ========================================================================================
DECLARE SUB glGetUniformuivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYREF params AS DWORD)

' ========================================================================================
' void glBindFragDataLocationEXT (GLuint program, GLuint color, const GLchar *name);
' ========================================================================================
DECLARE SUB glBindFragDataLocationEXT (BYVAL dwProgram AS DWORD, BYVAL dwColor AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' GLint glGetFragDataLocationEXT (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetFragDataLocationEXT (BYVAL dwProgram AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' GLAPI void APIENTRY glUniform1uiEXT (GLint, GLuint);
' typedef void (APIENTRYP PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
' ========================================================================================
DECLARE SUB glUniform1uiEXT (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD)

' ========================================================================================
' void glUniform2uiEXT (GLint location, GLuint v0, GLuint v1);
' ========================================================================================
DECLARE SUB glUniform2uiEXT (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD)

' ========================================================================================
' void glUniform3uiEXT (GLint location, GLuint v0, GLuint v1, GLuint v2);
' ========================================================================================
DECLARE SUB glUniform3uiEXT (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD)

' ========================================================================================
' void glUniform4uiEXT (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
' ========================================================================================
DECLARE SUB glUniform4uiEXT (BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD, BYVAL v3 AS DWORD)

' ========================================================================================
' void glUniform1uivEXT (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform1uivEXT (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glUniform2uivEXT (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform2uivEXT (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glUniform3uivEXT (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform3uivEXT (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glUniform4uivEXT (GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glUniform4uivEXT (BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_draw_instanced)
'%GL_EXT_draw_instanced = 1

' ========================================================================================
' void glDrawArraysInstancedEXT (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
' ========================================================================================
DECLARE SUB glDrawArraysInstancedEXT (BYVAL dwMode AS DWORD, BYVAL nStart AS LONG, BYVAL nCount AS LONG, BYVAL primcount AS LONG)

' ========================================================================================
' void glDrawElementsInstancedEXT (GLenum mode, GLsizei count, GLenum type,
' const GLvoid *indices, GLsizei primcount);
' ========================================================================================
DECLARE SUB glDrawElementsInstancedEXT (BYVAL dwMode AS DWORD, BYVAL nCount AS LONG, BYVAL dwType AS DWORD, BYVAL indices AS DWORD, BYVAL primcount AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_packed_float)
'%GL_EXT_packed_float = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_array)
'%GL_EXT_texture_array = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_buffer_object)
'%GL_EXT_texture_buffer_object = 1

' ========================================================================================
' void glTexBufferEXT (GLenum target, GLenum internalformat, GLuint buffer);
' ========================================================================================
DECLARE SUB glTexBufferEXT (BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL buffer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_compression_latc)
'%GL_EXT_texture_compression_latc = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_compression_rgtc)
'%GL_EXT_texture_compression_rgtc = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_shared_exponent)
'%GL_EXT_texture_shared_exponent = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_depth_buffer_float)
'%GL_NV_depth_buffer_float = 1

' ========================================================================================
' void glDepthRangedNV (GLdouble zNear, GLdouble zFar);
' ========================================================================================
DECLARE SUB glDepthRangedNV (BYVAL zNear AS DOUBLE, BYVAL zFar AS DOUBLE)

' ========================================================================================
' void glClearDepthdNV (GLdouble depth);
' ========================================================================================
DECLARE SUB glClearDepthdNV (BYVAL depth AS DOUBLE)

' ========================================================================================
' void glDepthBoundsdNV (GLdouble zmin, GLdouble zmax);
' ========================================================================================
DECLARE SUB glDepthBoundsdNV (BYVAL zmin AS DOUBLE, BYVAL zmax AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_NV_fragment_program4)
'%GL_NV_fragment_program4 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_framebuffer_multisample_coverage)
'%GL_NV_framebuffer_multisample_coverage = 1

' ========================================================================================
' void glRenderbufferStorageMultisampleCoverageNV (GLenum target, GLsizei coverageSamples,
' GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glRenderbufferStorageMultisampleCoverageNV (BYVAL dwTarget AS DWORD, BYVAL coverageSamples AS LONG, BYVAL colorSamples AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_framebuffer_sRGB)
'%GL_EXT_framebuffer_sRGB = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_geometry_shader4)
'%GL_NV_geometry_shader4 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_parameter_buffer_object)
'%GL_NV_parameter_buffer_object = 1

' ========================================================================================
' GLAPI void APIENTRY glProgramBufferParametersfvNV (GLenum target, GLuint bindingIndex,
' GLuint wordIndex, GLsizei count, const GLfloat *params);
' ========================================================================================
DECLARE SUB glProgramBufferParametersfvNV (BYVAL dwTarget AS DWORD, BYVAL bindingIndex AS DWORD, BYVAL wordIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS SINGLE)

' ========================================================================================
' void glProgramBufferParametersIivNV (GLenum target, GLuint bindingIndex, GLuint wordIndex,
' GLsizei count, const GLint *params);
' ========================================================================================
DECLARE SUB glProgramBufferParametersIivNV (BYVAL dwTarget AS DWORD, BYVAL bindingIndex AS DWORD, BYVAL wordIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS LONG)

' ========================================================================================
' void glProgramBufferParametersIuivNV (GLenum target, GLuint bindingIndex, GLuint wordIndex,
' GLsizei count, const GLuint *params);
' ========================================================================================
DECLARE SUB glProgramBufferParametersIuivNV (BYVAL dwTarget AS DWORD, BYVAL bindingIndex AS DWORD, BYVAL wordIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_draw_buffers2)
'%GL_EXT_draw_buffers2 = 1

' ========================================================================================
' void glColorMaskIndexedEXT (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
' ========================================================================================
DECLARE SUB glColorMaskIndexedEXT (BYVAL dwIndex AS DWORD, BYVAL r AS BYTE, BYVAL g AS BYTE, BYVAL b AS BYTE, BYVAL a AS BYTE)

' ========================================================================================
' void glGetBooleanIndexedvEXT (GLenum target, GLuint index, GLboolean *data);
' ========================================================================================
DECLARE SUB glGetBooleanIndexedvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF pData AS BYTE)

' ========================================================================================
' void glGetIntegerIndexedvEXT (GLenum target, GLuint index, GLint *data);
' ========================================================================================
DECLARE SUB glGetIntegerIndexedvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF pData AS LONG)

' ========================================================================================
' void glEnableIndexedEXT (GLenum target, GLuint index);
' ========================================================================================
DECLARE SUB glEnableIndexedEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' void glDisableIndexedEXT (GLenum target, GLuint index);
' ========================================================================================
DECLARE SUB glDisableIndexedEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' GLboolean glIsEnabledIndexedEXT (GLenum target, GLuint index);
' ========================================================================================
DECLARE FUNCTION glIsEnabledIndexedEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD) AS BYTE

'#ENDIF

'#IF NOT %DEF(%GL_NV_transform_feedback)
'%GL_NV_transform_feedback = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glBeginTransformFeedbackNV (GLenum primitiveMode);
' ========================================================================================
DECLARE SUB glBeginTransformFeedbackNV (BYVAL primitiveMode AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glEndTransformFeedbackNV (void);
' typedef void (APIENTRYP PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
' ========================================================================================
DECLARE SUB glEndTransformFeedbackNV

' ========================================================================================
' void glTransformFeedbackAttribsNV (GLuint count, const GLint *attribs, GLenum bufferMode);
' ========================================================================================
DECLARE SUB glTransformFeedbackAttribsNV (BYVAL dwcount AS DWORD, BYREF attribs AS LONG, BYVAL bufferMode AS DWORD)

' ========================================================================================
' void glBindBufferRangeNV (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glBindBufferRangeNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG)

' ========================================================================================
' void glBindBufferOffsetNV (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
' ========================================================================================
DECLARE SUB glBindBufferOffsetNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD, BYVAL poffset AS LONG)

' ========================================================================================
' void glBindBufferBaseNV (GLenum target, GLuint index, GLuint buffer);
' ========================================================================================
DECLARE SUB glBindBufferBaseNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD)

' ========================================================================================
' void glTransformFeedbackVaryingsNV (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
' ========================================================================================
DECLARE SUB glTransformFeedbackVaryingsNV (BYVAL dwProgram AS DWORD, BYVAL nCount AS LONG, BYREF locations AS LONG, BYVAL bufferMode AS DWORD)

' ========================================================================================
' void glActiveVaryingNV (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE SUB glActiveVaryingNV (BYVAL dwProgram AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' GLint glGetVaryingLocationNV (GLuint program, const GLchar *name);
' ========================================================================================
DECLARE FUNCTION glGetVaryingLocationNV (BYVAL dwProgram AS DWORD, BYREF szName AS ASCIIZ) AS LONG

' ========================================================================================
' void glGetActiveVaryingNV (GLuint program, GLuint index, GLsizei bufSize,
' GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
' ========================================================================================
DECLARE SUB glGetActiveVaryingNV (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF nSize AS LONG, BYREF dwType AS DWORD, BYREF szName AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glGetTransformFeedbackVaryingNV (GLuint, GLuint, GLint *);
' typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
' ========================================================================================
DECLARE SUB glGetTransformFeedbackVaryingNV (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYREF location AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_bindable_uniform)
'%GL_EXT_bindable_uniform = 1

' ========================================================================================
' void glUniformBufferEXT (GLuint program, GLint location, GLuint buffer);
' ========================================================================================
DECLARE SUB glUniformBufferEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL buffer AS DWORD)

' ========================================================================================
' GLint glGetUniformBufferSizeEXT (GLuint program, GLint location);
' ========================================================================================
DECLARE FUNCTION glGetUniformBufferSizeEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG) AS LONG

' ========================================================================================
' GLintptr glGetUniformOffsetEXT (GLuint program, GLint location);
' ========================================================================================
DECLARE FUNCTION glGetUniformOffsetEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG) AS LONG

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_integer)
'%GL_EXT_texture_integer = 1
'#IF %DEF(%GL_GLEXT_PROTOTYPES)

' ========================================================================================
' void glTexParameterIivEXT (GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glTexParameterIivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glTexParameterIuivEXT (GLenum target, GLenum pname, const GLuint *params);
' ========================================================================================
DECLARE SUB glTexParameterIuivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glGetTexParameterIivEXT (GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetTexParameterIivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetTexParameterIuivEXT (GLenum target, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetTexParameterIuivEXT (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glClearColorIiEXT (GLint red, GLint green, GLint blue, GLint alpha);
' ========================================================================================
DECLARE SUB glClearColorIiEXT (BYVAL red AS LONG, BYVAL green AS LONG, BYVAL blue AS LONG, BYVAL alpha AS LONG)

' ========================================================================================
' void glClearColorIuiEXT (GLuint red, GLuint green, GLuint blue, GLuint alpha);
' ========================================================================================
DECLARE SUB glClearColorIuiEXT (BYVAL red AS DWORD, BYVAL green AS DWORD, BYVAL blue AS DWORD, BYVAL alpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_GREMEDY_frame_terminator)
'%GL_GREMEDY_frame_terminator = 1

' ========================================================================================
' GLAPI void APIENTRY glFrameTerminatorGREMEDY (void);
' typedef void (APIENTRYP PFNGLFRAMETERMINATORGREMEDYPROC) (void);
' ========================================================================================
DECLARE SUB glFrameTerminatorGREMEDY

'#ENDIF

'#IF NOT %DEF(%GL_NV_conditional_render)
'%GL_NV_conditional_render = 1

' ========================================================================================
' void glBeginConditionalRenderNV (GLuint id, GLenum mode);
' ========================================================================================
DECLARE SUB glBeginConditionalRenderNV (BYVAL dwId AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' void glEndConditionalRenderNV (void);
' ========================================================================================
DECLARE SUB glEndConditionalRenderNV

'#ENDIF

'#IF NOT %DEF(%GL_NV_present_video)
'%GL_NV_present_video = 1

' ========================================================================================
' void APIENTRY glPresentFrameKeyedNV (GLuint video_slot, GLuint64EXT minPresentTime,
' GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0,
' GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
' ========================================================================================
DECLARE SUB glPresentFrameKeyedNV (BYVAL video_slot AS DWORD, BYVAL minPresentTime AS QUAD, BYVAL beginPresentTimeId AS DWORD, BYVAL presentDurationId AS DWORD, BYVAL dwType AS DWORD, _
   BYVAL target0 AS DWORD, BYVAL fill0 AS DWORD, BYVAL key0 AS DWORD, BYVAL target1 AS DWORD, BYVAL fill1 AS DWORD, BYVAL key1 AS DWORD)

' ========================================================================================
' void APIENTRY glPresentFrameDualFillNV (GLuint video_slot, GLuint64EXT minPresentTime,
' GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0,
' GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
' ========================================================================================
DECLARE SUB glPresentFrameDualFillNV (BYVAL video_slot AS DWORD, BYVAL minPresentTime AS QUAD, BYVAL beginPresentTimeId AS DWORD, BYVAL presentDurationId AS DWORD, BYVAL dwType AS DWORD, _
   BYVAL target0 AS DWORD, BYVAL fill0 AS DWORD, BYVAL target1 AS DWORD, BYVAL fill1 AS DWORD, BYVAL target2 AS DWORD, BYVAL fill2 AS DWORD, BYVAL target3 AS DWORD, BYVAL fill3 AS DWORD)

' ========================================================================================
' void APIENTRY glGetVideoivNV (GLuint video_slot, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVideoivNV (BYVAL video_slot AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void APIENTRY glGetVideouivNV (GLuint video_slot, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetVideouivNV (BYVAL video_slot AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void APIENTRY glGetVideoi64vNV (GLuint video_slot, GLenum pname, GLint64EXT *params);
' ========================================================================================
DECLARE SUB glGetVideoi64vNV (BYVAL video_slot AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' void APIENTRY glGetVideoui64vNV (GLuint video_slot, GLenum pname, GLuint64EXT *params);
' ========================================================================================
DECLARE SUB glGetVideoui64vNV (BYVAL video_slot AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_transform_feedback)
'%GL_EXT_transform_feedback = 1

' ========================================================================================
' void glBeginTransformFeedbackEXT (GLenum primitiveMode);
' ========================================================================================
DECLARE SUB glBeginTransformFeedbackEXT (BYVAL primitiveMode AS DWORD)

' ========================================================================================
' void glEndTransformFeedbackEXT (void);
' ========================================================================================
DECLARE SUB glEndTransformFeedbackEXT

' ========================================================================================
' void glBindBufferRangeEXT (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glBindBufferRangeEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG)

' ========================================================================================
' void glBindBufferOffsetEXT (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
' ========================================================================================
DECLARE SUB glBindBufferOffsetEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD, BYVAL poffset AS LONG)

' ========================================================================================
' void glBindBufferBaseEXT (GLenum target, GLuint index, GLuint buffer);
' ========================================================================================
DECLARE SUB glBindBufferBaseEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL buffer AS DWORD)

' ========================================================================================
' void glTransformFeedbackVaryingsEXT (GLuint program, GLsizei count,
' const GLint *, GLenum bufferMode);
' ========================================================================================
DECLARE SUB glTransformFeedbackVaryingsEXT (BYVAL dwProgram AS DWORD, BYVAL nCount AS LONG, BYREF locations AS LONG, BYVAL bufferMode AS DWORD)

' ========================================================================================
' void glGetTransformFeedbackVaryingEXT (GLuint program, GLuint index, GLint *location);
' ========================================================================================
DECLARE SUB glGetTransformFeedbackVaryingEXT (BYVAL dwProgram AS DWORD, BYVAL dwIndex AS DWORD, BYREF location AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_direct_state_access)
'%GL_EXT_direct_state_access = 1

' ========================================================================================
' void glClientAttribDefaultEXT (GLbitfield mask);
' ========================================================================================
DECLARE SUB glClientAttribDefaultEXT (BYVAL dwMask AS DWORD)

' ========================================================================================
' void glPushClientAttribDefaultEXT (GLbitfield mask);
' ========================================================================================
DECLARE SUB glPushClientAttribDefaultEXT (BYVAL dwMask AS DWORD)

' ========================================================================================
' void glMatrixLoadfEXT (GLenum mode, const GLfloat *m);
' ========================================================================================
DECLARE SUB glMatrixLoadfEXT (BYVAL dwMode AS DWORD, BYREF m AS SINGLE)

' ========================================================================================
' void glMatrixLoaddEXT (GLenum mode, const GLdouble *m);
' ========================================================================================
DECLARE SUB glMatrixLoaddEXT (BYVAL dwMode AS DWORD, BYREF m AS DOUBLE)

' ========================================================================================
' void glMatrixMultfEXT (GLenum mode, const GLfloat *m);
' ========================================================================================
DECLARE SUB glMatrixMultfEXT (BYVAL dwMode AS DWORD, BYREF m AS SINGLE)

' ========================================================================================
' void glMatrixMultdEXT (GLenum mode, const GLdouble *m);
' ========================================================================================
DECLARE SUB glMatrixMultdEXT (BYVAL dwMode AS DWORD, BYREF m AS DOUBLE)

' ========================================================================================
' void glMatrixLoadIdentityEXT (GLenum mode);
' ========================================================================================
DECLARE SUB glMatrixLoadIdentityEXT (BYVAL dwMode AS DWORD)

' ========================================================================================
' void glMatrixRotatefEXT (GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glMatrixRotatefEXT (BYVAL dwMode AS DWORD, BYVAL angle AS SINGLE, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glMatrixRotatedEXT (GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glMatrixRotatedEXT (BYVAL dwMode AS DWORD, BYVAL angle AS DOUBLE, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glMatrixScalefEXT (GLenum mode, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glMatrixScalefEXT (BYVAL dwMode AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glMatrixScaledEXT (GLenum mode, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glMatrixScaledEXT (BYVAL dwMode AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glMatrixTranslatefEXT (GLenum mode, GLfloat x, GLfloat y, GLfloat z);
' ========================================================================================
DECLARE SUB glMatrixTranslatefEXT (BYVAL dwMode AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE)

' ========================================================================================
' void glMatrixTranslatedEXT (GLenum mode, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glMatrixTranslatedEXT (BYVAL dwMode AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void glMatrixFrustumEXT (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom,
' GLdouble top, GLdouble zNear, GLdouble zFar);
' ========================================================================================
DECLARE SUB glMatrixFrustumEXT (BYVAL dwMode AS DWORD, BYVAL nLeft AS DOUBLE, BYVAL nRight AS DOUBLE, BYVAL nBottom AS DOUBLE, BYVAL nTop AS DOUBLE, BYVAL zNear AS DOUBLE, BYVAL zFar AS DOUBLE)

' ========================================================================================
' void glMatrixOrthoEXT (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom,
' GLdouble top, GLdouble zNear, GLdouble zFar);
' ========================================================================================
DECLARE SUB glMatrixOrthoEXT (BYVAL dwMode AS DWORD, BYVAL nLeft AS DOUBLE, BYVAL nRight AS DOUBLE, BYVAL nBottom AS DOUBLE, BYVAL nTop AS DOUBLE, BYVAL zNear AS DOUBLE, BYVAL zFar AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glMatrixPopEXT (GLenum);
' typedef void (APIENTRYP PFNGLMATRIXPOPEXTPROC) (GLenum mode);
' ========================================================================================
DECLARE SUB glMatrixPopEXT (BYVAL dwMode AS DWORD)

' ========================================================================================
' void glMatrixPushEXT (GLenum mode);
' ========================================================================================
DECLARE SUB glMatrixPushEXT (BYVAL dwMode AS DWORD)

' ========================================================================================
' void glMatrixLoadTransposefEXT (GLenum mode, const GLfloat *m);
' ========================================================================================
DECLARE SUB glMatrixLoadTransposefEXT (BYVAL dwMode AS DWORD, BYREF m AS SINGLE)

' ========================================================================================
' void glMatrixLoadTransposedEXT (GLenum mode, const GLdouble *m);
' ========================================================================================
DECLARE SUB glMatrixLoadTransposedEXT (BYVAL dwMode AS DWORD, BYREF m AS DOUBLE)

' ========================================================================================
' void glMatrixMultTransposefEXT (GLenum mode, const GLfloat *m);
' ========================================================================================
DECLARE SUB glMatrixMultTransposefEXT (BYVAL dwMode AS DWORD, BYREF m AS SINGLE)

' ========================================================================================
' void glMatrixMultTransposedEXT (GLenum mode, const GLdouble *m);
' ========================================================================================
DECLARE SUB glMatrixMultTransposedEXT (BYVAL dwMode AS DWORD, BYREF m AS DOUBLE)

' ========================================================================================
' void glTextureParameterfEXT (GLuint texture, GLenum target, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glTextureParameterfEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glTextureParameterfvEXT (GLuint texture, GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glTextureParameterfvEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glTextureParameteriEXT (GLuint texture, GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glTextureParameteriEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glTextureParameterivEXT (GLuint texture, GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glTextureParameterivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glTextureImage1DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type,
' const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTextureImage1DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, _
   BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTextureImage2DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLint border,
' GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTextureImage2DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, _
   BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset,
' GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTextureSubImage1DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset,
' GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTextureSubImage2DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
   BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glCopyTextureImage1DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
' ========================================================================================
DECLARE SUB glCopyTextureImage1DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG)

' ========================================================================================
' void glCopyTextureImage2DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
' ========================================================================================
DECLARE SUB glCopyTextureImage2DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG)

' ========================================================================================
' void glCopyTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level,
' GLint xoffset, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyTextureSubImage1DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' void glCopyTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyTextureSubImage2DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glGetTextureImageEXT (GLuint texture, GLenum target, GLint level, GLenum format,
' GLenum type, GLvoid *pixels);
' ========================================================================================
DECLARE SUB glGetTextureImageEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, _
   BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glGetTextureParameterfvEXT (GLuint texture, GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetTextureParameterfvEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetTextureParameterivEXT (GLuint texture, GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetTextureParameterivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetTextureLevelParameterfvEXT (GLuint texture, GLenum target, GLint level,
' GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetTextureLevelParameterfvEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetTextureLevelParameterivEXT (GLuint texture, GLenum target, GLint level,
' GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetTextureLevelParameterivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glTextureImage3DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth,
' GLint border, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTextureImage3DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, _
   BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset,
' GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
' GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glTextureSubImage3DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nWidth AS LONG, _
   BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glCopyTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyTextureSubImage3DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, _
   BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glMultiTexParameterfEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glMultiTexParameterfEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glMultiTexParameterfvEXT (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glMultiTexParameterfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glMultiTexParameteriEXT (GLenum texunit, GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glMultiTexParameteriEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glMultiTexParameterivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glMultiTexParameterivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLint border, GLenum format,
' GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glMultiTexImage1DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, _
   BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLint border,
' GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glMultiTexImage2DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset,
' GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glMultiTexSubImage1DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format,
' GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glMultiTexSubImage2DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glCopyMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
' ========================================================================================
DECLARE SUB glCopyMultiTexImage1DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG)

' ========================================================================================
' void glCopyMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
' ========================================================================================
DECLARE SUB glCopyMultiTexImage2DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL x AS LONG, _
   BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG)

' ========================================================================================
' void glCopyMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint x, GLint y, GLsizei width);
' ========================================================================================
DECLARE SUB glCopyMultiTexSubImage1DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG)

' ========================================================================================
' void glCopyMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyMultiTexSubImage2DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, _
   BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glGetMultiTexImageEXT (GLenum texunit, GLenum target, GLint level, GLenum format,
' GLenum type, GLvoid *pixels);
' ========================================================================================
DECLARE SUB glGetMultiTexImageEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glGetMultiTexParameterfvEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMultiTexParameterfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMultiTexParameterivEXT (GLenum texunit, GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMultiTexParameterivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMultiTexLevelParameterfvEXT (GLenum texunit, GLenum target, GLint level,
' GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMultiTexLevelParameterfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMultiTexLevelParameterivEXT (GLenum texunit, GLenum target, GLint level,
' GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMultiTexLevelParameterivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth,
' GLint border, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glMultiTexImage3DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, _
   BYVAL nBorder AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height,
' GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
' ========================================================================================
DECLARE SUB glMultiTexSubImage3DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, BYVAL nWidth AS LONG, _
   BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL dwType AS DWORD, BYVAL pPixels AS DWORD)

' ========================================================================================
' void glCopyMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glCopyMultiTexSubImage3DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, _
   BYVAL x AS LONG, BYVAL y AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glBindMultiTextureEXT (GLenum, GLenum, GLuint);
' typedef void (APIENTRYP PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
' ========================================================================================
DECLARE SUB glBindMultiTextureEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwTexture AS DWORD)

' ========================================================================================
' void glEnableClientStateIndexedEXT (GLenum array, GLuint index);
' ========================================================================================
DECLARE SUB glEnableClientStateIndexedEXT (BYVAL dwArray AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' void glDisableClientStateIndexedEXT (GLenum array, GLuint index);
' ========================================================================================
DECLARE SUB glDisableClientStateIndexedEXT (BYVAL dwArray AS DWORD, BYVAL dwIndex AS DWORD)

' ========================================================================================
' void glMultiTexCoordPointerEXT (GLenum texunit, GLint size, GLenum type, GLsizei stride,
' const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glMultiTexCoordPointerEXT (BYVAL dwTexunit AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL nStride AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void glMultiTexEnvfEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glMultiTexEnvfEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glMultiTexEnvfvEXT (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glMultiTexEnvfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glMultiTexEnviEXT (GLenum texunit, GLenum target, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glMultiTexEnviEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glMultiTexEnvivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glMultiTexEnvivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glMultiTexGendEXT (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
' ========================================================================================
DECLARE SUB glMultiTexGendEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL param AS DOUBLE)

' ========================================================================================
' void glMultiTexGendvEXT (GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params);
' ========================================================================================
DECLARE SUB glMultiTexGendvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF param AS DOUBLE)

' ========================================================================================
' void glMultiTexGenfEXT (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
' ========================================================================================
DECLARE SUB glMultiTexGenfEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS  DWORD, BYVAL param AS SINGLE)

' ========================================================================================
' void glMultiTexGenfvEXT (GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glMultiTexGenfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glMultiTexGeniEXT (GLenum texunit, GLenum coord, GLenum pname, GLint param);
' ========================================================================================
DECLARE SUB glMultiTexGeniEXT (BYVAL dwTexunit AS DWORD, BYVAL dwCoord AS DWORD, BYVAL pname AS DWORD, BYVAL param AS LONG)

' ========================================================================================
' void glMultiTexGenivEXT (GLenum texunit, GLenum coord, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glMultiTexGenivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwCoord AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMultiTexEnvfvEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMultiTexEnvfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMultiTexEnvivEXT (GLenum texunit, GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMultiTexEnvivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMultiTexGendvEXT (GLenum texunit, GLenum coord, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetMultiTexGendvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwCoord AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetMultiTexGenfvEXT (GLenum texunit, GLenum coord, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetMultiTexGenfvEXT (BYVAL dwTexunit AS DWORD, BYVAL dwCoord AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetMultiTexGenivEXT (GLenum texunit, GLenum coord, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMultiTexGenivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwCoord AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetFloatIndexedvEXT (GLenum target, GLuint index, GLfloat *data);
' ========================================================================================
DECLARE SUB glGetFloatIndexedvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF pData AS SINGLE)

' ========================================================================================
' void glGetDoubleIndexedvEXT (GLenum target, GLuint index, GLdouble *data);
' ========================================================================================
DECLARE SUB glGetDoubleIndexedvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF pData AS DOUBLE)

' ========================================================================================
' void glGetPointerIndexedvEXT (GLenum target, GLuint index, GLvoid* *data);
' ========================================================================================
DECLARE SUB glGetPointerIndexedvEXT (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' void glCompressedTextureImage3DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border,
' GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedTextureImage3DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedTextureImage2DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize,
' const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedTextureImage2DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedTextureImage1DEXT (GLuint texture, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedTextureImage1DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height,
' GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedTextureSubImage3DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format,
' GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedTextureSubImage2DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level,
' GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedTextureSubImage1DEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, _
   BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glGetCompressedTextureImageEXT (GLuint texture, GLenum target, GLint lod, GLvoid *img);
' ========================================================================================
DECLARE SUB glGetCompressedTextureImageEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL lod AS LONG, BYVAL pImg AS DWORD)

' ========================================================================================
' void glCompressedMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border,
' GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedMultiTexImage3DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, _
   BYVAL nDepth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize,
' const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedMultiTexImage2DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level,
' GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedMultiTexImage1DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nBorder AS LONG, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void (glCompressedMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height,
' GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedMultiTexSubImage3DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, BYVAL zoffset AS LONG, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glCompressedMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format,
' GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedMultiTexSubImage2DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL yoffset AS LONG, _
   BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)
' ========================================================================================

' ========================================================================================
' void glCompressedMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level,
' GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
' ========================================================================================
DECLARE SUB glCompressedMultiTexSubImage1DEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL nLevel AS LONG, BYVAL xoffset AS LONG, BYVAL nWidth AS LONG, BYVAL dwFormat AS DWORD, BYVAL imageSize AS LONG, BYVAL pbits AS DWORD)

' ========================================================================================
' void glGetCompressedMultiTexImageEXT (GLenum texunit, GLenum target, GLint lod, GLvoid *img);
' ========================================================================================
DECLARE SUB glGetCompressedMultiTexImageEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL lod AS LONG, BYVAL pImg AS DWORD)

' ========================================================================================
' void glNamedProgramStringEXT (GLuint program, GLenum target, GLenum format,
' GLsizei len, const GLvoid *string);
' ========================================================================================
DECLARE SUB glNamedProgramStringEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwFormat AS DWORD, BYVAL nLen AS LONG, BYVAL pstring AS DWORD)

' ========================================================================================
' void glNamedProgramLocalParameter4dEXT (GLuint program, GLenum target, GLuint index,
' GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameter4dEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void glNamedProgramLocalParameter4dvEXT (GLuint program, GLenum target, GLuint index,
' const GLdouble *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameter4dvEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glNamedProgramLocalParameter4fEXT (GLuint program, GLenum target, GLuint index,
' GLfloat x, GLfloat y, GLfloat z, GLfloat w);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameter4fEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE, BYVAL z AS SINGLE, BYVAL w AS SINGLE)

' ========================================================================================
' void glNamedProgramLocalParameter4fvEXT (GLuint program, GLenum target, GLuint index,
' const GLfloat *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameter4fvEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetNamedProgramLocalParameterdvEXT (GLuint program, GLenum target, GLuint index, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetNamedProgramLocalParameterdvEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' void glGetNamedProgramLocalParameterfvEXT (GLuint program, GLenum target, GLuint index, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetNamedProgramLocalParameterfvEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void glGetNamedProgramivEXT (GLuint program, GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedProgramivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetNamedProgramStringEXT (GLuint program, GLenum target, GLenum pname, GLvoid *string);
' ========================================================================================
DECLARE SUB glGetNamedProgramStringEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL pstring AS DWORD)

' ========================================================================================
' void glNamedProgramLocalParameters4fvEXT (GLuint program, GLenum target, GLuint index,
' GLsizei count, const GLfloat *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameters4fvEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS SINGLE)

' ========================================================================================
' void glNamedProgramLocalParameterI4iEXT (GLuint program, GLenum target, GLuint index,
' GLint x, GLint y, GLint z, GLint w);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameterI4iEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS LONG, BYVAL y AS LONG, BYVAL z AS LONG, BYVAL w AS LONG)

' ========================================================================================
' void glNamedProgramLocalParameterI4ivEXT (GLuint program, GLenum target, GLuint index, const GLint *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameterI4ivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glNamedProgramLocalParametersI4ivEXT (GLuint program, GLenum target, GLuint index,
' GLsizei count, const GLint *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParametersI4ivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS LONG)

' ========================================================================================
' void glNamedProgramLocalParameterI4uiEXT (GLuint program, GLenum target, GLuint index,
' GLuint x, GLuint y, GLuint z, GLuint w);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameterI4uiEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL x AS DWORD, BYVAL y AS DWORD, BYVAL z AS DWORD, BYVAL w AS DWORD)

' ========================================================================================
' void glNamedProgramLocalParameterI4uivEXT (GLuint program, GLenum target, GLuint index, const GLuint *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParameterI4uivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glNamedProgramLocalParametersI4uivEXT (GLuint program, GLenum target, GLuint index,
' GLsizei count, const GLuint *params);
' ========================================================================================
DECLARE SUB glNamedProgramLocalParametersI4uivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nCount AS LONG, BYREF params AS DWORD)

' ========================================================================================
' void glGetNamedProgramLocalParameterIivEXT (GLuint program, GLenum target, GLuint index, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedProgramLocalParameterIivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetNamedProgramLocalParameterIuivEXT (GLuint program, GLenum target, GLuint index, GLuint *params);
' ========================================================================================
DECLARE SUB glGetNamedProgramLocalParameterIuivEXT (BYVAL dwProgram AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glTextureParameterIivEXT (GLuint texture, GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glTextureParameterIivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glTextureParameterIuivEXT (GLuint texture, GLenum target, GLenum pname, const GLuint *params);
' ========================================================================================
DECLARE SUB glTextureParameterIuivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glGetTextureParameterIivEXT (GLuint texture, GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetTextureParameterIivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetTextureParameterIuivEXT (GLuint texture, GLenum target, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetTextureParameterIuivEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glMultiTexParameterIivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glMultiTexParameterIivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glMultiTexParameterIuivEXT (GLenum texunit, GLenum target, GLenum pname, const GLuint *params);
' ========================================================================================
DECLARE SUB glMultiTexParameterIuivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glGetMultiTexParameterIivEXT (GLenum texunit, GLenum target, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetMultiTexParameterIivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetMultiTexParameterIuivEXT (GLenum texunit, GLenum target, GLenum pname, GLuint *params);
' ========================================================================================
DECLARE SUB glGetMultiTexParameterIuivEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' void glProgramUniform1fEXT (GLuint program, GLint location, GLfloat v0);
' ========================================================================================
DECLARE SUB glProgramUniform1fEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE)

' ========================================================================================
' void glProgramUniform2fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1);
' ========================================================================================
DECLARE SUB glProgramUniform2fEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE)

' ========================================================================================
' void glProgramUniform3fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
' ========================================================================================
DECLARE SUB glProgramUniform3fEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE)

' ========================================================================================
' void glProgramUniform4fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
' ========================================================================================
DECLARE SUB glProgramUniform4fEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS SINGLE, BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, BYVAL v3 AS SINGLE)

' ========================================================================================
' void glProgramUniform1iEXT (GLuint program, GLint location, GLint v0);
' ========================================================================================
DECLARE SUB glProgramUniform1iEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2iEXT (GLuint, GLint, GLint, GLint);
' typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location,
' GLint v0, GLint v1);
' ========================================================================================
DECLARE SUB glProgramUniform2iEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG)

' ========================================================================================
' void glProgramUniform3iEXT (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
' ========================================================================================
DECLARE SUB glProgramUniform3iEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG)

' ========================================================================================
' void glProgramUniform4iEXT (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
' ========================================================================================
DECLARE SUB glProgramUniform4iEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS LONG, BYVAL v1 AS LONG, BYVAL v2 AS LONG, BYVAL v3 AS LONG)

' ========================================================================================
' void glProgramUniform1fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform1fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniform2fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform2fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniform3fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform3fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniform4fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniform4fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniform1ivEXT (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform1ivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glProgramUniform2ivEXT (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform2ivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glProgramUniform3ivEXT (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform3ivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glProgramUniform4ivEXT (GLuint program, GLint location, GLsizei count, const GLint *value);
' ========================================================================================
DECLARE SUB glProgramUniform4ivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS LONG)

' ========================================================================================
' void glProgramUniformMatrix2fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix3fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix4fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix2x3fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x3fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix3x2fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x2fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix2x4fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x4fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix4x2fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x2fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix3x4fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x4fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniformMatrix4x3fvEXT (GLuint program, GLint location, GLsizei count,
' GLboolean transpose, const GLfloat *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x3fvEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYVAL bTranspose AS BYTE, BYREF value AS SINGLE)

' ========================================================================================
' void glProgramUniform1uiEXT (GLuint program, GLint location, GLuint v0);
' ========================================================================================
DECLARE SUB glProgramUniform1uiEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS DWORD)

' ========================================================================================
' void glProgramUniform2uiEXT (GLuint program, GLint location, GLuint v0, GLuint v1);
' ========================================================================================
DECLARE SUB glProgramUniform2uiEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD)

' ========================================================================================
' void glProgramUniform3uiEXT (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
' ========================================================================================
DECLARE SUB glProgramUniform3uiEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD)

' ========================================================================================
' void glProgramUniform4uiEXT (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
' ========================================================================================
DECLARE SUB glProgramUniform4uiEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL v0 AS DWORD, BYVAL v1 AS DWORD, BYVAL v2 AS DWORD, BYVAL v3 AS DWORD)

' ========================================================================================
' void glProgramUniform1uivEXT (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform1uivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glProgramUniform2uivEXT (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform2uivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glProgramUniform3uivEXT (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform3uivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glProgramUniform4uivEXT (GLuint program, GLint location, GLsizei count, const GLuint *value);
' ========================================================================================
DECLARE SUB glProgramUniform4uivEXT (BYVAL dwProgram AS DWORD, BYVAL nLocation AS LONG, BYVAL nCount AS LONG, BYREF value AS DWORD)

' ========================================================================================
' void glNamedBufferDataEXT (GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
' ========================================================================================
DECLARE SUB glNamedBufferDataEXT (BYVAL buffer AS DWORD, BYVAL dwSize AS DWORD, BYVAL pData AS DWORD, BYVAL dwUsage AS DWORD)

' ========================================================================================
' void glNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
' ========================================================================================
DECLARE SUB glNamedBufferSubDataEXT (BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' GLvoid* glMapNamedBufferEXT (GLuint buffer, GLenum access);
' ========================================================================================
DECLARE FUNCTION glMapNamedBufferEXT (BYVAL buffer AS DWORD, BYVAL dwAccess AS DWORD) AS DWORD

' ========================================================================================
' GLboolean glUnmapNamedBufferEXT (GLuint buffer);
' ========================================================================================
DECLARE FUNCTION glUnmapNamedBufferEXT (BYVAL buffer AS DWORD) AS BYTE

' ========================================================================================
' GLvoid* APIENTRY glMapNamedBufferRangeEXT (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
' ========================================================================================
DECLARE FUNCTION glMapNamedBufferRangeEXT (BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL plength AS LONG, BYVAL dwAccess AS DWORD) AS DWORD

' ========================================================================================
' void APIENTRY glFlushMappedNamedBufferRangeEXT (GLuint buffer, GLintptr offset, GLsizeiptr length);
' ========================================================================================
DECLARE SUB glFlushMappedNamedBufferRangeEXT (BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL plength AS LONG)

' ========================================================================================
' void APIENTRY glNamedCopyBufferSubDataEXT (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
' ========================================================================================
DECLARE SUB glNamedCopyBufferSubDataEXT (BYVAL readBuffer AS DWORD, BYVAL writeBuffer AS DWORD, BYVAL readOffset AS LONG, BYVAL writeOffset AS LONG, BYVAL psize AS LONG)

' ========================================================================================
' void glGetNamedBufferParameterivEXT (GLuint buffer, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedBufferParameterivEXT (BYVAL buffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGetNamedBufferPointervEXT (GLuint buffer, GLenum pname, GLvoid* *params);
' ========================================================================================
DECLARE SUB glGetNamedBufferPointervEXT (BYVAL buffer AS DWORD, BYVAL pname AS DWORD, BYVAL params AS DWORD)

' ========================================================================================
' void glGetNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
' ========================================================================================
DECLARE SUB glGetNamedBufferSubDataEXT (BYVAL buffer AS DWORD, BYVAL poffset AS LONG, BYVAL psize AS LONG, BYVAL pData AS DWORD)

' ========================================================================================
' void glTextureBufferEXT (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
' ========================================================================================
DECLARE SUB glTextureBufferEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL buffer AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glMultiTexBufferEXT (GLenum, GLenum, GLenum, GLuint);
' typedef void (APIENTRYP PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target,
' GLenum internalformat, GLuint buffer);
' ========================================================================================
DECLARE SUB glMultiTexBufferEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL internalformat AS DWORD, BYVAL buffer AS DWORD)

' ========================================================================================
' void glNamedRenderbufferStorageEXT (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glNamedRenderbufferStorageEXT (BYVAL renderbuffer AS DWORD, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glGetNamedRenderbufferParameterivEXT (GLuint renderbuffer, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedRenderbufferParameterivEXT (BYVAL renderbuffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' GLenum glCheckNamedFramebufferStatusEXT (GLuint framebuffer, GLenum target);
' ========================================================================================
DECLARE FUNCTION glCheckNamedFramebufferStatusEXT (BYVAL framebuffer AS DWORD, BYVAL dwTarget AS DWORD) AS DWORD

' ========================================================================================
' void glNamedFramebufferTexture1DEXT (GLuint framebuffer, GLenum attachment,  GLenum textarget, GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glNamedFramebufferTexture1DEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTextarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glNamedFramebufferTexture2DEXT (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glNamedFramebufferTexture2DEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTextarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glNamedFramebufferTexture3DEXT (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
' ========================================================================================
DECLARE SUB glNamedFramebufferTexture3DEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTextarget AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL zoffset AS LONG)

' ========================================================================================
' void glNamedFramebufferRenderbufferEXT (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glNamedFramebufferRenderbufferEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL renderbuffertarget AS DWORD, BYVAL renderbuffer AS DWORD)

' ========================================================================================
' void glGetNamedFramebufferAttachmentParameterivEXT (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetNamedFramebufferAttachmentParameterivEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glGenerateTextureMipmapEXT (GLuint texture, GLenum target);
' ========================================================================================
DECLARE SUB glGenerateTextureMipmapEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD)

' ========================================================================================
' void glGenerateMultiTexMipmapEXT (GLenum texunit, GLenum target);
' ========================================================================================
DECLARE SUB glGenerateMultiTexMipmapEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD)

' ========================================================================================
' void glFramebufferDrawBufferEXT (GLuint framebuffer, GLenum mode);
' ========================================================================================
DECLARE SUB glFramebufferDrawBufferEXT (BYVAL framebuffer AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' void glFramebufferDrawBuffersEXT (GLuint framebuffer, GLsizei n, const GLenum *bufs);
' ========================================================================================
DECLARE SUB glFramebufferDrawBuffersEXT (BYVAL framebuffer AS DWORD, BYVAL n AS LONG, BYREF bufs AS DWORD)

' ========================================================================================
' void glFramebufferReadBufferEXT (GLuint framebuffer, GLenum mode);
' ========================================================================================
DECLARE SUB glFramebufferReadBufferEXT (BYVAL framebuffer AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' void glGetFramebufferParameterivEXT (GLuint framebuffer, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetFramebufferParameterivEXT (BYVAL framebuffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void glNamedRenderbufferStorageMultisampleEXT (GLuint renderbuffer, GLsizei samples,
' GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glNamedRenderbufferStorageMultisampleEXT (BYVAL renderbuffer AS DWORD, BYVAL samples AS LONG, BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glNamedRenderbufferStorageMultisampleCoverageEXT (GLuint renderbuffer,
' GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
' ========================================================================================
DECLARE SUB glNamedRenderbufferStorageMultisampleCoverageEXT (BYVAL renderbuffer AS DWORD, BYVAL coverageSamples AS LONG, BYVAL colorSamples AS LONG, _
   BYVAL internalformat AS DWORD, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG)

' ========================================================================================
' void glNamedFramebufferTextureEXT (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glNamedFramebufferTextureEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG)

' ========================================================================================
' void glNamedFramebufferTextureLayerEXT (GLuint framebuffer, GLenum attachment,
' GLuint texture, GLint level, GLint layer);
' ========================================================================================
DECLARE SUB glNamedFramebufferTextureLayerEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL nLayer AS LONG)

' ========================================================================================
' void glNamedFramebufferTextureFaceEXT (GLuint framebuffer, GLenum attachment,
' GLuint texture, GLint level, GLenum face);
' ========================================================================================
DECLARE SUB glNamedFramebufferTextureFaceEXT (BYVAL framebuffer AS DWORD, BYVAL dwAttachment AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nLevel AS LONG, BYVAL dwFace AS DWORD)

' ========================================================================================
' void glTextureRenderbufferEXT (GLuint texture, GLenum target, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glTextureRenderbufferEXT (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL renderbuffer AS DWORD)

' ========================================================================================
' void glMultiTexRenderbufferEXT (GLenum texunit, GLenum target, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glMultiTexRenderbufferEXT (BYVAL dwTexunit AS DWORD, BYVAL dwTarget AS DWORD, BYVAL renderbuffer AS DWORD)

' ========================================================================================
' void APIENTRY glProgramUniform1dEXT (GLuint program, GLint location, GLdouble x);
' ========================================================================================
DECLARE SUB glProgramUniform1dEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL x AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform2dEXT (GLuint program, GLint location, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glProgramUniform2dEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform3dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glProgramUniform3dEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform4dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glProgramUniform4dEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform1dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform1dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform2dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform2dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform3dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform3dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniform4dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniform4dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix2x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x3dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix2x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix2x4dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix3x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x2dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix3x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix3x4dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix4x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x2dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

' ========================================================================================
' void APIENTRY glProgramUniformMatrix4x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
' ========================================================================================
DECLARE SUB glProgramUniformMatrix4x3dvEXT (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYVAL transpose AS BYTE, BYREF value AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_vertex_array_bgra)
'%GL_EXT_vertex_array_bgra = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_swizzle)
'%GL_EXT_texture_swizzle = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_explicit_multisample)
'%GL_NV_explicit_multisample = 1

' ========================================================================================
' void APIENTRY glGetMultisamplefvNV (GLenum pname, GLuint index, GLfloat *val);
' ========================================================================================
DECLARE SUB glGetMultisamplefvNV (BYVAL pname AS DWORD, BYVAL dwIndex AS DWORD, BYREF value AS SINGLE)

' ========================================================================================
' void APIENTRY glSampleMaskIndexedNV (GLuint index, GLbitfield mask);
' ========================================================================================
DECLARE SUB glSampleMaskIndexedNV (BYVAL dwIndex AS DWORD, BYVAL dwMask AS DWORD)

' ========================================================================================
' void APIENTRY glTexRenderbufferNV (GLenum target, GLuint renderbuffer);
' ========================================================================================
DECLARE SUB glTexRenderbufferNV (BYVAL dwTarget AS DWORD, BYVAL renderbuffer AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_transform_feedback2)
'%GL_NV_transform_feedback2 = 1

' ========================================================================================
' void APIENTRY glBindTransformFeedbackNV (GLenum target, GLuint id);
' ========================================================================================
DECLARE SUB glBindTransformFeedbackNV (BYVAL dwTarget AS DWORD, BYVAL dwId AS DWORD)

' ========================================================================================
' void APIENTRY glDeleteTransformFeedbacksNV (GLsizei n, const GLuint *ids);
' ========================================================================================
DECLARE SUB glDeleteTransformFeedbacksNV (BYVAL n AS DWORD, BYREF ids AS DWORD)

' ========================================================================================
' void APIENTRY glGenTransformFeedbacksNV (GLsizei n, GLuint *ids);
' ========================================================================================
DECLARE SUB glGenTransformFeedbacksNV (BYVAL n AS DWORD, BYREF ids AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsTransformFeedbackNV (GLuint id);
' ========================================================================================
DECLARE FUNCTION glIsTransformFeedbackNV (BYVAL dwId AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glPauseTransformFeedbackNV (void);
' ========================================================================================
DECLARE SUB glPauseTransformFeedbackNV

' ========================================================================================
' void APIENTRY glResumeTransformFeedbackNV (void);
' ========================================================================================
DECLARE SUB glResumeTransformFeedbackNV

' ========================================================================================
' void APIENTRY glDrawTransformFeedbackNV (GLenum mode, GLuint id);
' ========================================================================================
DECLARE SUB glDrawTransformFeedbackNV (BYVAL dwMode AS DWORD, BYREF dwId AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_ATI_meminfo)
'%GL_ATI_meminfo = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_performance_monitor)
'%GL_AMD_performance_monitor = 1

' ========================================================================================
' void APIENTRY glGetPerfMonitorGroupsAMD (GLint *numGroups, GLsizei groupsSize, GLuint *groups);
' ========================================================================================
DECLARE SUB glGetPerfMonitorGroupsAMD (BYREF numGroups AS LONG, BYVAL groupsSize AS LONG, BYREF groups AS DWORD)

' ========================================================================================
' void APIENTRY glGetPerfMonitorCountersAMD (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
' ========================================================================================
DECLARE SUB glGetPerfMonitorCountersAMD (BYVAL group AS DWORD, BYREF numCounters AS LONG, BYREF maxActiveCounters AS LONG, BYVAL counterSize AS LONG, BYREF counters AS DWORD)

' ========================================================================================
' void APIENTRY glGetPerfMonitorGroupStringAMD (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
' ========================================================================================
DECLARE SUB glGetPerfMonitorGroupStringAMD (BYVAL group AS DWORD, BYREF bufSize AS LONG, BYREF nLength AS LONG, BYREF groupString AS ASCIIZ)

' ========================================================================================
' void APIENTRY glGetPerfMonitorCounterStringAMD (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
' ========================================================================================
DECLARE SUB glGetPerfMonitorCounterStringAMD (BYVAL group AS DWORD, BYVAL dwCounter AS DWORD, BYVAL bufSize AS LONG, BYREF nLength AS LONG, BYREF counterString AS ASCIIZ)

' ========================================================================================
' void APIENTRY glGetPerfMonitorCounterInfoAMD (GLuint group, GLuint counter, GLenum pname, void *data);
' ========================================================================================
DECLARE SUB glGetPerfMonitorCounterInfoAMD (BYVAL group AS DWORD, BYVAL dwCounter AS DWORD, BYVAL pname AS DWORD, BYVAL pData AS DWORD)

' ========================================================================================
' void APIENTRY glGenPerfMonitorsAMD (GLsizei n, GLuint *monitors);
' ========================================================================================
DECLARE SUB glGenPerfMonitorsAMD (BYVAL n AS LONG, BYREF monitors AS DWORD)

' ========================================================================================
' void APIENTRY glDeletePerfMonitorsAMD (GLsizei n, GLuint *monitors);
' ========================================================================================
DECLARE SUB glDeletePerfMonitorsAMD (BYVAL n AS LONG, BYREF monitors AS DWORD)

' ========================================================================================
' void APIENTRY glSelectPerfMonitorCountersAMD (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);
' ========================================================================================
DECLARE SUB glSelectPerfMonitorCountersAMD (BYVAL dwMonitor AS DWORD, BYVAL bEnable AS BYTE, BYVAL group AS DWORD, BYVAL numCounters AS LONG, BYREF counterList AS DWORD)

' ========================================================================================
' void APIENTRY glBeginPerfMonitorAMD (GLuint monitor);
' ========================================================================================
DECLARE SUB glBeginPerfMonitorAMD (BYVAL dwMonitor AS DWORD)

' ========================================================================================
' void APIENTRY glEndPerfMonitorAMD (GLuint monitor);
' ========================================================================================
DECLARE SUB glEndPerfMonitorAMD (BYVAL dwMonitor AS DWORD)

' ========================================================================================
' void APIENTRY glGetPerfMonitorCounterDataAMD (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);
' ========================================================================================
DECLARE SUB glGetPerfMonitorCounterDataAMD (BYVAL dwMonitor AS DWORD, BYVAL pname AS DWORD, BYVAL dataSize AS LONG, BYREF pData AS DWORD, BYREF bytesWritten AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_AMD_texture_texture4)
'%GL_AMD_texture_texture4 = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_vertex_shader_tessellator)
'%GL_AMD_vertex_shader_tessellator = 1

' ========================================================================================
' void APIENTRY glTessellationFactorAMD (GLfloat factor);
' ========================================================================================
DECLARE SUB glTessellationFactorAMD (BYVAL factor AS SINGLE)

' ========================================================================================
' void APIENTRY glTessellationModeAMD (GLenum mode);
' ========================================================================================
DECLARE SUB glTessellationModeAMD (BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_provoking_vertex)
'%GL_EXT_provoking_vertex = 1

' ========================================================================================
' void APIENTRY glProvokingVertexEXT (GLenum mode);
' ========================================================================================
DECLARE SUB glProvokingVertexEXT (BYVAL dwMode AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_snorm)
'%GL_EXT_texture_snorm = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_draw_buffers_blend)
'%GL_AMD_draw_buffers_blend = 1

' ========================================================================================
' void APIENTRY glBlendFuncIndexedAMD (GLuint buf, GLenum src, GLenum dst);
' ========================================================================================
DECLARE SUB glBlendFuncIndexedAMD (BYVAL buf AS DWORD, BYVAL src AS DWORD, BYVAL dst AS DWORD)

' ========================================================================================
' void APIENTRY glBlendFuncSeparateIndexedAMD (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
' ========================================================================================
DECLARE SUB glBlendFuncSeparateIndexedAMD (BYVAL buf AS DWORD, BYVAL srcRGB AS DWORD, BYVAL dstRGB AS DWORD, BYVAL srcAlpha AS DWORD, BYVAL dstAlpha AS DWORD)

' ========================================================================================
' void APIENTRY glBlendEquationIndexedAMD (GLuint buf, GLenum mode);
' ========================================================================================
DECLARE SUB glBlendEquationIndexedAMD (BYVAL buf AS DWORD, BYVAL dwMode AS DWORD)

' ========================================================================================
' void APIENTRY glBlendEquationSeparateIndexedAMD (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
' ========================================================================================
DECLARE SUB glBlendEquationSeparateIndexedAMD (BYVAL buf AS DWORD, BYVAL modeRGB AS DWORD, BYVAL modeAlpha AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_texture_range)
'%GL_APPLE_texture_range = 1

' ========================================================================================
' void APIENTRY glTextureRangeAPPLE (GLenum target, GLsizei length, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glTextureRangeAPPLE (BYVAL dwTarget AS DWORD, BYVAL nLength AS LONG, BYVAL pPointer AS DWORD)

' ========================================================================================
' void APIENTRY glGetTexParameterPointervAPPLE (GLenum target, GLenum pname, GLvoid* *params);
' ========================================================================================
DECLARE SUB glGetTexParameterPointervAPPLE (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYVAL params AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_float_pixels)
'%GL_APPLE_float_pixels = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_vertex_program_evaluators)
'%GL_APPLE_vertex_program_evaluators = 1

' ========================================================================================
' void APIENTRY glEnableVertexAttribAPPLE (GLuint index, GLenum pname);
' ========================================================================================
DECLARE SUB glEnableVertexAttribAPPLE (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD)

' ========================================================================================
' void APIENTRY glDisableVertexAttribAPPLE (GLuint index, GLenum pname);
' ========================================================================================
DECLARE SUB glDisableVertexAttribAPPLE (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsVertexAttribEnabledAPPLE (GLuint index, GLenum pname);
' ========================================================================================
DECLARE FUNCTION glIsVertexAttribEnabledAPPLE (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glMapVertexAttrib1dAPPLE (GLuint index, GLuint size, GLdouble u1,
' GLdouble u2, GLint stride, GLint order, const GLdouble *points);
' ========================================================================================
DECLARE SUB glMapVertexAttrib1dAPPLE (BYVAL dwIndex AS DWORD, BYVAL dwSize AS DWORD, BYVAL u1 AS DOUBLE, BYVAL u2 AS DOUBLE, BYVAL stride AS LONG, BYVAL order AS LONG, BYREF dpoints AS DOUBLE)

' ========================================================================================
' void APIENTRY glMapVertexAttrib1fAPPLE (GLuint index, GLuint size, GLfloat u1,
' GLfloat u2, GLint stride, GLint order, const GLfloat *points);
' ========================================================================================
DECLARE SUB glMapVertexAttrib1fAPPLE (BYVAL dwIndex AS DWORD, BYVAL dwSize AS DWORD, BYVAL u1 AS SINGLE, BYVAL u2 AS SINGLE, BYVAL stride AS LONG, BYVAL order AS LONG, BYREF fpoints AS SINGLE)

' ========================================================================================
' void APIENTRY glMapVertexAttrib2dAPPLE (GLuint index, GLuint size, GLdouble u1,
' GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride,
' GLint vorder, const GLdouble *points);
' ========================================================================================
DECLARE SUB glMapVertexAttrib2dAPPLE (BYVAL dwIndex AS DWORD, BYVAL dwSize AS DWORD, BYVAL u1 AS DOUBLE, BYVAL u2 AS DOUBLE, BYVAL ustride AS LONG, BYVAL uorder AS LONG, _
   BYVAL v1 AS DOUBLE, BYVAL v2 AS DOUBLE, BYVAL vstride AS LONG, BYVAL vorder AS LONG, BYREF dpoints AS DOUBLE)

' ========================================================================================
' void APIENTRY glMapVertexAttrib2fAPPLE (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
' ========================================================================================
DECLARE SUB glMapVertexAttrib2fAPPLE (BYVAL dwIndex AS DWORD, BYVAL dwSize AS DWORD, BYVAL u1 AS SINGLE, BYVAL u2 AS SINGLE, BYVAL ustride AS LONG, BYVAL uorder AS LONG, _
   BYVAL v1 AS SINGLE, BYVAL v2 AS SINGLE, BYVAL vstride AS LONG, BYVAL vorder AS LONG, BYREF fpoints AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_aux_depth_stencil)
'%GL_APPLE_aux_depth_stencil = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_object_purgeable)
'%GL_APPLE_object_purgeable = 1

' ========================================================================================
' GLenum APIENTRY glObjectPurgeableAPPLE (GLenum objectType, GLuint name, GLenum option);
' ========================================================================================
DECLARE FUNCTION glObjectPurgeableAPPLE (BYVAL objectType AS DWORD, BYVAL dwName AS DWORD, BYVAL dwOption AS DWORD) AS DWORD

' ========================================================================================
' GLenum APIENTRY glObjectUnpurgeableAPPLE (GLenum objectType, GLuint name, GLenum option);
' ========================================================================================
DECLARE FUNCTION glObjectUnpurgeableAPPLE (BYVAL objectType AS DWORD, BYVAL dwName AS DWORD, BYVAL dwOption AS DWORD) AS DWORD

' ========================================================================================
' void APIENTRY glGetObjectParameterivAPPLE (GLenum objectType, GLuint name, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetObjectParameterivAPPLE (BYVAL objectType AS DWORD, BYVAL dwName AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_APPLE_row_bytes)
'%GL_APPLE_row_bytes = 1
'#ENDIF

'#IF NOT %DEF(%GL_APPLE_rgb_422)
'%GL_APPLE_rgb_422 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_video_capture)
'%GL_NV_video_capture = 1

' ========================================================================================
' void APIENTRY glBeginVideoCaptureNV (GLuint video_capture_slot);
' ========================================================================================
DECLARE SUB glBeginVideoCaptureNV (BYVAL video_capture_slot AS DWORD)

' ========================================================================================
' void APIENTRY glBindVideoCaptureStreamBufferNV (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
' ========================================================================================
DECLARE SUB glBindVideoCaptureStreamBufferNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL frame_region AS DWORD, BYVAL poffset AS LONG)

' ========================================================================================
' void APIENTRY glBindVideoCaptureStreamTextureNV (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
' ========================================================================================
DECLARE SUB glBindVideoCaptureStreamTextureNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL frame_region AS DWORD, BYVAL dwTarget AS DWORD, BYVAL dwTexture AS DWORD)

' ========================================================================================
' void APIENTRY glEndVideoCaptureNV (GLuint video_capture_slot);
' ========================================================================================
DECLARE SUB glEndVideoCaptureNV (BYVAL video_capture_slot AS DWORD)

' ========================================================================================
' void APIENTRY glGetVideoCaptureivNV (GLuint video_capture_slot, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVideoCaptureivNV (BYVAL video_capture_slot AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void APIENTRY glGetVideoCaptureStreamivNV (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params);
' ========================================================================================
DECLARE SUB glGetVideoCaptureStreamivNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void APIENTRY glGetVideoCaptureStreamfvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params);
' ========================================================================================
DECLARE SUB glGetVideoCaptureStreamfvNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void APIENTRY glGetVideoCaptureStreamdvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetVideoCaptureStreamdvNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' GLenum APIENTRY glVideoCaptureNV (GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time);
' ========================================================================================
DECLARE FUNCTION glVideoCaptureNV (BYVAL video_capture_slot AS DWORD, BYREF sequence_num AS DWORD, BYREF capture_time AS QUAD) AS DWORD

' ========================================================================================
' void APIENTRY glVideoCaptureStreamParameterivNV (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params);
' ========================================================================================
DECLARE SUB glVideoCaptureStreamParameterivNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL pname AS DWORD, BYREF params AS LONG)

' ========================================================================================
' void APIENTRY glVideoCaptureStreamParameterfvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params);
' ========================================================================================
DECLARE SUB glVideoCaptureStreamParameterfvNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL pname AS DWORD, BYREF params AS SINGLE)

' ========================================================================================
' void APIENTRY glVideoCaptureStreamParameterdvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params);
' ========================================================================================
DECLARE SUB glVideoCaptureStreamParameterdvNV (BYVAL video_capture_slot AS DWORD, BYVAL dwStream AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

'#ENDIF

'#IF NOT %DEF(%GL_NV_copy_image)
'%GL_NV_copy_image = 1

' ========================================================================================
' void APIENTRY glCopyImageSubDataNV (GLuint srcName, GLenum srcTarget, GLint srcLevel,
' GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel,
' GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
' ========================================================================================
DECLARE SUB glCopyImageSubDataNV (BYVAL srcName AS DWORD, BYVAL srcTarget AS DWORD, BYVAL srcLevel AS LONG, BYVAL srcX AS LONG, BYVAL srcY AS LONG, BYVAL srcZ AS LONG, BYVAL dstName AS DWORD, BYVAL dstTarget AS DWORD, _
   BYVAL dstLevel AS LONG, BYVAL dstX AS LONG, BYVAL dstY AS LONG, BYVAL dstZ AS LONG, BYVAL nWidth AS LONG, BYVAL nHeight AS LONG, BYVAL nDepth AS LONG)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_separate_shader_objects)
'%GL_EXT_separate_shader_objects = 1

' ========================================================================================
' void APIENTRY glUseShaderProgramEXT (GLenum type, GLuint program);
' ========================================================================================
DECLARE SUB glUseShaderProgramEXT (BYVAL dwType AS DWORD, BYVAL program AS DWORD)

' ========================================================================================
' void APIENTRY glActiveProgramEXT (GLuint program);
' ========================================================================================
DECLARE SUB glActiveProgramEXT (BYVAL program AS DWORD)

' ========================================================================================
' GLuint APIENTRY glCreateShaderProgramEXT (GLenum type, const GLchar *string);
' ========================================================================================
DECLARE FUNCTION glCreateShaderProgramEXT (BYVAL dwType AS DWORD, BYREF szString AS ASCIIZ) AS DWORD

'#ENDIF

'#IF NOT %DEF(%GL_NV_parameter_buffer_object2)
'%GL_NV_parameter_buffer_object2 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_shader_buffer_load)
'%GL_NV_shader_buffer_load = 1

' ========================================================================================
' void APIENTRY glMakeBufferResidentNV (GLenum target, GLenum access);
' ========================================================================================
DECLARE SUB glMakeBufferResidentNV (BYVAL dwTarget AS DWORD, BYVAL dwAccess AS DWORD)

' ========================================================================================
' void APIENTRY glMakeBufferNonResidentNV (GLenum target);
' ========================================================================================
DECLARE SUB glMakeBufferNonResidentNV (BYVAL dwTarget AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsBufferResidentNV (GLenum target);
' ========================================================================================
DECLARE FUNCTION glIsBufferResidentNV (BYVAL dwTarget AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glMakeNamedBufferResidentNV (GLuint buffer, GLenum access);
' ========================================================================================
DECLARE SUB glMakeNamedBufferResidentNV (BYVAL buffer AS DWORD, BYVAL dwAccess AS DWORD)

' ========================================================================================
' void APIENTRY glMakeNamedBufferNonResidentNV (GLuint buffer);
' ========================================================================================
DECLARE SUB glMakeNamedBufferNonResidentNV (BYVAL buffer AS DWORD)

' ========================================================================================
' GLboolean APIENTRY glIsNamedBufferResidentNV (GLuint buffer);
' ========================================================================================
DECLARE FUNCTION glIsNamedBufferResidentNV (BYVAL buffer AS DWORD) AS BYTE

' ========================================================================================
' void APIENTRY glGetBufferParameterui64vNV (GLenum target, GLenum pname, GLuint64EXT *params);
' ========================================================================================
DECLARE SUB glGetBufferParameterui64vNV (BYVAL dwTarget AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' void APIENTRY glGetNamedBufferParameterui64vNV (GLuint buffer, GLenum pname, GLuint64EXT *params);
' ========================================================================================
DECLARE SUB glGetNamedBufferParameterui64vNV (BYVAL buffer AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' void APIENTRY glGetIntegerui64vNV (GLenum value, GLuint64EXT *result);
' ========================================================================================
DECLARE SUB glGetIntegerui64vNV (BYVAL value AS DWORD, BYREF result AS QUAD)

' ========================================================================================
' void APIENTRY glUniformui64NV (GLint location, GLuint64EXT value);
' ========================================================================================
DECLARE SUB glUniformui64NV (BYVAL location AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' void APIENTRY glUniformui64vNV (GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glUniformui64vNV (BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS QUAD)

' ========================================================================================
' void APIENTRY glGetUniformui64vNV (GLuint program, GLint location, GLuint64EXT *params);
' ========================================================================================
DECLARE SUB glGetUniformui64vNV (BYVAL program AS DWORD, BYVAL location AS LONG, BYREF params AS QUAD)

' ========================================================================================
' void APIENTRY glProgramUniformui64NV (GLuint program, GLint location, GLuint64EXT value);
' ========================================================================================
DECLARE SUB glProgramUniformui64NV (BYVAL program AS DWORD, BYVAL location AS LONG, BYREF value AS QUAD)

' ========================================================================================
' void APIENTRY glProgramUniformui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniformui64vNV (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL nCount AS LONG, BYREF value AS QUAD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_buffer_unified_memory)
'%GL_NV_vertex_buffer_unified_memory = 1

' ========================================================================================
' void APIENTRY glBufferAddressRangeNV (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
' ========================================================================================
DECLARE SUB glBufferAddressRangeNV (BYVAL pname AS DWORD, BYVAL dwIndex AS DWORD, BYVAL address AS QUAD, BYVAL length AS DWORD)

' ========================================================================================
' void APIENTRY glVertexFormatNV (GLint size, GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glVertexFormatNV (BYVAL nsize AS LONG, BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glNormalFormatNV (GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glNormalFormatNV (BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glColorFormatNV (GLint size, GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glColorFormatNV (BYVAL nsize AS LONG, BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glIndexFormatNV (GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glIndexFormatNV (BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glTexCoordFormatNV (GLint size, GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glTexCoordFormatNV (BYVAL nsize AS LONG, BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glEdgeFlagFormatNV (GLsizei stride);
' ========================================================================================
DECLARE SUB glEdgeFlagFormatNV (BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glSecondaryColorFormatNV (GLint size, GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glSecondaryColorFormatNV (BYVAL nsize AS LONG, BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glFogCoordFormatNV (GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glFogCoordFormatNV (BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glVertexAttribFormatNV (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
' ========================================================================================
DECLARE SUB glVertexAttribFormatNV (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL normalized AS BYTE, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glVertexAttribIFormatNV (GLuint index, GLint size, GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glVertexAttribIFormatNV (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL stride AS LONG)

' ========================================================================================
' void APIENTRY glGetIntegerui64i_vNV (GLenum value, GLuint index, GLuint64EXT *result);
' ========================================================================================
DECLARE SUB glGetIntegerui64i_vNV (BYVAL value AS DWORD, BYVAL dwIndex AS DWORD, BYREF result AS QUAD)

'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_barrier)
'%GL_NV_texture_barrier = 1

' ========================================================================================
' void APIENTRY glTextureBarrierNV (void);
' ========================================================================================
DECLARE SUB glTextureBarrierNV

'#ENDIF

'#IF NOT %DEF(%GL_AMD_shader_stencil_export)
'%GL_AMD_shader_stencil_export = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_seamless_cubemap_per_texture)
'%GL_AMD_seamless_cubemap_per_texture = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_conservative_depth)
'%GL_AMD_conservative_depth = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_shader_image_load_store)
'%GL_EXT_shader_image_load_store = 1
' ========================================================================================
' GLAPI void APIENTRY glBindImageTextureEXT (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
' ========================================================================================
DECLARE SUB glBindImageTextureEXT (BYVAL dwIndex AS DWORD, BYVAL dwTexture AS DWORD, BYVAL nlevel AS LONG, BYVAL bLayered AS LONG, BYVAL nLayer AS LONG, BYVAL dwAccess AS DWORD, BYVAL nFormat AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glMemoryBarrierEXT (GLbitfield barriers);
' ========================================================================================
DECLARE SUB glMemoryBarrierEXT (BYVAL barriers AS DWORD)
'#ENDIF

'#IF NOT %DEF(%GL_EXT_vertex_attrib_64bit)
'%GL_EXT_vertex_attrib_64bit = 1
' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1dEXT (GLuint index, GLdouble x);
' ========================================================================================
DECLARE SUB glVertexAttribL1dEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2dEXT (GLuint index, GLdouble x, GLdouble y);
' ========================================================================================
DECLARE SUB glVertexAttribL2dEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3dEXT (GLuint index, GLdouble x, GLdouble y, GLdouble z);
' ========================================================================================
DECLARE SUB glVertexAttribL3dEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4dEXT (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
' ========================================================================================
DECLARE SUB glVertexAttribL4dEXT (BYVAL dwIndex AS DWORD, BYVAL x AS DOUBLE, BYVAL y AS DOUBLE, BYVAL z AS DOUBLE, BYVAL w AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1dvEXT (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL1dvEXT (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2dvEXT (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL2dvEXT (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3dvEXT (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL3dvEXT (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4dvEXT (GLuint index, const GLdouble *v);
' ========================================================================================
DECLARE SUB glVertexAttribL4dvEXT (BYVAL dwIndex AS DWORD, BYREF v AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribLPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
' ========================================================================================
DECLARE SUB glVertexAttribLPointerEXT (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL dwStride AS DWORD, BYVAL p AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetVertexAttribLdvEXT (GLuint index, GLenum pname, GLdouble *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribLdvEXT (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS DOUBLE)

' ========================================================================================
' GLAPI void APIENTRY glVertexArrayVertexAttribLOffsetEXT (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
' ========================================================================================
DECLARE SUB glVertexArrayVertexAttribLOffsetEXT (BYVAL vaobj AS DWORD, BYVAL dwBuffer AS DWORD, BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL dwStride AS DWORD, BYVAL poffset AS LONG)
'#ENDIF

'#IF NOT %DEF(%GL_NV_gpu_program5)
'%GL_NV_gpu_program5 = 1
' ========================================================================================
' GLAPI void APIENTRY glProgramSubroutineParametersuivNV (GLenum target, GLsizei count, const GLuint *params);
' ========================================================================================
DECLARE SUB glProgramSubroutineParametersuivNV (BYVAL dwTarget AS DWORD, BYVAL dwCount AS DWORD, BYREF params AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glGetProgramSubroutineParameteruivNV (GLenum target, GLuint index, GLuint *param);
' ========================================================================================
DECLARE SUB glGetProgramSubroutineParameteruivNV (BYVAL dwTarget AS DWORD, BYVAL dwIndex AS DWORD, BYREF param AS DWORD)
'#ENDIF

'#IF NOT %DEF(%GL_NV_gpu_shader5)
'%GL_NV_gpu_shader5 = 1
' ========================================================================================
' GLAPI void APIENTRY glUniform1i64NV (GLint location, GLint64EXT x);
' ========================================================================================
DECLARE SUB glUniform1i64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform2i64NV (GLint location, GLint64EXT x, GLint64EXT y);
' ========================================================================================
DECLARE SUB glUniform2i64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform3i64NV (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
' ========================================================================================
DECLARE SUB glUniform3i64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform4i64NV (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
' ========================================================================================
DECLARE SUB glUniform4i64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD, BYVAL w AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform1i64vNV (GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform1i64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform2i64vNV (GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform2i64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform3i64vNV (GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform3i64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform4i64vNV (GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform4i64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform1ui64NV (GLint location, GLuint64EXT x);
' ========================================================================================
DECLARE SUB glUniform1ui64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform2ui64NV (GLint location, GLuint64EXT x, GLuint64EXT y);
' ========================================================================================
DECLARE SUB glUniform2ui64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform3ui64NV (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
' ========================================================================================
DECLARE SUB glUniform3ui64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform4ui64NV (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
' ========================================================================================
DECLARE SUB glUniform4ui64NV (BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD, BYVAL w AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform1ui64vNV (GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform1ui64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform2ui64vNV (GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform2ui64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform3ui64vNV (GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform3ui64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniform4ui64vNV (GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glUniform4ui64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glGetUniformi64vNV (GLuint program, GLint location, GLint64EXT *params);
' ========================================================================================
DECLARE SUB glGetUniformi64vNV (BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1i64NV (GLuint program, GLint location, GLint64EXT x);
' ========================================================================================
DECLARE SUB glProgramUniform1i64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2i64NV (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
' ========================================================================================
DECLARE SUB glProgramUniform2i64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3i64NV (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
' ========================================================================================
DECLARE SUB glProgramUniform3i64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z aS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4i64NV (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
' ========================================================================================
DECLARE SUB glProgramUniform4i64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z aS QUAD, BYVAL w AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform1i64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform2i64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform3i64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform4i64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1ui64NV (GLuint program, GLint location, GLuint64EXT x);
' ========================================================================================
DECLARE SUB glProgramUniform1ui64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2ui64NV (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
' ========================================================================================
DECLARE SUB glProgramUniform2ui64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3ui64NV (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
' ========================================================================================
DECLARE SUB glProgramUniform3ui64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4ui64NV (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
' ========================================================================================
DECLARE SUB glProgramUniform4ui64NV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD, BYVAL w AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform1ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform1ui64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform2ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform2ui64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform3ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform3ui64vNV(BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniform4ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
' ========================================================================================
DECLARE SUB glProgramUniform4ui64vNV (BYVAL program AS DWORD, BYVAL nLocation AS LONG, BYVAL dwCount AS DWORD, BYREF value AS QUAD)
'#ENDIF

'#IF NOT %DEF(%GL_NV_shader_buffer_store)
'%GL_NV_shader_buffer_store = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_tessellation_program5)
'%GL_NV_tessellation_program5 = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_vertex_attrib_integer_64bit)
'%GL_NV_vertex_attrib_integer_64bit = 1
' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1i64NV (GLuint index, GLint64EXT x);
' ========================================================================================
DECLARE SUB glVertexAttribL1i64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2i64NV (GLuint index, GLint64EXT x, GLint64EXT y);
' ========================================================================================
DECLARE SUB glVertexAttribL2i64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD, BYVAL y AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3i64NV (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
' ========================================================================================
DECLARE SUB glVertexAttribL3i64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4i64NV (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
' ========================================================================================
DECLARE SUB glVertexAttribL4i64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD, BYVAL w AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1i64vNV (GLuint index, const GLint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL1i64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2i64vNV (GLuint index, const GLint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL2i64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3i64vNV (GLuint index, const GLint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL3i64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4i64vNV (GLuint index, const GLint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL4i64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1ui64NV (GLuint index, GLuint64EXT x);
' ========================================================================================
DECLARE SUB glVertexAttribL1ui64NV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2ui64NV (GLuint index, GLuint64EXT x, GLuint64EXT y);
' ========================================================================================
DECLARE SUB glVertexAttribL2ui64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD, BYVAL y AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3ui64NV (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
' ========================================================================================
DECLARE SUB glVertexAttribL3ui64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4ui64NV (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
' ========================================================================================
DECLARE SUB glVertexAttribL4ui64NV (BYVAL dwIndex AS DWORD, BYVAL x AS QUAD, BYVAL y AS QUAD, BYVAL z AS QUAD, BYVAL w AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL1ui64vNV (GLuint index, const GLuint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL1ui64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL2ui64vNV (GLuint index, const GLuint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL2ui64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL3ui64vNV (GLuint index, const GLuint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL3ui64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribL4ui64vNV (GLuint index, const GLuint64EXT *v);
' ========================================================================================
DECLARE SUB glVertexAttribL4ui64vNV (BYVAL dwIndex AS DWORD, BYREF v AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glGetVertexAttribLi64vNV (GLuint index, GLenum pname, GLint64EXT *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribLi64vNV (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glGetVertexAttribLui64vNV (GLuint index, GLenum pname, GLuint64EXT *params);
' ========================================================================================
DECLARE SUB glGetVertexAttribLui64vNV (BYVAL dwIndex AS DWORD, BYVAL pname AS DWORD, BYREF params AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glVertexAttribLFormatNV (GLuint index, GLint size, GLenum type, GLsizei stride);
' ========================================================================================
DECLARE SUB glVertexAttribLFormatNV (BYVAL dwIndex AS DWORD, BYVAL nSize AS LONG, BYVAL dwType AS DWORD, BYVAL dwStride AS DWORD)
'#ENDIF

'#IF NOT %DEF(%GL_NV_multisample_coverage)
'%GL_NV_multisample_coverage = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_name_gen_delete)
'%GL_AMD_name_gen_delete = 1
' ========================================================================================
' GLAPI void APIENTRY glGenNamesAMD (GLenum identifier, GLuint num, GLuint *names);
' ========================================================================================
DECLARE SUB glGenNamesAMD (BYVAL dwIdentifier AS DWORD, BYVAL dwNum AS DWORD, BYREF names AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glDeleteNamesAMD (GLenum identifier, GLuint num, const GLuint *names);
' ========================================================================================
DECLARE SUB glDeleteNamesAMD (BYVAL dwIdentifier AS DWORD, BYVAL dwNum AS DWORD, BYREF names AS DWORD)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsNameAMD (GLenum identifier, GLuint name);
' ========================================================================================
DECLARE FUNCTION glIsNameAMD (BYVAL dwIdentifier AS DWORD, BYVAL dwName AS DWORD) AS LONG
'#ENDIF

'#IF NOT %DEF(%GL_AMD_debug_output)
'%GL_AMD_debug_output = 1
' ========================================================================================
' GLAPI void APIENTRY glDebugMessageEnableAMD (GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
' ========================================================================================
DECLARE SUB glDebugMessageEnableAMD (BYVAL dwCategory AS DWORD, BYVAL dwSeverity AS DWORD, BYVAL dwCount AS DWORD, BYREF ids AS DWORD, BYVAL bEnabled AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageInsertAMD (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf);
' ========================================================================================
DECLARE SUB glDebugMessageInsertAMD (BYVAL dwCategory AS DWORD, BYVAL dwSeverity AS DWORD, BYVAL dwId AS DWORD, BYVAL length AS DWORD, BYREF buf AS ASCIIZ)

' ========================================================================================
' GLAPI void APIENTRY glDebugMessageCallbackAMD (GLDEBUGPROCAMD callback, GLvoid *userParam);
' ========================================================================================
DECLARE SUB glDebugMessageCallbackAMD (BYVAL pCallback AS DWORD, BYVAL userParam AS DWORD)

' ========================================================================================
' GLAPI GLuint APIENTRY glGetDebugMessageLogAMD (GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message);
' ========================================================================================
DECLARE FUNCTION glGetDebugMessageLogAMD (BYVAL dwCount AS DWORD, BYVAL bufsize AS DWORD, BYREF categories AS DWORD, BYREF severities AS DWORD, BYREF ids AS DWORD, BYREF lengths AS DWORD, BYREF message AS ASCIIZ) AS DWORD
'#ENDIF

'#IF NOT %DEF(%GL_NV_vdpau_interop)
'%GL_NV_vdpau_interop 1
' ========================================================================================
' GLAPI void APIENTRY glVDPAUInitNV (const GLvoid *vdpDevice, const GLvoid *getProcAddress);
' ========================================================================================
DECLARE SUB glVDPAUInitNV (BYVAL vdpDevice AS DWORD, BYVAL pGetProcAddress AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVDPAUFiniNV (void);
' ========================================================================================
DECLARE SUB glVDPAUFiniNV

' ========================================================================================
' GLAPI GLvdpauSurfaceNV APIENTRY glVDPAURegisterVideoSurfaceNV (const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
' ========================================================================================
DECLARE FUNCTION glVDPAURegisterVideoSurfaceNV (BYVAL vdpSurface AS DWORD, BYVAL dwTarget AS DWORD, BYVAL numTextureNames AS DWORD, BYREF textureNames AS DWORD) AS DWORD

' ========================================================================================
' GLAPI GLvdpauSurfaceNV APIENTRY glVDPAURegisterOutputSurfaceNV (GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
' ========================================================================================
DECLARE FUNCTION glVDPAURegisterOutputSurfaceNV (BYVAL vdpSurface AS DWORD, BYVAL dwTarget AS DWORD, BYVAL numTextureNames AS DWORD, BYREF textureNames AS DWORD) AS DWORD

' ========================================================================================
' GLAPI void APIENTRY glVDPAUIsSurfaceNV (GLvdpauSurfaceNV surface);
' ========================================================================================
DECLARE SUB glVDPAUIsSurfaceNV (BYVAL surface AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVDPAUUnregisterSurfaceNV (GLvdpauSurfaceNV surface);
' ========================================================================================
DECLARE SUB glVDPAUUnregisterSurfaceNV (BYVAL surface AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVDPAUGetSurfaceivNV (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
' ========================================================================================
DECLARE SUB glVDPAUGetSurfaceivNV (BYVAL surface AS DWORD, BYVAL pname AS DWORD, BYVAL bufSize AS DWORD, BYREF length AS DWORD, BYREF values AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glVDPAUSurfaceAccessNV (GLvdpauSurfaceNV surface, GLenum access);
' ========================================================================================
DECLARE SUB glVDPAUSurfaceAccessNV (BYVAL surface AS DWORD, BYVAL dwAccess AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVDPAUMapSurfacesNV (GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces);
' ========================================================================================
DECLARE SUB glVDPAUMapSurfacesNV (BYVAL numSurfaces AS DWORD, BYREF surfaces AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glVDPAUUnmapSurfacesNV (GLsizei numSurface, const GLvdpauSurfaceNV *surfaces);
' ========================================================================================
DECLARE SUB glVDPAUUnmapSurfacesNV (BYVAL numSurface AS DWORD, BYREF surfaces AS DWORD)
'#ENDIF

'#IF NOT %DEF(%GL_AMD_transform_feedback3_lines_triangles)
'%GL_AMD_transform_feedback3_lines_triangles = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_depth_clamp_separate)
'%GL_AMD_depth_clamp_separate = 1
'#ENDIF

'#IF NOT %DEF(%GL_EXT_texture_sRGB_decode)
'%GL_EXT_texture_sRGB_decode = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_texture_multisample)
'%GL_NV_texture_multisample = 1
' ========================================================================================
' GLAPI void APIENTRY glTexImage2DMultisampleCoverageNV (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
' ========================================================================================
DECLARE SUB glTexImage2DMultisampleCoverageNV (BYVAL dwTarget AS DWORD, BYVAL coverageSamples AS DWORD, BYVAL colorSamples AS DWORD, BYVAL internalFormat AS LONG, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, BYVAL fixedSampleLocations AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTexImage3DMultisampleCoverageNV (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
' ========================================================================================
DECLARE SUB glTexImage3DMultisampleCoverageNV (BYVAL dwTarget AS DWORD, BYVAL coverageSamples AS DWORD, BYVAL colorSamples AS DWORD, BYVAL internalFormat AS LONG, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, _
   BYVAL dwDepth AS DWORD, BYVAL fixedSampleLocations AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTextureImage2DMultisampleNV (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
' ========================================================================================
DECLARE SUB glTextureImage2DMultisampleNV (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL samples AS DWORD, BYVAL internalFormat AS LONG, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, BYVAL fixedSampleLocations AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTextureImage3DMultisampleNV (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
' ========================================================================================
DECLARE SUB glTextureImage3DMultisampleNV (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL samples AS DWORD, BYVAL internalFormat AS LONG, BYVAL dwWidth AS DWORD, BYVAL dwHeight AS DWORD, _
   BYVAL dwDepth AS DWORD, BYVAL fixedSampleLocations AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTextureImage2DMultisampleCoverageNV (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
' ========================================================================================
DECLARE SUB glTextureImage2DMultisampleCoverageNV (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL coverageSamples AS DWORD, BYVAL colorSamples AS DWORD, BYVAL internalFormat AS LONG, BYVAL dwWidth AS DWORD, _
   BYVAL dwHeight AS DWORD, BYVAL fixedSampleLocations AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glTextureImage3DMultisampleCoverageNV (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
' ========================================================================================
DECLARE SUB glTextureImage3DMultisampleCoverageNV (BYVAL dwTexture AS DWORD, BYVAL dwTarget AS DWORD, BYVAL coverageSamples AS DWORD, BYVAL colorSamples AS DWORD, BYVAL internalFormat AS LONG, BYVAL dwWidth AS DWORD, _
   BYVAL dwHeight AS DWORD, BYVAL dwDepth AS DWORD, BYVAL fixedSampleLocations AS LONG)
'#ENDIF

'#IF NOT %DEF(%GL_AMD_blend_minmax_factor)
'%GL_AMD_blend_minmax_factor = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_sample_positions)
'%GL_AMD_sample_positions = 1

' ========================================================================================
' GLAPI void APIENTRY glSetMultisamplefvAMD (GLenum pname, GLuint index, const GLfloat *val);
' ========================================================================================
DECLARE SUB glSetMultisamplefvAMD (BYVAL pname AS DWORD, BYVAL dwIndex AS DWORD, BYREF rgVal AS SINGLE)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_x11_sync_object)
'%GL_EXT_x11_sync_object = 1

' ========================================================================================
' GLAPI GLsync APIENTRY glImportSyncEXT (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
' ========================================================================================
DECLARE FUNCTION glImportSyncEXT (BYVAL external_sync_type AS DWORD, BYVAL external_sync AS LONG, BYVAL dwFlags AS DWORD) AS DWORD

'#ENDIF

'#IF NOT %DEF(%GL_AMD_multi_draw_indirect)
'%GL_AMD_multi_draw_indirect = 1

' ========================================================================================
' GLAPI void APIENTRY glMultiDrawArraysIndirectAMD (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
' ========================================================================================
DECLARE SUB glMultiDrawArraysIndirectAMD (BYVAL dwMode AS DWORD, BYVAL pindirect AS DWORD, BYVAL primcount AS DWORD, BYVAL dwStride AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glMultiDrawElementsIndirectAMD (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
' ========================================================================================
DECLARE SUB glMultiDrawElementsIndirectAMD (BYVAL dwMode AS DWORD, BYVAL dwType AS DWORD, BYVAL pindirect AS DWORD, BYVAL primcount AS DWORD, BYVAL dwStride AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_EXT_framebuffer_multisample_blit_scaled)
'%GL_EXT_framebuffer_multisample_blit_scaled = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_path_rendering)
'%GL_NV_path_rendering = 1

' ========================================================================================
' GLAPI GLuint APIENTRY glGenPathsNV (GLsizei range);
' ========================================================================================
DECLARE FUNCTION glGenPathsNV (BYVAL dwRange AS DWORD) AS DWORD

' ========================================================================================
' GLAPI void APIENTRY glDeletePathsNV (GLuint path, GLsizei range);
' ========================================================================================
DECLARE SUB glDeletePathsNV (BYVAL dwPath AS DWORD, BYVAL dwRange AS DWORD)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsPathNV (GLuint path);
' ========================================================================================
DECLARE FUNCTION glIsPathNV (BYVAL dwPath AS DWORD) AS BYTE

' ========================================================================================
' GLAPI void APIENTRY glPathCommandsNV (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
' ========================================================================================
DECLARE SUB glPathCommandsNV (BYVAL dwPath AS DWORD, BYVAL numCommands AS DWORD, BYREF commands AS BYTE, BYVAL numCoords AS DWORD, BYVAL coordType AS DWORD, BYVAL pcoords AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathCoordsNV (GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
' ========================================================================================
DECLARE SUB glPathCoordsNV (BYVAL dwPath AS DWORD, BYVAL numCoords AS DWORD, BYVAL coordType AS DWORD, BYVAL pcoords AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathSubCommandsNV (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
' ========================================================================================
DECLARE SUB glPathSubCommandsNV (BYVAL dwPath AS DWORD, BYVAL commandStart AS DWORD, BYVAL commandsToDelete AS DWORD, BYVAL numCommands AS DWORD, BYREF commands AS BYTE, BYVAL numCoords AS DWORD, BYVAL coordType AS DWORD, BYVAL pcoords AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathSubCoordsNV (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
' ========================================================================================
DECLARE SUB glPathSubCoordsNV (BYVAL dwPath AS DWORD, BYVAL coordStart AS DWORD, BYVAL numCoords AS DWORD,  BYVAL coordType AS DWORD, BYVAL pcoords AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathStringNV (GLuint path, GLenum format, GLsizei length, const GLvoid *pathString);
' ========================================================================================
DECLARE SUB glPathStringNV (BYVAL dwPath AS DWORD, BYVAL dwFormat AS DWORD, BYVAL dwLength AS DWORD, BYVAL pathString AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathGlyphsNV (GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes,
' GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
' ========================================================================================
DECLARE SUB glPathGlyphsNV (BYVAL firstPathName AS DWORD, BYVAL fontTarget AS DWORD, BYVAL fontName AS DWORD, BYVAL fontStyle AS DWORD, BYVAL numGlyphs AS DWORD, BYVAL dwType AS DWORD, BYVAL charcodes AS DWORD, _
   BYVAL handleMissingGlyphs AS DWORD, BYVAL pathParameterTemplate AS DWORD, BYVAL emScale AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathGlyphRangeNV (GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle,
' GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
' ========================================================================================
DECLARE SUB glPathGlyphRangeNV (BYVAL firstPathName AS DWORD, BYVAL fontTarget AS DWORD, BYVAL fontName AS DWORD, BYVAL fontStyle AS DWORD, _
   BYVAL firstGlyph AS DWORD, BYVAL numGlyphs AS DWORD, BYVAL handleMissingGlyphs AS DWORD, BYVAL pathParameterTemplate AS DWORD, BYVAL emScale AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glWeightPathsNV (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights);
' ========================================================================================
DECLARE SUB glWeightPathsNV (BYVAL resultPath AS DWORD, BYVAL numPaths AS DWORD, BYVAL paths AS DWORD, BYREF weights AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glCopyPathNV (GLuint resultPath, GLuint srcPath);
' ========================================================================================
DECLARE SUB glCopyPathNV (BYVAL resultPath AS DWORD, BYVAL srcPath AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glInterpolatePathsNV (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
' ========================================================================================
DECLARE SUB glInterpolatePathsNV (BYVAL resultPath AS DWORD, BYVAL pathA AS DWORD, BYVAL pathB AS DWORD, BYVAL fweight AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glTransformPathNV (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues);
' ========================================================================================
DECLARE SUB glTransformPathNV (BYVAL resultPath AS DWORD, BYVAL srcPath AS DWORD, BYVAL transformType AS DWORD, BYREF transformValues AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathParameterivNV (GLuint path, GLenum pname, const GLint *value);
' ========================================================================================
DECLARE SUB glPathParameterivNV (BYVAL dwPath AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPathParameteriNV (GLuint path, GLenum pname, GLint value);
' ========================================================================================
DECLARE SUB glPathParameteriNV (BYVAL dwPath AS DWORD, BYVAL pname AS DWORD, BYVAL nValue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glPathParameterfvNV (GLuint path, GLenum pname, const GLfloat *value);
' ========================================================================================
DECLARE SUB glPathParameterfvNV (BYVAL dwPath AS DWORD, BYVAL pname AS DWORD, BYREF fvalue AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathParameterfNV (GLuint path, GLenum pname, GLfloat value);
' ========================================================================================
DECLARE SUB glPathParameterfNV (BYVAL dwPath AS DWORD, BYVAL pname AS DWORD, BYVAL fvalue AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathDashArrayNV (GLuint path, GLsizei dashCount, const GLfloat *dashArray);
' ========================================================================================
DECLARE SUB glPathDashArrayNV (BYVAL dwPath AS DWORD, BYVAL dashCount AS DWORD, BYREF dashArray AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathStencilFuncNV (GLenum func, GLint ref, GLuint mask);
' ========================================================================================
DECLARE SUB glPathStencilFuncNV (BYVAL dwFunc AS DWORD, BYVAL nRef AS LONG, BYVAL dwMask AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathStencilDepthOffsetNV (GLfloat factor, GLfloat units);
' ========================================================================================
DECLARE SUB glPathStencilDepthOffsetNV (BYVAL factor AS SINGLE, BYVAL funits AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glStencilFillPathNV (GLuint path, GLenum fillMode, GLuint mask);
' ========================================================================================
DECLARE SUB glStencilFillPathNV (BYVAL dwPath AS DWORD, BYVAL fillMode AS DWORD, BYVAL dwMask AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glStencilStrokePathNV (GLuint path, GLint reference, GLuint mask);
' ========================================================================================
DECLARE SUB glStencilStrokePathNV (BYVAL dwPath AS DWORD, BYVAL reference AS LONG, BYVAL dwMask AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glStencilFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
' ========================================================================================
DECLARE SUB glStencilFillPathInstancedNV (BYVAL numPaths AS DWORD, BYVAL pathNameType AS DWORD, BYVAL paths AS DWORD, BYVAL pathBase AS DWORD, BYVAL fillMode AS DWORD, _
   BYVAL dwMask AS DWORD, BYVAL transformType AS DWORD, BYREF transformValues AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glStencilStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
' ========================================================================================
DECLARE SUB glStencilStrokePathInstancedNV (BYVAL numPaths AS DWORD, BYVAL pathNameType AS DWORD, BYVAL paths AS DWORD, BYVAL pathBase AS DWORD, BYVAL reference AS LONG, _
   BYVAL dwMask AS DWORD, BYVAL transformType AS DWORD, BYREF transformValues AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathCoverDepthFuncNV (GLenum func);
' ========================================================================================
DECLARE SUB glPathCoverDepthFuncNV (BYVAL dwFunc AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glPathColorGenNV (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs);
' ========================================================================================
DECLARE SUB glPathColorGenNV (BYVAL dwColor AS DWORD, BYVAL genMode AS DWORD, BYVAL colorFormat AS DWORD, BYREF coeffs AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathTexGenNV (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs);
' ========================================================================================
DECLARE SUB glPathTexGenNV (BYVAL texCoordSet AS DWORD, BYVAL genMode AS DWORD, BYVAL components AS LONG, BYREF coeffs AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glPathFogGenNV (GLenum genMode);
' ========================================================================================
DECLARE SUB glPathFogGenNV (BYVAL genMode AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glCoverFillPathNV (GLuint path, GLenum coverMode);
' ========================================================================================
DECLARE SUB glCoverFillPathNV (BYVAL dwPath AS DWORD, BYVAL coverMode AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glCoverStrokePathNV (GLuint path, GLenum coverMode);
' ========================================================================================
DECLARE SUB glCoverStrokePathNV (BYVAL dwPath AS DWORD, BYVAL coverMode AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glCoverFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
' ========================================================================================
DECLARE SUB glCoverFillPathInstancedNV (BYVAL numPaths AS DWORD, BYVAL pathNameType AS DWORD, BYVAL paths AS DWORD, BYVAL pathBase AS DWORD, _
   BYVAL coverMode AS DWORD, BYVAL transformType AS DWORD, BYREF transformValues AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glCoverStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
' ========================================================================================
DECLARE SUB glCoverStrokePathInstancedNV (BYVAL numPaths AS DWORD, BYVAL pathNameType AS DWORD, BYVAL paths AS DWORD, BYVAL pathBase AS DWORD, _
   BYVAL coverMode AS DWORD, BYVAL transformType AS DWORD, BYREF transformValues AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathParameterivNV (GLuint path, GLenum pname, GLint *value);
' ========================================================================================
DECLARE SUB glGetPathParameterivNV (BYVAL dwPath AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetPathParameterfvNV (GLuint path, GLenum pname, GLfloat *value);
' ========================================================================================
DECLARE SUB glGetPathParameterfvNV (BYVAL dwPath AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetPathCommandsNV (GLuint path, GLubyte *commands);
' ========================================================================================
DECLARE SUB glGetPathCommandsNV (BYVAL dwPath AS DWORD, BYREF commands AS BYTE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathCoordsNV (GLuint path, GLfloat *coords);
' ========================================================================================
DECLARE SUB glGetPathCoordsNV (BYVAL dwPath AS DWORD, BYREF coords AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathDashArrayNV (GLuint path, GLfloat *dashArray);
' ========================================================================================
DECLARE SUB glGetPathDashArrayNV (BYVAL dwPath AS DWORD, BYREF dashArray AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathMetricsNV (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
' ========================================================================================
DECLARE SUB glGetPathMetricsNV (BYVAL metricQueryMask AS DWORD, BYVAL numPaths AS DWORD, BYVAL pathNameType AS DWORD, _
   BYVAL paths AS DWORD, BYVAL pathBase AS DWORD, BYVAL stride AS DWORD, BYREF fmetrics AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathMetricRangeNV (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics);
' ========================================================================================
DECLARE SUB glGetPathMetricRangeNV (BYVAL metricQueryMask AS DWORD, BYVAL firstPathName AS DWORD, BYVAL numPaths AS DWORD, BYVAL stride AS DWORD, BYREF fmetrics AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathSpacingNV (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
' ========================================================================================
DECLARE SUB glGetPathSpacingNV (BYVAL pathListMode AS DWORD, BYVAL numPaths AS DWORD, BYVAL pathNameType AS DWORD, BYVAL paths AS DWORD, BYVAL pathBase AS DWORD, _
   BYVAL advanceScale AS SINGLE, BYVAL kerningScale AS SINGLE, BYVAL transformType AS DWORD, BYREF returnedSpacing AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathColorGenivNV (GLenum color, GLenum pname, GLint *value);
' ========================================================================================
DECLARE SUB glGetPathColorGenivNV (BYVAL dwColor AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetPathColorGenfvNV (GLenum color, GLenum pname, GLfloat *value);
' ========================================================================================
DECLARE SUB glGetPathColorGenfvNV (BYVAL dwColor AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS SINGLE)

' ========================================================================================
' GLAPI void APIENTRY glGetPathTexGenivNV (GLenum texCoordSet, GLenum pname, GLint *value);
' ========================================================================================
DECLARE SUB glGetPathTexGenivNV (BYVAL texCoordSet AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS LONG)

' ========================================================================================
' GLAPI void APIENTRY glGetPathTexGenfvNV (GLenum texCoordSet, GLenum pname, GLfloat *value);
' ========================================================================================
DECLARE SUB glGetPathTexGenfvNV (BYVAL texCoordSet AS DWORD, BYVAL pname AS DWORD, BYREF rgValue AS SINGLE)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsPointInFillPathNV (GLuint path, GLuint mask, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE FUNCTION glIsPointInFillPathNV (BYVAL dwPath AS DWORD, BYVAL dwMask AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE) AS BYTE

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsPointInStrokePathNV (GLuint path, GLfloat x, GLfloat y);
' ========================================================================================
DECLARE FUNCTION glIsPointInStrokePathNV (BYVAL dwPath AS DWORD, BYVAL x AS SINGLE, BYVAL y AS SINGLE) AS BYTE

' ========================================================================================
' GLAPI GLfloat APIENTRY glGetPathLengthNV (GLuint path, GLsizei startSegment, GLsizei numSegments);
' ========================================================================================
DECLARE FUNCTION glGetPathLengthNV (BYVAL dwPath AS DWORD, BYVAL startSegment AS DWORD, BYVAL numSegments AS DWORD) AS SINGLE

' ========================================================================================
' GLAPI GLboolean APIENTRY glPointAlongPathNV (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
' ========================================================================================
DECLARE FUNCTION glPointAlongPathNV (BYVAL dwPath AS DWORD, BYVAL startSegment AS DWORD, BYVAL numSegments AS DWORD, _
   BYVAL distance AS SINGLE, BYREF x AS SINGLE, BYREF y AS SINGLE, BYREF tangentX AS SINGLE, BYREF tangentY AS SINGLE) AS BYTE

'#ENDIF

'#IF NOT %DEF(%GL_AMD_pinned_memory)
'%GL_AMD_pinned_memory = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_stencil_operation_extended)
'%GL_AMD_stencil_operation_extended = 1

' ========================================================================================
' GLAPI void APIENTRY glStencilOpValueAMD (GLenum face, GLuint value);
' ========================================================================================
DECLARE SUB glStencilOpValueAMD (BYVAL dwFace AS DWORD, BYVAL dwValue AS DWORD)

'#ENDIF

'#IF NOT %DEF(%GL_AMD_vertex_shader_viewport_index)
'%GL_AMD_vertex_shader_viewport_index = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_vertex_shader_layer)
'%GL_AMD_vertex_shader_layer = 1
'#ENDIF

#IF NOT %DEF(%GL_NV_bindless_texture)
%GL_NV_bindless_texture = 1

' ========================================================================================
' GLAPI GLuint64 APIENTRY glGetTextureHandleNV (GLuint texture);
' ========================================================================================
DECLARE FUNCTION glGetTextureHandleNV (BYVAL dwtexture AS DWORD) AS QUAD

' ========================================================================================
' GLAPI GLuint64 APIENTRY glGetTextureSamplerHandleNV (GLuint texture, GLuint sampler);
' ========================================================================================
DECLARE FUNCTION glGetTextureSamplerHandleNV (BYVAL dwtexture AS DWORD, BYVAL sampler AS DWORD) AS QUAD

' ========================================================================================
' GLAPI void APIENTRY glMakeTextureHandleResidentNV (GLuint64 handle);
' ========================================================================================
DECLARE SUB glMakeTextureHandleResidentNV (BYVAL qhandle AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glMakeTextureHandleNonResidentNV (GLuint64 handle);
' ========================================================================================
DECLARE SUB glMakeTextureHandleNonResidentNV (BYVAL qhandle AS QUAD)

' ========================================================================================
' GLAPI GLuint64 APIENTRY glGetImageHandleNV (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
' ========================================================================================
DECLARE FUNCTION glGetImageHandleNV (BYVAL dwtexture AS DWORD, BYVAL nlevel AS LONG, BYVAL layered AS BYTE, BYVAL layer AS LONG, BYVAL dwformat AS DWORD) AS QUAD

' ========================================================================================
' GLAPI void APIENTRY glMakeImageHandleResidentNV (GLuint64 handle, GLenum access);
' ========================================================================================
DECLARE SUB glMakeImageHandleResidentNV (BYVAL qhandle AS QUAD, BYVAL dwaccess AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glMakeImageHandleNonResidentNV (GLuint64 handle);
' ========================================================================================
DECLARE SUB glMakeImageHandleNonResidentNV (BYVAL qhandle AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniformHandleui64NV (GLint location, GLuint64 value);
' ========================================================================================
DECLARE SUB glUniformHandleui64NV (BYVAL location AS LONG, BYVAL qhandle AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glUniformHandleui64vNV (GLint location, GLsizei count, const GLuint64 *value);
' ========================================================================================
DECLARE SUB glUniformHandleui64vNV (BYVAL location AS LONG, BYVAL ncount AS LONG, BYREF value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformHandleui64NV (GLuint program, GLint location, GLuint64 value);
' ========================================================================================
DECLARE SUB glProgramUniformHandleui64NV (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL value AS QUAD)

' ========================================================================================
' GLAPI void APIENTRY glProgramUniformHandleui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64 *values);
' ========================================================================================
DECLARE SUB glProgramUniformHandleui64vNV (BYVAL program AS DWORD, BYVAL location AS LONG, BYVAL ncount AS LONG, BYREF values AS QUAD)

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsTextureHandleResidentNV (GLuint64 handle);
' ========================================================================================
DECLARE FUNCTION glIsTextureHandleResidentNV (BYVAL qhandle AS QUAD) AS BYTE

' ========================================================================================
' GLAPI GLboolean APIENTRY glIsImageHandleResidentNV (GLuint64 handle);
' ========================================================================================
DECLARE FUNCTION glIsImageHandleResidentNV (BYVAL qhandle AS QUAD) AS BYTE

#ENDIF

'#IF NOT %DEF(%GL_NV_shader_atomic_float)
'%GL_NV_shader_atomic_float = 1
'#ENDIF

'#IF NOT %DEF(%GL_AMD_query_buffer_object)
'%GL_AMD_query_buffer_object = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_compute_program5)
'%GL_NV_compute_program5 ) 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_shader_storage_buffer_object)
'%GL_NV_shader_storage_buffer_object = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_shader_atomic_counters)
'%GL_NV_shader_atomic_counters = 1
'#ENDIF

'#IF NOT %DEF(%GL_NV_deep_texture3D)
'%GL_NV_deep_texture3D = 1
'#ENDIF

#IF NOT %DEF(%GL_NVX_conditional_render)
%GL_NVX_conditional_render = 1

' ========================================================================================
' GLAPI void APIENTRY glBeginConditionalRenderNVX (GLuint id);
' ========================================================================================
DECLARE SUB glBeginConditionalRenderNVX (BYVAL dwid AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glEndConditionalRenderNVX (void);
' ========================================================================================
DECLARE SUB glEndConditionalRenderNVX ()

#ENDIF

#IF NOT %DEF(%GL_AMD_sparse_texture)
%GL_AMD_sparse_texture = 1

' ========================================================================================
' GLAPI void APIENTRY glTexStorageSparseAMD (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
' ========================================================================================
DECLARE SUB glTexStorageSparseAMD (BYVAL dwtarget AS DWORD, BYVAL internalFormat AS DWORD, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL depth AS LONG, BYVAL layers AS LONG, BYVAL flags AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glTextureStorageSparseAMD (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
' ========================================================================================
DECLARE SUB glTextureStorageSparseAMD (BYVAL dwtexture AS DWORD, BYVAL dwtarget AS DWORD, BYVAL internalFormat AS DWORD, BYVAL nwidth AS LONG, BYVAL nheight AS LONG, BYVAL depth AS LONG, BYVAL layers AS LONG, BYVAL flags AS DWORD)

#ENDIF

'#IF NOT %DEF(%GL_AMD_shader_trinary_minmax)
'%GL_AMD_shader_trinary_minmax = 1
'#ENDIF

#IF NOT %DEF(%GL_INTEL_map_texture)
%GL_INTEL_map_texture = 1

' ========================================================================================
' GLAPI void APIENTRY glSyncTextureINTEL (GLuint texture);
' ========================================================================================
DECLARE SUB glSyncTextureINTEL (BYVAL dwtexture AS DWORD)

' ========================================================================================
' GLAPI void APIENTRY glUnmapTexture2DINTEL (GLuint texture, GLint level);
' ========================================================================================
DECLARE SUB glUnmapTexture2DINTEL (BYVAL dwtexture AS DWORD, BYVAL nlevel AS LONG)

' ========================================================================================
' GLAPI GLvoid* APIENTRY glMapTexture2DINTEL (GLuint texture, GLint level, GLbitfield access, const GLint *stride, const GLenum *layout);
' ========================================================================================
DECLARE FUNCTION glMapTexture2DINTEL (BYVAL dwtexture AS DWORD, BYVAL nlevel AS LONG, BYVAL dwaccess AS DWORD, BYREF stride AS LONG, BYREF layout AS DWORD) AS DWORD

#ENDIF

#IF NOT %DEF(%GL_NV_draw_texture)
%GL_NV_draw_texture = 1

' ========================================================================================
' GLAPI void APIENTRY glDrawTextureNV (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
' ========================================================================================
DECLARE SUB glDrawTextureNV (BYVAL dwtexture AS DWORD, BYVAL sampler AS DWORD, BYVAL x0 AS SINGLE, BYVAL y0 AS SINGLE, _
   BYVAL x1 AS SINGLE, BYVAL y1 AS SINGLE, BYVAL z AS SINGLE, BYVAL s0 AS SINGLE, BYVAL t0 AS SINGLE, BYVAL s1 AS SINGLE, BYVAL t1 AS SINGLE)

#ENDIF
