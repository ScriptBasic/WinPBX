# Preprocessor Directives

Preprocessor directives are lines included in the code of programs preceded by a hash sign (#). These lines are not program statements but directives for the preprocessor. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements. They can be used to include headers or other source files, conditional compilation of blocks of code, define small inline functions (macros), alter how the compiler handles variables and parameter passing and other uses.

| Name       | Description |
| ---------- | ----------- |
| [#alert](#alert) | Generates a compiler message (like an error). |
| [#assign](#assign) | Emulates the C convention for the `=` operator. |
| [#autodim](#autodim) | Enables variables to be created without a `dim` statement. |
| [#blockdepth](#blockdepth) | Returns the nesting depth of a block. |
| [#byref](#byref) | Specifies that parameters must be passed using its address instead of its value. |
| [#byval](#byval) | Specifies that parameters must be passed by value instead of by reference. |
| [#case](#case) | Specifies the case sensitivity mode. |
| [#compact](#compact) | Removes unused code. |
| [#console](#console) | Prevents the creation of a new console. |
| [#cpointer](#cpointer) | Specifies to use C-like syntax with pointers. |
| [#def](#def) | Defines a low level macro. |
| [#define](#define) | Defines a preprocessor macro. |
| [#dim](#dim) | Specifies the datatype to be used when this is unspecified. |
| [#else](#else) |  |
| [#elseif](#elseif) |  |
| [#endif](#endif) |  |
| [#endv](#endv) |  |
| [#error](#error) |  |
| [#file](#file) |  |
| [#if](#if) |  |
| [#ifdef](#ifdef) |  |
| [#ifndef](#ifndef) |  |
| [#include](#include) |  |
| [#lookahead](#lookahead) |  |
| [#noinit](#noinit) |  |
| [#noprec](#noprec) |  |
| [#pragma](#pragma) |  |
| [#print](#print) |  |
| [#recordof](#recordof) |  |
| [#semicolon](#semicolon) |  |
| [#show](#show) |  |
| [#undef](#undef) |  |
| [#undefine](#undefine) |  |
| [#unique](#unique) |  |
| [#view](#view) |  |

# <a name="#alert"></a>#alert

Generates a compiler message (like an error).

Used to alert programmer about an area of code that requires attention.

#### Example

```
#alert (please implement methods for this interface)
```

# <a name="#assign"></a>#assign

Emulates the C convention for the `=` operator.

When `assign` is on, `=` acts always as an assignment operator in conditional statements and `==` must be used to test equality.
 
#### Example

```
#assign on
if hresult = QueryInterface(gu, ob) then ...
```

# <a name="#autodim"></a>#autodim

Enables variables to be created without a `dim` statement. The type is implied from the initializer expression.

#### Example

```
#autodim on
v = 123
print v
```

# <a name="#blockdepth"></a>#blockdepth

Returns the nesting depth of a block at compile time.

This command was introduced to catch unclosed blocks which are often hard to trace.

#### Example

```
#blockdepth node x   ' use any descriptive label on the line
```

# <a name="#byref"></a>#byref

Specifies that parameters must be passed using its address instead of its value.

#### Example

```
#byref on
```

# <a name="#byval"></a>#byval

Specifies that parameters must be passed by value instead of by reference.

#### Example

```
#byval on
```

# <a name="#case"></a>#case

Specifies the case sensitivity mode: `sensitive`, `insensitive`, or `capital`.

`#case insensitive`  ' converts words to lowercase (this is the default)<br>
`#case sensitive`    ' no case conversion, like the C language<br>
`#case capital`      ' converts words to lowercase, except for all-uppercase words

`#case` has block scope and reverts to its previous state when the block ends.
 
#### Example

```
#case sensitive
```

# <a name="#compact"></a>#compact

Removes unused unused methods from classes, as well as unused general functions.

#### Example

```
#compact on
```

# <a name="#console"></a>#console

Prevents the creation of a new console. Inputs and outputs will use the existing console.

#### Example

```
#console
```

Programs compiled to EXE/DLL will run in an existing console (MS Subsystem 3) 
 
#### Remark

When Oxygen is embedded it will use the host's subsystem.


# <a name="#cpointer"></a>#cpointer

Specifies to use C-like syntax with pointers.

#### Example

Wrapping code between `#cpointer on`and `#cpointer off` directives allows to use explicit pointers that are deferenced with the `*` operator:

```
#cpointer on
dim x as long = 123456
dim p as long ptr = @x
print *p
#cpointer off
```

instead of:

```
dim x as long = 123456
dim p as long ptr
@p = @x
print p
```

By default, Oxygen Basic uses a novelty syntax style to avoid the use of explicit pointers. This applies uniformly to objects, functions and variables. Also to COM objects. Once an indirect variable is given an address, no further pointer notation is required.

The principle is that once an indirect variable is provided with an address, it is treated just like a normal variable. This is exactly how byref parameters work within functions for most basics.

# <a name="#def"></a>#def

Defines a low level macro. `#def` and `def` are the same.

#### Example

```
#def show "%1: " %1
int x = 123
print show x
```

# <a name="#define"></a>#define

Defines a preprocessor macro.

#### Syntax

```
#define identifier replacement
```

When the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code by replacement. This replacement can be an expression, a statement, a block or simply anything.

#### Example

```
#define x 32
#define False 0
#define True (not False)
```

Defines are scoped; they are only visible in the scope they were defined in.

#### Example

```
#define x 45

scope
#define x 32
   print x   ' output: 32
end scope

print x   ' output: 45
```

# <a name="#dim"></a>#dim

Specifies the datatype to be used when this is unspecified.

#### Example

```
#dim float
```

The type (or class) must be defined already.
